DROP DATABASE IF EXISTS Smart_Buildings;
CREATE DATABASE Smart_Buildings;
SET @timer = CURRENT_TIME();
SET FOREIGN_KEY_CHECKS = 0;
SET SQL_SAFE_UPDATES = 0;
USE Smart_Buildings;

# CREAZIONE TABELLE

DROP TABLE IF EXISTS Edificio;
CREATE TABLE Edificio (
	ID INT AUTO_INCREMENT PRIMARY KEY,
    Stato FLOAT NOT NULL,
    Tipologia VARCHAR(50) NOT NULL,
	Locazione INT NOT NULL,
    FOREIGN KEY(Locazione) REFERENCES AreaGeografica(ID_Area)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Pianta;
CREATE TABLE Pianta(
	Codice_Pianta INT AUTO_INCREMENT PRIMARY KEY,
    Edificio INT NOT NULL,
    NumeroPiano INT NOT NULL,
    FOREIGN KEY(Edificio) REFERENCES Edificio(ID)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Vano;
CREATE TABLE Vano(
	Codice_Vano INT AUTO_INCREMENT PRIMARY KEY,
    Funzione VARCHAR(50) NOT NULL,
    AltezzaMax FLOAT NOT NULL, # IN METRI
	LunghezzaMax FLOAT DEFAULT NULL, # IN METRI
    LarghezzaMax FLOAT DEFAULT NULL, # IN METRI
    Pianta INT NOT NULL,
    Pavimentazione VARCHAR(50) DEFAULT NULL,
	FOREIGN KEY(Pianta) REFERENCES Pianta(Codice_Pianta) 
		ON DELETE CASCADE
		ON UPDATE CASCADE,
    FOREIGN KEY(Pavimentazione) REFERENCES Piastrelle(Codice_Lotto)
		ON DELETE NO ACTION
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Muro;
CREATE TABLE Muro(
	Codice_Muro INT AUTO_INCREMENT PRIMARY KEY,
    Vano1 INT NOT NULL,
    Vano2 INT,
    X1 FLOAT NOT NULL,
    Y1 FLOAT NOT NULL,
    X2 FLOAT NOT NULL,
    Y2 FLOAT NOT NULL,
    FOREIGN KEY(Vano1) REFERENCES Vano(Codice_Vano),
    FOREIGN KEY(Vano2) REFERENCES Vano(Codice_Vano)
		ON DELETE CASCADE
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Apertura;
CREATE TABLE Apertura(
	Codice_Apertura INT AUTO_INCREMENT PRIMARY KEY,
    Muro INT NOT NULL,
    X1 FLOAT NOT NULL,
    Y1 FLOAT NOT NULL,
    X2 FLOAT NOT NULL,
    Y2 FLOAT NOT NULL,
    Balcone BOOL DEFAULT FALSE,
    Tipologia VARCHAR(50) NOT NULL,
    FOREIGN KEY(Muro) REFERENCES Muro(Codice_muro)
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS ProgettoEdilizio;
CREATE TABLE ProgettoEdilizio(
	ID_Progetto INT AUTO_INCREMENT PRIMARY KEY,
    Tipo VARCHAR(50) NOT NULL,
    DataApprovazione DATE NOT NULL, 
    DataInizio DATE NOT NULL, 
    StimaFine DATE NOT NULL,
    DataFine DATE,
    Edificio INT NOT NULL,
    FOREIGN KEY(Edificio) REFERENCES Edificio(ID)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS StadioDiAvanzamento;
CREATE TABLE StadioDiAvanzamento(
	Progetto INT,
    Numero INT,
    DataInizio DATE,
    StimaFine DATE,
    DataFine DATE,
    Tipologia VARCHAR(50) NOT NULL,
    CostoPreventivato FLOAT NOT NULL,
    PRIMARY KEY(Numero, Progetto),
    FOREIGN KEY(Progetto) REFERENCES ProgettoEdilizio(ID_Progetto)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS TipologiaLavoro;
CREATE TABLE TipologiaLavoro(
	Nome VARCHAR(50) PRIMARY KEY,
    NumeroMinimoLavoratori INT NOT NULL,
    NumeroMassimoLavoratori INT NOT NULL,
    TempoStimato INT NOT NULL # In giorni
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Lavoro;
CREATE TABLE Lavoro(
	Codice_Lavoro INT AUTO_INCREMENT PRIMARY KEY,
	TipologiaDiLavoro VARCHAR(50) NOT NULL,
    DataInizio DATE NOT NULL, 
    DataFine DATE,
    Costo FLOAT DEFAULT NULL,
	Progetto INT NOT NULL,
    StadioDiAvanzamento INT NOT NULL,
    FOREIGN KEY(StadioDiAvanzamento) REFERENCES StadioDiAvanzamento(Numero)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION,
    FOREIGN KEY(Progetto) REFERENCES StadioDiAvanzamento(Progetto)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION,
    FOREIGN KEY(TipologiaDiLavoro) REFERENCES TipologiaLavoro(Nome)
		ON DELETE NO ACTION
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Lavoratore;
CREATE TABLE Lavoratore(
	CodiceFiscale VARCHAR(50) PRIMARY KEY,
    Nome VARCHAR(50) NOT NULL,
    Cognome VARCHAR(50) NOT NULL,
    Sesso VARCHAR(1) NOT NULL, # M, F, A
    Stipendio FLOAT NOT NULL, # Mensile in Euro
    DataNascita DATE NOT NULL,
    DataAssunzione DATE NOT NULL,
    Pensione BOOL DEFAULT FALSE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Capocantiere;
CREATE TABLE Capocantiere(
	CodiceFiscale VARCHAR(50) PRIMARY KEY,
    Nome VARCHAR(50) NOT NULL,
    Cognome VARCHAR(50) NOT NULL,
    Sesso VARCHAR(1) NOT NULL, # M, F, A
    Stipendio FLOAT NOT NULL, # Mensile in Euro
    DataNascita DATE NOT NULL,
    DataAssunzione DATE NOT NULL,
	Pensione BOOL DEFAULT FALSE,
    NumeroMassimoLavoratori INT NOT NULL
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Responsabile;
CREATE TABLE Responsabile(
	CodiceFiscale VARCHAR(50) PRIMARY KEY,
    Nome VARCHAR(50) NOT NULL,
    Cognome VARCHAR(50) NOT NULL,
    Sesso VARCHAR(1) NOT NULL, # M, F, A
    Stipendio FLOAT NOT NULL, # Mensile in Euro
    DataNascita DATE NOT NULL,
    DataAssunzione DATE NOT NULL,
	Pensione BOOL DEFAULT FALSE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Turni_Di_Lavoro_Lavoratore;
CREATE TABLE Turni_Di_Lavoro_Lavoratore(
	Lavoro INT,
	CodiceFiscale VARCHAR(50),
    OrarioInizio TIME,
    OrarioFine TIME,
    OrePausa INT,
    GiornoLibero INT, # Da 2 a 7
    PRIMARY KEY(Lavoro, CodiceFiscale),
    FOREIGN KEY(CodiceFiscale) REFERENCES Lavoratore(CodiceFiscale)
		ON DELETE NO ACTION
		ON UPDATE CASCADE,
    FOREIGN KEY(Lavoro) REFERENCES Lavoro(Codice_Lavoro)
		ON DELETE NO ACTION
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1; 

DROP TABLE IF EXISTS Turni_Di_Lavoro_Capocantiere;
CREATE TABLE Turni_Di_Lavoro_Capocantiere(
	Lavoro INT,
	CodiceFiscale VARCHAR(50),
    OrarioInizio TIME,
    OrarioFine TIME,
    OrePausa INT,
    GiornoLibero INT, # Da 2 a 7
    PRIMARY KEY(Lavoro, CodiceFiscale),
    FOREIGN KEY(CodiceFiscale) REFERENCES Capocantiere(CodiceFiscale)
		ON DELETE NO ACTION
		ON UPDATE CASCADE,
    FOREIGN KEY(Lavoro) REFERENCES Lavoro(Codice_Lavoro)
		ON DELETE NO ACTION
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Turni_Di_lavoro_Responsabile;
CREATE TABLE Turni_Di_Lavoro_Responsabile(
	Lavoro INT,
	CodiceFiscale VARCHAR(50),
    OrarioInizio TIME,
    OrarioFine TIME,
    OrePausa INT,
    GiornoLibero INT, # Da 2 a 7
    PRIMARY KEY(Lavoro, CodiceFiscale),
    FOREIGN KEY(CodiceFiscale) REFERENCES Responsabile(CodiceFiscale)
		ON DELETE NO ACTION
		ON UPDATE CASCADE,
    FOREIGN KEY(Lavoro) REFERENCES Lavoro(Codice_Lavoro)
		ON DELETE NO ACTION
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Responsabilita;
CREATE TABLE Responsabilita(
	Responsabile VARCHAR(50),
    Progetto INT,
    PRIMARY KEY(Responsabile, Progetto),
    FOREIGN KEY(Responsabile) REFERENCES Responsabile(CodiceFiscale)
		ON DELETE NO ACTION
		ON UPDATE CASCADE,
    FOREIGN KEY(Progetto) REFERENCES ProgettoEdilizio(ID_Progetto)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS AreaGeografica;
CREATE TABLE AreaGeografica(
	ID_Area INT PRIMARY KEY,
    Nome VARCHAR(50),
    Nazione VARCHAR(50)
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS PericoloGeologico;
CREATE TABLE PericoloGeologico(
	Area INT,
    Pericolo VARCHAR(50),
    CoefficienteRischio FLOAT,
    PRIMARY KEY(Area, Pericolo),
    FOREIGN KEY(Area) REFERENCES AreaGeografica(ID_Area)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Calamita;
CREATE TABLE Calamita(
	Area INT NOT NULL, 
	Data DATE NOT NULL,
    Orario TIME NOT NULL,
	Nome VARCHAR(50) NOT NULL,
    Epicentro FLOAT NOT NULL, # IN KM
    Intensita INT NOT NULL,
    PRIMARY KEY(Area, Data, Orario),
    FOREIGN KEY(Area) REFERENCES AreaGeografica(ID_Area)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS AltriMateriali;
CREATE TABLE AltriMateriali(
	Codice_Lotto VARCHAR(50) PRIMARY KEY,
    Nome VARCHAR(50) NOT NULL,
    QuantitaComprata FLOAT NOT NULL, # IN KG
    QuantitaStoccata FLOAT NOT NULL, # IN KG
    Fornitore VARCHAR(50) NOT NULL,
    Costo FLOAT NOT NULL, # IN EURO
    DataAcquisto DATE NOT NULL
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Intonaco;
CREATE TABLE Intonaco(
	Codice_Lotto VARCHAR(50) PRIMARY KEY,
    Nome VARCHAR(50) NOT NULL,
    QuantitaComprata FLOAT NOT NULL, # IN KG
    QuantitaStoccata FLOAT NOT NULL, # IN KG
    Fornitore VARCHAR(50) NOT NULL,
    Costo FLOAT NOT NULL, # IN EURO
    DataAcquisto DATE NOT NULL,
    Colore VARCHAR(50) NOT NULL
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Mattoni;
CREATE TABLE Mattoni(
	Codice_Lotto VARCHAR(50) PRIMARY KEY,
    Nome VARCHAR(50) NOT NULL,
    QuantitaComprata FLOAT NOT NULL, # IN KG
    QuantitaStoccata FLOAT NOT NULL, # IN KG
    Fornitore VARCHAR(50) NOT NULL,
    Costo FLOAT NOT NULL, # IN EURO
    DataAcquisto DATE NOT NULL,
    Alveolatura VARCHAR(50) NOT NULL
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Piastrelle;
CREATE TABLE Piastrelle(
	Codice_Lotto VARCHAR(50) PRIMARY KEY,
    Nome VARCHAR(50) NOT NULL,
    QuantitaComprata FLOAT NOT NULL, # IN KG
    QuantitaStoccata FLOAT NOT NULL, # IN KG
    Fornitore VARCHAR(50) NOT NULL,
    Costo FLOAT NOT NULL, # IN EURO
    DataAcquisto DATE NOT NULL,
    Forma VARCHAR(50) NOT NULL,
    Fuga INT NOT NULL # IN MM
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Pietre;
CREATE TABLE Pietre(
	Codice_Lotto VARCHAR(50) PRIMARY KEY,
    Nome VARCHAR(50) NOT NULL,
    QuantitaComprata FLOAT NOT NULL, # IN KG
    QuantitaStoccata FLOAT NOT NULL, # IN KG
    Fornitore VARCHAR(50) NOT NULL,
    Costo FLOAT NOT NULL, # IN EURO
    DataAcquisto DATE NOT NULL,
    Spessore INT NOT NULL # IN MM
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Strato;
CREATE TABLE Strato(
	Muro INT NOT NULL,
	Lotto_Intonaco VARCHAR(50),
    Spessore FLOAT, # IN CM
    PRIMARY KEY(Muro, Lotto_Intonaco),
    FOREIGN KEY(Lotto_Intonaco) REFERENCES Intonaco(Codice_Lotto)
		ON DELETE NO ACTION
		ON UPDATE CASCADE,
    FOREIGN KEY(Muro) REFERENCES Muro(Codice_Muro)
		ON DELETE CASCADE
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Muratura;
CREATE TABLE Muratura(
	Muro INT NOT NULL,
	Lotto_Mattoni VARCHAR(50),
    PRIMARY KEY(Muro, Lotto_Mattoni),
    FOREIGN KEY(Lotto_Mattoni) REFERENCES Mattoni(Codice_Lotto)
		ON DELETE NO ACTION
		ON UPDATE CASCADE,
    FOREIGN KEY(Muro) REFERENCES Muro(Codice_Muro)
		ON DELETE CASCADE
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Decorazione;
CREATE TABLE Decorazione(
	Muro INT NOT NULL,
	Lotto_Pietre VARCHAR(50),
    Disposizione VARCHAR(50),
    PRIMARY KEY(Muro, Lotto_Pietre),
    FOREIGN KEY(Lotto_Pietre) REFERENCES Pietre(Codice_Lotto)
		ON DELETE NO ACTION
		ON UPDATE CASCADE,
    FOREIGN KEY(Muro) REFERENCES Muro(Codice_Muro)
		ON DELETE CASCADE
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS ImpiegoAltriMateriali;
CREATE TABLE ImpiegoAltriMateriali(
	Lavoro INT,
	Lotto_Altri_Materiali VARCHAR(50),
    Quantita FLOAT NOT NULL, # IN KG
    PRIMARY KEY(Lavoro, Lotto_Altri_Materiali),
    FOREIGN KEY(Lotto_Altri_Materiali) REFERENCES AltriMateriali(Codice_Lotto)
		ON DELETE NO ACTION
		ON UPDATE CASCADE,
    FOREIGN KEY(Lavoro) REFERENCES Lavoro(Codice_Lavoro)
		ON DELETE NO ACTION
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS ImpiegoIntonaco;
CREATE TABLE ImpiegoIntonaco(
	Lavoro INT,
	Lotto_Intonaco VARCHAR(50),
	Quantita FLOAT NOT NULL, # IN KG
    PRIMARY KEY(Lavoro, Lotto_Intonaco),
    FOREIGN KEY(Lotto_Intonaco) REFERENCES Intonaco(Codice_Lotto)
		ON DELETE NO ACTION
		ON UPDATE CASCADE,
    FOREIGN KEY(Lavoro) REFERENCES Lavoro(Codice_Lavoro)
		ON DELETE NO ACTION
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS ImpiegoMattoni;
CREATE TABLE ImpiegoMattoni(
	Lavoro INT,
	Lotto_Mattoni VARCHAR(50),
    Quantita FLOAT NOT NULL, # IN KG
    PRIMARY KEY(Lavoro, Lotto_Mattoni),
    FOREIGN KEY(Lotto_Mattoni) REFERENCES Mattoni(Codice_Lotto)
		ON DELETE NO ACTION
		ON UPDATE CASCADE,
    FOREIGN KEY(Lavoro) REFERENCES Lavoro(Codice_Lavoro)
		ON DELETE NO ACTION
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS ImpiegoPiastrelle;
CREATE TABLE ImpiegoPiastrelle(
	Lavoro INT,
	Lotto_Piastrelle VARCHAR(50),
    Quantita FLOAT NOT NULL, # IN KG
    PRIMARY KEY(Lavoro, Lotto_Piastrelle),
    FOREIGN KEY(Lotto_Piastrelle) REFERENCES Piastrelle(Codice_Lotto)
		ON DELETE NO ACTION
		ON UPDATE CASCADE,
    FOREIGN KEY(Lavoro) REFERENCES Lavoro(Codice_Lavoro)
		ON DELETE NO ACTION
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS ImpiegoPietre;
CREATE TABLE ImpiegoPietre(
	Lavoro INT,
	Lotto_Pietre VARCHAR(50),
    Quantita FLOAT NOT NULL, # IN KG
    PRIMARY KEY(Lavoro, Lotto_Pietre),
    FOREIGN KEY(Lotto_Pietre) REFERENCES Pietre(Codice_Lotto)
		ON DELETE NO ACTION
		ON UPDATE CASCADE,
    FOREIGN KEY(Lavoro) REFERENCES Lavoro(Codice_Lavoro)
		ON DELETE NO ACTION
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Soffitto;
CREATE TABLE Soffitto(
	Vano INT, 
    Lotto_Pietre VARCHAR(50),
    PRIMARY KEY(Vano, Lotto_Pietre),
    FOREIGN KEY(Vano) REFERENCES Vano(Codice_Vano)
		ON DELETE CASCADE
		ON UPDATE CASCADE,
    FOREIGN KEY(Lotto_Pietre) REFERENCES Pietre(Codice_Lotto)
		ON DELETE NO ACTION
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Sensore;
CREATE TABLE Sensore(
	Codice_Seriale INT,
    Categoria VARCHAR(50),
    UnitaMisura VARCHAR(10),
    Alert FLOAT NOT NULL,
    Vano INT NOT NULL,
    PRIMARY KEY(Codice_Seriale, Categoria),
    FOREIGN KEY(Vano) REFERENCES Vano(Codice_Vano) 
		ON DELETE CASCADE
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Registrazione;
CREATE TABLE Registrazione(
	ID_Sensore INT,
    TipoSensore VARCHAR(50),
	Data DATE NOT NULL,
	Orario TIME NOT NULL,
    ValoreRegistrato FLOAT,
    PRIMARY KEY(ID_Sensore, TipoSensore, Data),
    FOREIGN KEY(ID_Sensore, TipoSensore) REFERENCES Sensore(Codice_Seriale, Categoria)
		ON DELETE CASCADE
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Danno;
CREATE TABLE Danno(
	Codice_Danno INT AUTO_INCREMENT PRIMARY KEY,
    Zona VARCHAR(50),
    Entita FLOAT NOT NULL,
    Riparato BOOL DEFAULT FALSE,
    Edificio INT NOT NULL,
    FOREIGN KEY(Edificio) REFERENCES Edificio(ID)
		ON DELETE NO ACTION
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Ristrutturazione;
CREATE TABLE Ristrutturazione(
	Danno INT,
    Lavoro INT,
    PRIMARY KEY(Danno, Lavoro),
    FOREIGN KEY(Lavoro) REFERENCES Lavoro(Codice_Lavoro)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION,
    FOREIGN KEY(Danno) REFERENCES Danno(Codice_Danno)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS CausaDanneggiamento;
CREATE TABLE CausaDanneggiamento(
	Danno INT,
    Area INT,
    Data DATE,
    Orario TIME,
    PRIMARY KEY(Danno, Area, Data, Orario),
    FOREIGN KEY(Area, Data, Orario) REFERENCES Calamita(Area, Data, Orario)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION,
    FOREIGN KEY(Danno) REFERENCES Danno(Codice_Danno)
		ON DELETE NO ACTION
		ON UPDATE NO ACTION
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

DROP TABLE IF EXISTS Crepa;
CREATE TABLE Crepa(
    Codice_Crepa INT AUTO_INCREMENT,
    Muro INT NOT NULL,
    UltimaLunghezzaRegistrata FLOAT NOT NULL,
    UnitaMisura VARCHAR(10) NOT NULL,
    UltimaAngolazioneRegistrata FLOAT NOT NULL,
    AlertLunghezza FLOAT NOT NULL,
    AlertAngolo FLOAT NOT NULL,
    Entita FLOAT DEFAULT 0,
    Riparato BOOL DEFAULT FALSE,
    PRIMARY KEY(Codice_Crepa),
    FOREIGN KEY(Muro) REFERENCES Muro(Codice_Muro) 
		ON DELETE CASCADE
		ON UPDATE CASCADE
) ENGINE = InnoDB DEFAULT CHARSET = latin1;

SET FOREIGN_KEY_CHECKS = 1;

# FUNZIONI DI UTILITÀ

# Restituisce TRUE se x è compreso tra y1 e y2 senza però uguagliare y1 o y2, altrimenti restituisce FALSE
DROP FUNCTION IF EXISTS Compreso_Senza_Estremi;
DELIMITER $$
CREATE FUNCTION Compreso_Senza_Estremi(x FLOAT, y1 FLOAT, y2 FLOAT)
RETURNS BOOL DETERMINISTIC
BEGIN
	DECLARE inter BOOL DEFAULT FALSE;
    DECLARE max FLOAT DEFAULT 0;
    DECLARE min FLOAT DEFAULT 0;
    
    IF 
		y1 > y2
	THEN 
		SET max = y1;
        SET min = y2;
	ELSEIF
		y1 <= y2
	THEN 
		SET max = y2;
        SET min = y1;
	END IF;
        
	IF
		(x BETWEEN min AND max AND x <> y1 AND x <> y2) OR (x = min AND x = max)
    THEN
		SET inter = TRUE ;
	END IF;
    
	RETURN inter;
END $$
DELIMITER ;

DROP FUNCTION IF EXISTS Minimo;
DELIMITER $$
CREATE FUNCTION Minimo(x FLOAT, y FLOAT)
RETURNS FLOAT DETERMINISTIC
BEGIN
	DECLARE min FLOAT DEFAULT x;
    
	IF 
		x > y
	THEN 
		SET min = y;
	END IF;
    
    RETURN min;
END $$
DELIMITER ;

DROP FUNCTION IF EXISTS Massimo;
DELIMITER $$
CREATE FUNCTION Massimo(x FLOAT, y FLOAT)
RETURNS FLOAT DETERMINISTIC
BEGIN
	DECLARE max FLOAT DEFAULT x;
    
	IF 
		y > x 
	THEN 
		SET max = y;
	END IF;

	RETURN max;
END $$
DELIMITER ;

# Funzione che dato due segmenti in input, restituisce TRUE se si intersecano e FALSE altrimenti (per Muri)
DROP FUNCTION IF EXISTS Intersezione;
DELIMITER $$
CREATE FUNCTION Intersezione(x1 FLOAT, y1 FLOAT, x2 FLOAT, y2 FLOAT, x3 FLOAT, y3 FLOAT, x4 FLOAT, y4 FLOAT)
RETURNS BOOL DETERMINISTIC 
BEGIN
	DECLARE intersezione BOOL DEFAULT FALSE;
	DECLARE m, q, _m, _q FLOAT DEFAULT 0;
	DECLARE x_inter, y_inter FLOAT DEFAULT 0;
    
	IF 
		x1 <> x2 AND x3 <> x4
	THEN 
		SET m = (y2 - y1) / (x2 - x1) ;
		SET _m = (y4 - y3) / (x4 - x3) ;
		SET q = y1 - m * x1 ;
		SET _q = y3 - _m * x3 ;
		IF 
			m <> _m
		THEN
			SET x_inter = (q - _q) / (_m - m) ;
			SET y_inter = m * x_inter + q;
            
			# Controllo che il punto appartenga ai due segmenti
			IF 
				Compreso_Senza_Estremi(x_inter, x1, x2) = TRUE AND Compreso_Senza_Estremi(x_inter, x3, x4) = TRUE
            THEN 
				IF 
					Compreso_Senza_Estremi(y_inter, y1, y2) = TRUE AND Compreso_Senza_Estremi(y_inter, y3, y4) = TRUE
				THEN
					SET intersezione = TRUE;
				END IF;
			END IF; 
		END IF;
	ELSEIF 
		x1 <> x2 AND x3 = x4
	THEN
		SET m = (y2 - y1) / (x2 - x1) ;
		SET q = y1 - m * X1 ;
		SET x_inter = x3;
		SET y_inter = m * x_inter + q;
		IF 
			 Compreso_Senza_Estremi(x_inter, x1, x2) = TRUE 
        THEN 
			IF 
				Compreso_Senza_Estremi(y_inter, y1, y2) = TRUE AND Compreso_Senza_Estremi(y_inter, y3, y4) = TRUE
			THEN
					SET intersezione = TRUE;
			END IF;
		END IF;
	ELSEIF 
		x1 = x2 AND x3 <> x4
	THEN
		SET m = (y4 - y3) / (x4 - x3);
		SET q = y3 - m * x3 ;
		SET x_inter = x1;
		SET y_inter = m * x1 + q;
		IF 
			Compreso_Senza_Estremi(x_inter, x3, x4) = TRUE 
		THEN
			IF 
				Compreso_Senza_Estremi(y_inter, y1, y2) = TRUE AND Compreso_Senza_Estremi(y_inter, y3, y4) = TRUE
			THEN
				SET intersezione = TRUE;
			END IF;
		END IF;
	END IF;
    
	RETURN intersezione;
END $$
DELIMITER ;

# Funzione che dati due segmenti in input, restituisce TRUE se si intersecano e FALSE altrimenti, compresi gli estremi (per Aperture)
DROP FUNCTION IF EXISTS Intersezione_con_estremi;
DELIMITER $$
CREATE FUNCTION Intersezione_con_estremi(x1 FLOAT, y1 FLOAT, x2 FLOAT, y2 FLOAT, x3 FLOAT, y3 FLOAT, x4 FLOAT, y4 FLOAT)
RETURNS BOOL DETERMINISTIC 
BEGIN
	DECLARE intersezione BOOL DEFAULT FALSE;
	DECLARE m, q, _m, _q FLOAT DEFAULT 0;
	DECLARE x_inter, y_inter FLOAT DEFAULT 0;
    DECLARE cambio FLOAT DEFAULT 0;
    
    IF
		x1 > x2
    THEN
		SET cambio = x2;
        SET x2 = x1;
        SET x1 = cambio;
    END IF;
    
    IF
		x3 > x4
    THEN
		SET cambio = x3;
        SET x3 = x4;
        SET x4 = cambio;
    END IF;
    
    IF
		y1 > y2
    THEN
		SET cambio = y2;
        SET y2 = y1;
        SET y1 = cambio;
    END IF;
    
    IF
		y3 > y4
    THEN
		SET cambio = y3;
        SET y3 = y4;
        SET y4 = cambio;
    END IF;
    
	IF 
		x1 <> x2 AND x3 <> x4
	THEN 
		SET m = (y2 - y1) / (x2 - x1) ;
		SET _m = (y4 - y3) / (x4 - x3) ;
		SET q = y1 - m * x1 ;
		SET _q = y3 - _m * x3 ;
		IF 
			m <> _m
		THEN
			SET x_inter = (q - _q) / (_m - m) ;
			SET y_inter = x_inter * m + q;
            
			# Controllo che il punto appartenga ai due segmenti
			IF 
				(x_inter BETWEEN x1 AND x2 = TRUE OR x_inter BETWEEN x2 AND x1 = TRUE)
                AND (x_inter BETWEEN x3 AND x4 = TRUE OR x_inter BETWEEN x4 AND x3)
            THEN 
				IF 
					(y_inter BETWEEN y1 AND y2 = TRUE OR y_inter BETWEEN y2 AND y1 = TRUE) 
                    AND (y_inter BETWEEN y3 AND y4 = TRUE OR y_inter BETWEEN y4 AND y3)
				THEN
					SET intersezione = TRUE;
				END IF;
			END IF; 
		END IF;
	ELSEIF 
		x1 <> x2 AND x3 = x4
	THEN
		SET m = (y2 - y1) / (x2 - x1) ;
		SET q = y1 - m * x1 ;
		SET x_inter = x3;
		SET y_inter = m * x_inter + q;
		IF 
			(x_inter BETWEEN x1 AND x2 = TRUE OR x_inter BETWEEN x2 AND x1 = TRUE)
        THEN 
			IF 
				(y_inter BETWEEN y1 AND y2 = TRUE OR y_inter BETWEEN y2 AND y1 = TRUE) 
				AND (y_inter BETWEEN y3 AND y4 = TRUE OR y_inter BETWEEN y4 AND y3)
			THEN
					SET intersezione = TRUE;
			END IF;
		END IF;
	ELSEIF 
		x3 <> x4 AND x1 = x2
	THEN
		SET m = (y4 - y3) / (x4 - x3);
		SET q = y3 - m * x3 ;
		SET x_inter = x1;
		SET y_inter = m * x1 + q;
		IF 
			(x_inter BETWEEN x3 AND x4 = TRUE OR x_inter BETWEEN x4 AND x3)
		THEN
			IF 
				(y_inter BETWEEN y1 AND y2 = TRUE OR y_inter BETWEEN y2 AND y1 = TRUE) 
				AND (y_inter BETWEEN y3 AND y4 = TRUE OR y_inter BETWEEN y4 AND y3)
			THEN
				SET intersezione = TRUE;
			END IF;
		END IF;
	END IF;
    
	RETURN intersezione;
END $$
DELIMITER ;

# Funzione che calcola l'Intersezione per le Aperture
DROP PROCEDURE IF EXISTS Intersezione_Aperture;
DELIMITER $$
CREATE PROCEDURE Intersezione_Aperture(IN x FLOAT, IN y FLOAT, IN cod_vano INT, INOUT numero_intersezioni INT)
BEGIN
	DECLARE finito INT DEFAULT 0;
    DECLARE v1_x, v1_y, v2_x, v2_y FLOAT DEFAULT 0;
	
    DECLARE vertici CURSOR FOR
		SELECT X1, Y1, X2, Y2
        FROM Muro
        WHERE Vano1 = cod_vano OR Vano2 IS NOT NULL AND Vano2 = cod_vano;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
    
    DROP TABLE IF EXISTS TEMP_Vertici_Intersezione;
    
	CREATE TABLE TEMP_Vertici_Intersezione
	(
		X FLOAT NOT NULL,
		Y FLOAT NOT NULL,
        PRIMARY KEY(X, Y)
	);
    
    OPEN vertici;
	ciclo: LOOP
		FETCH vertici INTO v1_x, v1_y, v2_x, v2_y;
        
        IF finito = 1 THEN LEAVE ciclo; END IF;
        
        IF
			Intersezione_con_estremi(v1_x, v1_y, v2_x, v2_y, x, y, Massimo(v1_x, v2_x) + 0.0001, y) = TRUE
		THEN
			IF
				(v1_x NOT IN (
							SELECT VI.X
                            FROM TEMP_Vertici_Intersezione VI
						    )
				 AND
				 v1_y NOT IN (
							SELECT VI.Y
                            FROM TEMP_Vertici_Intersezione VI
							))
				OR
                (v2_x NOT IN (
							SELECT VI.X
                            FROM TEMP_Vertici_Intersezione VI
							)
				 AND
				 v2_y NOT IN (
							SELECT VI.Y
                            FROM TEMP_Vertici_Intersezione VI
							))
            THEN
				INSERT INTO TEMP_Vertici_Intersezione(X, Y)
				VALUES (v1_x, v1_y),
					   (v2_x, v2_y);
                SET numero_intersezioni = numero_intersezioni + 1;
			ELSE 
				IF
					v1_x IN (
								SELECT VI.X
								FROM TEMP_Vertici_Intersezione VI
							)
					OR
					v1_y IN (
								SELECT VI.Y
								FROM TEMP_Vertici_Intersezione VI
							 )
                THEN
					INSERT INTO TEMP_Vertici_Intersezione(X, Y)
					VALUES (v2_x, v2_y);
                ELSEIF
					v2_x IN (
								SELECT VI.X
								FROM TEMP_Vertici_Intersezione VI
							)
					OR
					v2_y IN (
								SELECT VI.Y
								FROM TEMP_Vertici_Intersezione VI
							 )
                THEN
					INSERT INTO TEMP_Vertici_Intersezione(X, Y)
					VALUES (v1_x, v1_y);
                END IF;
            END IF;
		END IF;
    END LOOP;
    CLOSE vertici;
    
    DROP TABLE IF EXISTS TEMP_Vertici_Intersezione;
END $$
DELIMITER ;

# Funzione che date due date in input restituisce in output la differenza tra queste due date senza contare Sabato e Domenica
DROP FUNCTION IF EXISTS Differenza_Date_Senza_Weekend;
DELIMITER $$
CREATE FUNCTION Differenza_Date_Senza_Weekend(data1 DATE, data2 DATE)
RETURNS INT DETERMINISTIC
BEGIN 
	DECLARE differenza INT DEFAULT 0;
	SET differenza = ABS(DATEDIFF(data1, data2)) + 1
					- ABS(DATEDIFF(ADDDATE(data1, INTERVAL 1 - DAYOFWEEK(data1) DAY),
									ADDDATE(data2, INTERVAL 1 - DAYOFWEEK(data2) DAY))) / 7 * 2
					- (DAYOFWEEK(IF(data2 < data1, data2, data1)) = 1)
					- (DAYOFWEEK(IF(data2 > data1, data2, data1)) = 7);
	
    IF
		data2 < CONCAT(YEAR(data2), '-12-21')
        AND
        data1 > CONCAT(YEAR(data2)+1, '-01-07')
    THEN
		SET differenza = differenza - (ABS(DATEDIFF(CONCAT(YEAR(data1), '-01-07'), CONCAT(YEAR(data2), '-12-21'))) + 1
									- ABS(DATEDIFF(ADDDATE(CONCAT(YEAR(data1), '-01-07'), INTERVAL 1 - DAYOFWEEK(CONCAT(YEAR(data1), '-01-07')) DAY),
													ADDDATE(CONCAT(YEAR(data2), '-12-21'), INTERVAL 1 - DAYOFWEEK(CONCAT(YEAR(data2), '-12-21')) DAY))) / 7 * 2
									- (DAYOFWEEK(IF(CONCAT(YEAR(data2), '-12-21') < CONCAT(YEAR(data1), '-01-07'), CONCAT(YEAR(data2), '-12-21'), CONCAT(YEAR(data1), '-01-07'))) = 1)
									- (DAYOFWEEK(IF(CONCAT(YEAR(data2), '-12-21') > CONCAT(YEAR(data1), '-01-07'), CONCAT(YEAR(data2), '-12-21'), CONCAT(YEAR(data1), '-01-07'))) = 7));
    END IF;
    
    RETURN differenza;
END $$
DELIMITER ;

# Stored Procedure che aggiorna il numero massimo di Lavoratori per Capocantiere che serve all'Event "Aggiorna_Lavoratori_Per_Capocantiere"
DROP PROCEDURE IF EXISTS Aggiornamento_Max_N;
DELIMITER $$
CREATE PROCEDURE Aggiornamento_Max_N()
BEGIN
	DECLARE finito INT DEFAULT 0;
	DECLARE capocantiere VARCHAR(50) DEFAULT '';
    DECLARE numero_lavoratori INT DEFAULT 0;
    DECLARE lavori_anticipo, lavori_ritardo, lavori_totali INT DEFAULT 0;
    
    DECLARE lista_capocantieri CURSOR FOR
		SELECT C.CodiceFiscale, C.NumeroMassimoLavoratori
        FROM Capocantiere C
        WHERE C.Pensione = FALSE;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
    
    OPEN lista_capocantieri;
    ciclo: LOOP
		FETCH lista_capocantieri INTO capocantiere, numero_lavoratori;
		IF 
			finito = 1
		THEN 
			LEAVE ciclo;
		END IF;
		
        SET lavori_totali = (SELECT IFNULL(COUNT(DISTINCT L.Codice_Lavoro), 0)
							 FROM Lavoro L INNER JOIN Turni_Di_Lavoro_Capocantiere T ON L.Codice_Lavoro = T.Lavoro
											INNER JOIN TipologiaLavoro TL ON L.TipologiaDiLavoro = TL.Nome
                             WHERE T.CodiceFiscale = capocantiere
							      AND
								   YEAR(L.DataFine) = YEAR(CURRENT_DATE()));
        
        SET lavori_ritardo = (SELECT IFNULL(COUNT(DISTINCT L.Codice_Lavoro), 0)
							  FROM Lavoro L INNER JOIN Turni_Di_Lavoro_Capocantiere T ON L.Codice_Lavoro = T.Lavoro
											INNER JOIN TipologiaLavoro TL ON L.TipologiaDiLavoro = TL.Nome
                              WHERE T.CodiceFiscale = capocantiere
								   AND
									YEAR(L.DataFine) = YEAR(CURRENT_DATE())
								   AND
                                    Differenza_Date_Senza_Weekend(L.DataFine, L.DataInizio) > TL.TempoStimato);
                                    
        SET lavori_anticipo = (SELECT IFNULL(COUNT(DISTINCT L.Codice_Lavoro), 0)
						 	   FROM Lavoro L INNER JOIN Turni_Di_Lavoro_Capocantiere T ON L.Codice_Lavoro = T.Lavoro
											 INNER JOIN TipologiaLavoro TL ON L.TipologiaDiLavoro = TL.Nome
                               WHERE T.CodiceFiscale = capocantiere
								    AND
									 YEAR(L.DataFine) = YEAR(CURRENT_DATE())
								    AND
                                     Differenza_Date_Senza_Weekend(L.DataFine, L.DataInizio) < TL.TempoStimato);
                                     
		IF
			lavori_anticipo >= 0.5 * lavori_totali
            AND
            lavori_ritardo < 0.5 * lavori_anticipo
            AND
            numero_lavoratori > 3
        THEN
			UPDATE Capocantiere
            SET NumeroMassimoLavoratori = NumeroMassimoLavoratori - 1, Stipendio = Stipendio + 50
            WHERE CodiceFiscale = capocantiere;
		ELSEIF 
			lavori_ritardo >= 0.5 * lavori_totali
            AND
            numero_lavoratori < 15
        THEN
			UPDATE Capocantiere
            SET NumeroMassimoLavoratori = NumeroMassimoLavoratori + 1
            WHERE CodiceFiscale = capocantiere;
        END IF;
    END LOOP;
    CLOSE lista_capocantieri;
END $$
DELIMITER ;

# Stored Procedure che aggiorna il costo di un Lavoro che ha come data il giorno attuale che serve all'Event "Aggiornamento_Costo_Lavori"
DROP PROCEDURE IF EXISTS Procedura_Aggiornamento_Costo_Lavori;
DELIMITER $$
CREATE PROCEDURE Procedura_Aggiornamento_Costo_Lavori()
BEGIN
	DECLARE finito INT DEFAULT 0;
    DECLARE lavoro INT DEFAULT 0;
    DECLARE giorni_lavoro INT DEFAULT 0; 
	DECLARE costo_manodopera INT DEFAULT 0;
    DECLARE costo_materiali INT DEFAULT 0;
    DECLARE costo_burocratico INT DEFAULT 100;
    
    DECLARE lista_lavori CURSOR FOR
		SELECT L.Codice_Lavoro, DATEDIFF(L.DataFine, L.DataInizio)
        FROM Lavoro L
        WHERE L.Costo IS NULL;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
    
    OPEN lista_lavori;
    ciclo: LOOP
		FETCH lista_lavori INTO lavoro, giorni_lavoro;
		IF 
			finito = 1
		THEN 
			LEAVE ciclo;
		END IF;
		
        SET costo_manodopera = 
								(
									SELECT IFNULL(SUM(D.Stipendio * giorni_lavoro / 30), 0)
									FROM (
											SELECT DISTINCT L.CodiceFiscale, L.Stipendio
                                            FROM Turni_Di_Lavoro_Lavoratore TL NATURAL JOIN Lavoratore L 
                                            WHERE TL.Lavoro = lavoro
                                            UNION
                                            SELECT DISTINCT C.CodiceFiscale, C.Stipendio
                                            FROM Turni_Di_Lavoro_Capocantiere TC NATURAL JOIN Capocantiere C
                                            WHERE TC.Lavoro = lavoro
                                            UNION
                                            SELECT DISTINCT R.CodiceFiscale, R.Stipendio
                                            FROM Turni_Di_Lavoro_Responsabile TR NATURAL JOIN Responsabile R
                                            WHERE TR.Lavoro = lavoro
										 ) AS D
                                );
			
		SET costo_materiali = 
								(
									SELECT IFNULL(SUM(D.Quantita * D.Costo / D.QuantitaComprata), 0)
                                    FROM (
											SELECT IAM.Quantita, AM.Costo, AM.QuantitaComprata
											FROM ImpiegoAltriMateriali IAM INNER JOIN AltriMateriali AM ON IAM.Lotto_Altri_Materiali = AM.Codice_Lotto
                                            WHERE IAM.Lavoro = lavoro
                                            UNION
                                            SELECT II.Quantita, I.Costo, I.QuantitaComprata
											FROM ImpiegoIntonaco II INNER JOIN Intonaco I ON II.Lotto_Intonaco = I.Codice_Lotto
                                            WHERE II.Lavoro = lavoro
                                            UNION
                                            SELECT IM.Quantita, M.Costo, M.QuantitaComprata
											FROM ImpiegoMattoni IM INNER JOIN Mattoni M ON IM.Lotto_Mattoni = M.Codice_Lotto
                                            WHERE IM.Lavoro = lavoro
                                            UNION
                                            SELECT IP.Quantita, P.Costo, P.QuantitaComprata
											FROM ImpiegoPiastrelle IP INNER JOIN Piastrelle P ON IP.Lotto_Piastrelle = P.Codice_Lotto
                                            WHERE IP.Lavoro = lavoro
                                            UNION
                                            SELECT IP.Quantita, P.Costo, P.QuantitaComprata
											FROM ImpiegoPietre IP INNER JOIN Pietre P ON IP.Lotto_Pietre = P.Codice_Lotto
                                            WHERE IP.Lavoro = lavoro
										 ) AS D
                                );
		
        UPDATE Lavoro
        SET Costo = costo_manodopera + costo_materiali + costo_burocratico
        WHERE Codice_Lavoro = lavoro AND DataFine IS NOT NULL;
    END LOOP;
    CLOSE lista_lavori;
END $$
DELIMITER ;


# VINCOLI D'INTEGRITÀ

# Controlla se lo stato dell'Edificio appena inserito è Costruito, In Costruzione o Riparazione
DROP TRIGGER IF EXISTS ControllaInserimentoStatoEdificio;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoStatoEdificio
BEFORE INSERT ON Edificio
FOR EACH ROW
BEGIN
    IF    
        NEW.Stato < 1 OR NEW.Stato > 4
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Gli stati di un Edificio devono essere compresi tra 1 e 4';
    END IF;
END $$
DELIMITER ;

# Controlla se lo stato dell'Edificio appena aggiornato è Costruito, In Costruzione o Riparazione
DROP TRIGGER IF EXISTS ControllaAggiornamentoStatoEdificio;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoStatoEdificio
BEFORE UPDATE ON Edificio
FOR EACH ROW
BEGIN
    IF    
        NEW.Stato < 1 OR NEW.Stato > 4
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Gli stati di un Edificio devono essere compresi tra 1 e 4';
    END IF;
END $$
DELIMITER ;

# Controlla che l'inserimento del Piano della Pianta non sia minore di -1
DROP TRIGGER IF EXISTS ControllaInserimentoPianta;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoPianta
BEFORE INSERT ON Pianta
FOR EACH ROW
BEGIN    
    IF
		NEw.NumeroPiano < -1
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Il numero del Piano deve essere maggiore o uguale a -1.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'aggiornamento del Piano della Pianta non sia minore di -1
DROP TRIGGER IF EXISTS ControllaAggiornamentoPianta;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoPianta
BEFORE UPDATE ON Pianta
FOR EACH ROW
BEGIN    
    IF
		NEw.NumeroPiano < -1
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! Il numero del Piano deve essere maggiore o uguale a 0.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'inserimento dei punti del Perimetro del Vano siano più di 2 e che l'Altezza non sia minore o uguale a 0
DROP TRIGGER IF EXISTS ControllaInserimentoVano;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoVano
BEFORE INSERT ON Vano
FOR EACH ROW
BEGIN    
    IF
		NEW.AltezzaMax <= 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Altezza non può essere minore o uguale a 0.';
    END IF;
    
    IF
		NEW.LunghezzaMax IS NOT NULL
        AND
        NEW.LunghezzaMax <= 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Lunghezza non può essere minore o uguale a 0.';
    END IF;
    
    IF
		NEW.LarghezzaMax IS NOT NULL
        AND
        NEW.LarghezzaMax <= 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Larghezza non può essere minore o uguale a 0.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'aggiornamento dei punti del Perimetro del Vano non sia diverso da prima e che l'Altezza non sia minore o uguale a 0
DROP TRIGGER IF EXISTS ControllaAggiornamentoVano;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoVano
BEFORE UPDATE ON Vano
FOR EACH ROW
BEGIN  
	IF
		NEW.AltezzaMax <= 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Altezza non può essere minore o uguale a 0.';
    END IF;
    
    IF
		NEW.LunghezzaMax IS NOT NULL
        AND
        NEW.LunghezzaMax <= 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Lunghezza non può essere minore o uguale a 0.';
    END IF;
    
    IF
		NEW.LarghezzaMax IS NOT NULL
        AND
        NEW.LarghezzaMax <= 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Larghezza non può essere minore o uguale a 0.';
	END IF; 
END $$
DELIMITER ;

# Assicura l'assenza di intersezioni tra Muri
DROP TRIGGER IF EXISTS EvitaIntersezioni;
DELIMITER $$
CREATE TRIGGER EvitaIntersezioni
BEFORE INSERT ON Muro
FOR EACH ROW
BEGIN
	DECLARE v1_x, v2_x, v1_y, v2_y FLOAT DEFAULT NULL;
    DECLARE cod_pianta_1, cod_pianta_2 INT DEFAULT NULL;
    DECLARE finito INT DEFAULT 0;
    
	DECLARE vertici CURSOR FOR
		SELECT M.X1, M.Y1, M.X2, M.Y2
        FROM Muro M
        WHERE Vano1 IN 
        (
			SELECT V.Codice_Vano
            FROM Vano V
            WHERE V.Pianta = (
								SELECT V1.Pianta
								FROM Vano V1
								WHERE V1.Codice_Vano = NEW.Vano1
							 )
        );
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
        
	SET cod_pianta_1 =
    (
		SELECT Pianta
        FROM Vano
        WHERE Codice_Vano = NEW.Vano1
    );
    
    SET cod_pianta_2 =
    (
		SELECT Pianta
        FROM Vano
        WHERE Codice_Vano = NEW.Vano2
    );
    
    IF
		cod_pianta_1 <> cod_pianta_2
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! I vani selezionati non fanno parte della stessa pianta!';
	END IF;
    
    # Impongo l'assenza di intersezioni fra muri
    OPEN vertici;
		ciclo: LOOP
        FETCH Vertici INTO v1_x, v1_y, v2_x, v2_y;
        
        IF 
			finito = 1 
        THEN 
			LEAVE ciclo; 
		END IF;
        
        IF
			Intersezione(NEW.X1, NEW.Y1, NEW.X2, NEW.Y2, v1_x, v1_y, v2_x, v2_y) = TRUE
		THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Impossibile inserire! Sono presenti intersezioni fra muri!';
		END IF;
	END LOOP;    
    CLOSE vertici;
    
    IF
		NEW.Vano1 = NEW.Vano2
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Vano1 e Vano2 non possono essere uguali!';
    END IF;
END $$
DELIMITER ;

# Stimo, ogni volta che viene inserito un nuovo Muro, la lunghezza/larghezza max dei vani che comprendono il muro inserito
DROP TRIGGER IF EXISTS Massima_Lunghezza_Larghezza;
DELIMITER $$
CREATE TRIGGER Massima_Lunghezza_Larghezza
AFTER INSERT ON Muro
FOR EACH ROW
BEGIN
	DECLARE min_x, min_x_2, max_x, max_x_2, min_y, min_y_2, max_y, max_y_2 FLOAT DEFAULT 0;
    DECLARE lunghezza_max, larghezza_max FLOAT DEFAULT 0;
    
    SET min_x =
    (
		SELECT MIN(X1) 
        FROM Muro
        WHERE Vano1 = NEW.Vano1
			 OR
              Vano2 = NEW.Vano1
    );
    
    SET min_x_2 =
    (
		SELECT MIN(X2) 
        FROM Muro
        WHERE Vano1 = NEW.Vano1
			 OR
              Vano2 = NEW.Vano1
    );
    
    SET max_x =
    (
		SELECT MAX(X1) 
        FROM Muro
        WHERE Vano1 = NEW.Vano1
			 OR
              Vano2 = NEW.Vano1
    );
    
    SET max_x_2 =
    (
		SELECT MAX(X2) 
        FROM Muro
        WHERE Vano1 = NEW.Vano1
			 OR
              Vano2 = NEW.Vano1
    );
    
    SET min_y =
    (
		SELECT MIN(Y1) 
        FROM Muro
        WHERE Vano1 = NEW.Vano1
			 OR
              Vano2 = NEW.Vano1
    );
    
    SET min_y_2 =
    (
		SELECT MIN(Y2) 
        FROM Muro
        WHERE Vano1 = NEW.Vano1
			 OR
              Vano2 = NEW.Vano1
    );
    
    SET max_y =
    (
		SELECT MAX(Y1) 
        FROM Muro
        WHERE Vano1 = NEW.Vano1
			 OR
              Vano2 = NEW.Vano1
    );
    
    SET max_y_2 =
    (
		SELECT MAX(Y2) 
        FROM Muro
        WHERE Vano1 = NEW.Vano1
			 OR
              Vano2 = NEW.Vano1
    ); 
    
    SET lunghezza_max = 
			(
				SELECT V.LunghezzaMax
                FROM Vano V
                WHERE V.Codice_Vano = NEW.Vano1
            );
        
	SET larghezza_max = 
			(
				SELECT V.LarghezzaMax
                FROM Vano V
                WHERE V.Codice_Vano = NEW.Vano1
            );
    
    IF
		ABS(Massimo(max_x, max_x_2) - Minimo(min_x, min_x_2)) > lunghezza_max
        OR
        lunghezza_max IS NULL
    THEN
		IF
			ABS(Massimo(max_x, max_x_2) - Minimo(min_x, min_x_2)) > 0
        THEN
			UPDATE Vano 
			SET LunghezzaMax = ABS(Massimo(max_x, max_x_2) - Minimo(min_x, min_x_2))
			WHERE Codice_vano = NEW.Vano1;
		ELSE
			UPDATE Vano 
			SET LunghezzaMax = 0.1
			WHERE Codice_vano = NEW.Vano1;
        END IF;
		
    END IF;
    
    IF
		ABS(Massimo(max_y, max_y_2) - Minimo(min_y, min_y_2)) > larghezza_max
        OR
        larghezza_max IS NULL
    THEN
		IF
			ABS(Massimo(max_y, max_y_2) - Minimo(min_y, min_y_2)) > 0
        THEN
			UPDATE Vano 
			SET LarghezzaMax = ABS(Massimo(max_y, max_y_2) - Minimo(min_y, min_y_2))
			WHERE Codice_vano = NEW.Vano1;
        ELSE
			UPDATE Vano 
			SET LarghezzaMax = 0.1
			WHERE Codice_vano = NEW.Vano1;
        END IF;
    END IF;
    
    SET min_x =
    (
		SELECT MIN(X1) 
        FROM Muro
        WHERE Vano2 = NEW.Vano2
			 OR
              Vano1 = NEW.Vano2
    );
    
    SET min_x_2 =
    (
		SELECT MIN(X2) 
        FROM Muro
        WHERE Vano2 = NEW.Vano2
			 OR
              Vano1 = NEW.Vano2
    );
    
    SET max_x =
    (
		SELECT MAX(X1) 
        FROM Muro
        WHERE Vano2 = NEW.Vano2
			 OR
              Vano1 = NEW.Vano2
    );
    
    SET max_x_2 =
    (
		SELECT MAX(X2) 
        FROM Muro
        WHERE Vano2 = NEW.Vano2
			 OR
              Vano1 = NEW.Vano2
    );
    
    SET min_y =
    (
		SELECT MIN(Y1) 
        FROM Muro
        WHERE Vano2 = NEW.Vano2
			 OR
              Vano1 = NEW.Vano2
    );
    
    SET min_y_2 =
    (
		SELECT MIN(Y2) 
        FROM Muro
        WHERE Vano2 = NEW.Vano2
			 OR
              Vano1 = NEW.Vano2
    );
    
    SET max_y =
    (
		SELECT MAX(Y1) 
        FROM Muro
        WHERE Vano2 = NEW.Vano2
			 OR
              Vano1 = NEW.Vano2
    );
    
    SET max_y_2 =
    (
		SELECT MAX(Y2) 
        FROM Muro
        WHERE Vano2 = NEW.Vano2
			 OR
              Vano1 = NEW.Vano2
    ); 
    
    SET lunghezza_max = 
			(
				SELECT V.LunghezzaMax
                FROM Vano V
                WHERE V.Codice_Vano = NEW.Vano2
            );
        
	SET larghezza_max = 
			(
				SELECT V.LarghezzaMax
                FROM Vano V
                WHERE V.Codice_Vano = NEW.Vano2
            );
    
    IF
		ABS(Massimo(max_x, max_x_2) - Minimo(min_x, min_x_2)) > lunghezza_max
        OR
        lunghezza_max IS NULL
    THEN
		IF
			ABS(Massimo(max_x, max_x_2) - Minimo(min_x, min_x_2)) > 0
        THEN
			UPDATE Vano 
			SET LunghezzaMax = ABS(Massimo(max_x, max_x_2) - Minimo(min_x, min_x_2))
			WHERE Codice_vano = NEW.Vano2;
        ELSE
			UPDATE Vano 
			SET LunghezzaMax = 0.1
			WHERE Codice_vano = NEW.Vano2;
        END IF;
		
    END IF;
    
    IF
		ABS(Massimo(max_y, max_y_2) - Minimo(min_y, min_y_2)) > larghezza_max
        OR
        larghezza_max IS NULL
    THEN
		IF
			ABS(Massimo(max_y, max_y_2) - Minimo(min_y, min_y_2)) > 0
        THEN
			UPDATE Vano 
			SET LarghezzaMax = ABS(Massimo(max_y, max_y_2) - Minimo(min_y, min_y_2))
			WHERE Codice_vano = NEW.Vano2;
        ELSE
			UPDATE Vano 
			SET LarghezzaMax = 0.1
			WHERE Codice_vano = NEW.Vano2;
        END IF;
    END IF;
END $$
DELIMITER ;

# Controllo che ad un aggiornamento dei Vani di un Muro, essi non siano uguali
DROP TRIGGER IF EXISTS ControlloAggiornamentomentoVanoInMuro;
DELIMITER $$
CREATE TRIGGER ControlloAggiornamentoVanoInMuro
BEFORE UPDATE ON Muro
FOR EACH ROW
BEGIN
    DECLARE cod_pianta_1, cod_pianta_2 INT DEFAULT NULL;

	IF
		NEW.Vano1 = NEW.Vano2
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Vano1 e Vano2 non possono essere uguali!';
    END IF;
        
	SET cod_pianta_1 =
    (
		SELECT Pianta
        FROM Vano
        WHERE Codice_Vano = NEW.Vano1
    );
    
    SET cod_pianta_2 =
    (
		SELECT Pianta
        FROM Vano
        WHERE Codice_Vano = NEW.Vano2
    );
    
    IF
		cod_pianta_1 <> cod_pianta_2
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! I vani selezionati non fanno parte della stessa pianta!';
	END IF;
END $$
DELIMITER ;

# Assicura che un'Apertura stia su un Muro
DROP TRIGGER IF EXISTS ControlloInserimentoApertura;
DELIMITER $$
CREATE TRIGGER ControlloInserimentoApertura
BEFORE INSERT ON Apertura
FOR EACH ROW
BEGIN    
	DECLARE v1_x, v2_x, v1_y, v2_y FLOAT DEFAULT NULL;
    DECLARE ext BOOL DEFAULT FALSE;
    
    IF 
        (SELECT Vano2
		 FROM Muro
		 WHERE Codice_muro = NEW.Muro) = NULL 
    THEN 
		SET ext = TRUE;
    ELSE
		SET ext = FALSE;
    END IF;
    
    SET v1_x = 
    (
		SELECT X1
        FROM Muro
        WHERE Codice_muro = NEW.Muro
    );

	SET v1_y = 
    (
		SELECT y1
        FROM Muro
        WHERE Codice_muro = NEW.Muro
    );

	SET v2_x = 
    (
		SELECT X2
        FROM Muro
        WHERE Codice_muro = NEW.Muro
    );

	SET v2_y = 
    (
		SELECT y2
        FROM Muro
        WHERE Codice_muro = NEW.Muro
    );

	IF 
		compreso_senza_estremi(NEW.X1, v1_x, v2_x) = FALSE OR
		compreso_senza_estremi(NEW.X2, v1_x, v2_x) = FALSE OR
		compreso_senza_estremi(NEW.Y1, v1_y, v2_y) = FALSE OR
		compreso_senza_estremi(NEW.Y2, v1_y, v2_y) = FALSE 
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire perché non appartengono al muro selezionato!';
	END IF;
		
	IF
		NEW.Tipologia <> 'Porta'
        AND
        NEW.Tipologia <> 'Finestra'
        AND 
        NEW.Tipologia <> 'Porta-Finestra'
        AND
        NEW.Tipologia <> 'Arco'
        AND 
        NEW.Tipologia <> 'Spazio Vuoto'
        AND
        NEW.Tipologia <> 'Porta Esterna'
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Le aperture possono essere solo Porta, Porta Esterna, Finestra, Porta-Finestra, Arco o Spazio Vuoto.';
    END IF;
    
    IF 
		ext <> TRUE
        AND
        NEW.Tipologia <> 'Finestra'
        AND 
        NEW.Tipologia <> 'Porta-Finestra'
        AND
        NEW.Tipologia <> 'Porta Esterna'
	THEN 
		THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! La tipologia selezionata deve essere Esterna';
    END IF;
END;

# Controllo Aggiornamento Tipo di Apertura
DROP TRIGGER IF EXISTS ControlloAggiornamentoApertura;
DELIMITER $$
CREATE TRIGGER ControlloAggiornamentoApertura
BEFORE UPDATE ON Apertura
FOR EACH ROW
BEGIN    
	IF
		NEW.Tipologia <> 'Porta'
        AND
        NEW.Tipologia <> 'Finestra'
        AND 
        NEW.Tipologia <> 'Porta-Finestra'
        AND
        NEW.Tipologia <> 'Arco'
        AND 
        NEW.Tipologia <> 'Spazio Vuoto'
        AND
        NEW.Tipologia <> 'Porta Esterna'
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Le aperture possono essere solo Porta, Porta Esterna, Finestra, Porta-Finestra, Arco o Spazio Vuoto.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'inserimento delle date del Progetto Edilizio siano corrette e non presentino ovvi errori come la data di fine minore della data inizio 
DROP TRIGGER IF EXISTS ControllaInserimentoDateProgettoEdilizio;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoDateProgettoEdilizio
BEFORE INSERT ON ProgettoEdilizio
FOR EACH ROW
BEGIN
    IF    
        (NEW.DataApprovazione >= NEW.DataInizio
         OR 
         NEW.StimaFine <= NEW.DataInizio
		 OR
         NEW.StimaFine <= NEW.DataApprovazione
         OR
		 NEW.DataFine <= NEW.DataInizio
         OR 
         NEW.DataFine <= NEW.DataApprovazione)
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Gli inserimenti sulle date hanno valori inconsistenti.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'aggiornamento delle date del Progetto Edilizio siano corrette e non presentino ovvi errori e impone che per conclude un progetto ci siano almeno 2 Responsabili
DROP TRIGGER IF EXISTS ControllaAggiornamentoDateProgettoEdilizio;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoDateProgettoEdilizio
BEFORE UPDATE ON ProgettoEdilizio
FOR EACH ROW
BEGIN
    IF    
        (NEW.DataInizio <= DataApprovazione
         OR 
         NEW.DataFine <= DataInizio)
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Gli aggiornamenti sulle date hanno valori inconsistenti.';
	ELSEIF
		NEW.DataFine IS NOT NULL 
        AND
		(SELECT IFNULL(COUNT(*), 0)
		 FROM Responsabilita R
         WHERE R.Progetto = NEW.ID_Progetto) < 2
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! In Responsabilità ci devono essere almeno 2 Responsabili.';
    END IF;
END $$
DELIMITER ;

# Se si inserisce un Progetto Edilizio in Riparazione mettendo la data di fine non nulla, l'Edificio ha lo stato settato ad 1
DROP TRIGGER IF EXISTS ControlloStatoEdificioInserimento;
DELIMITER $$
CREATE TRIGGER ControlloStatoEdificioInserimento
AFTER INSERT ON ProgettoEdilizio
FOR EACH ROW
BEGIN
    IF    
        NEW.DataFine IS NOT NULL
        AND
        NEW.Tipo = 'Riparazione'
	THEN
        UPDATE Edificio
        SET Stato = 1
        WHERE ID = NEW.Edificio;
    END IF;
END $$
DELIMITER ;

# Se si aggiorna un Progetto Edilizio in Riparazione mettendo la data di fine non nulla, l'Edificio ha lo stato settato ad 1
DROP TRIGGER IF EXISTS ControlloStatoEdificioAggiornamento;
DELIMITER $$
CREATE TRIGGER ControlloStatoEdificioAggiornamento
AFTER UPDATE ON ProgettoEdilizio
FOR EACH ROW
BEGIN
    IF    
        NEW.DataFine IS NOT NULL
        AND 
        OLD.DataFine IS NULL
        AND
        NEW.Tipo = 'Riparazione'
	THEN
        UPDATE Edificio
        SET Stato = 1
        WHERE ID = NEW.Edificio;
    END IF;
END $$
DELIMITER ;

# Controlla se il Tipo di Progetto Edilizio appena inserito è Costruzione o Riparazione
DROP TRIGGER IF EXISTS ControllaInserimentoProgettoEdilizio;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoProgettoEdilizio
BEFORE INSERT ON ProgettoEdilizio
FOR EACH ROW
BEGIN
	DECLARE costruzione BOOL DEFAULT FALSE; # Sarà vero se l'Edificio di cui si inserisce il Progetto Edilizio è stato costruito o è in costruzione
	DECLARE costruito BOOL DEFAULT FALSE; # Sarà vero se l'Edificio di cui si inserisce il Progetto Edilizio è stato costruito
    DECLARE data_fine DATE DEFAULT NULL;
    
    SET data_fine = (SELECT PE.DataFine
					 FROM ProgettoEdilizio PE
					 WHERE PE.Edificio = NEW.Edificio
						  AND
						   PE.Tipo = 'Costruzione');
    
    IF 
		(SELECT IFNULL(COUNT(*), 0)
         FROM ProgettoEdilizio PE
         WHERE PE.Edificio = NEW.Edificio
			  AND
               PE.Tipo = 'Costruzione') = 1
    THEN
		SET costruzione = TRUE;
    END IF;
    
	IF 
		(SELECT IFNULL(COUNT(*), 0)
         FROM ProgettoEdilizio PE
         WHERE PE.Edificio = NEW.Edificio
			  AND
               PE.Tipo = 'Costruzione'
			  AND 
               PE.DataFine IS NOT NULL) = 1
    THEN
		SET costruito = TRUE;
    END IF;
    
    IF    
        (NEW.Tipo <> 'Costruzione'
         AND
         NEW.Tipo <> 'Riparazione')
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Gli stati di un Progetto devono essere Costruzione o Riparazione.';
    END IF;
    
    IF
		costruzione = TRUE
        AND
        NEW.Tipo = 'Costruzione'
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Edificio già costruito, o in costruzione, o non ancora costruito!';
    END IF;
    
	IF
		(costruzione = FALSE OR costruito = FALSE)
        AND
        NEW.Tipo = 'Riparazione'
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Edificio non inserito o in costruzione.';
    END IF;    
    
    IF
		(data_fine IS NULL
         OR
         NEW.DataInizio < data_fine)
        AND
        NEW.Tipo = 'Riparazione'
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Edificio non inserito o in costruzione.';
    END IF;
END $$
DELIMITER ;

# Controlla se il Tipo di Progetto Edilizio appena inserito è Costruzione o Riparazione
DROP TRIGGER IF EXISTS ControllaAggiornamentoProgettoEdilizio;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoProgettoEdilizio
BEFORE UPDATE ON ProgettoEdilizio
FOR EACH ROW
BEGIN
    IF    
        OLD.Tipo <> NEW.Tipo   
        OR
        OLD.Edificio <> NEW.Edificio
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Il cambio di Tipo e/o di Edificio non è concesso!';
    END IF;
END $$
DELIMITER ;

# Controlla che l'inserimento dello Stadio di Avanzamento non sia possibile se il Progetto si è concluso
DROP TRIGGER IF EXISTS ControllaInserimentoStadioAvanzamento;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoStadioAvanzamento
BEFORE INSERT ON StadioDiAvanzamento
FOR EACH ROW
BEGIN
	DECLARE data_progetto DATE DEFAULT NULL;
    DECLARE data_stadio DATE DEFAULT NULL;
    
    SET data_progetto = (SELECT PE.DataInizio
						 FROM ProgettoEdilizio PE
                         WHERE PE.ID_Progetto = NEW.Progetto);
    
    SET data_stadio = (SELECT S.DataFine
					   FROM StadioDiAvanzamento S
                       WHERE S.Progetto = NEW.Progetto
						    AND
                             S.Numero = (SELECT MAX(S1.Numero)
							             FROM StadioDiAvanzamento S1
                                         WHERE S1.Progetto = NEW.Progetto));
    
    IF    
		NEW.DataInizio <> data_progetto
        AND
        NEW.Numero = 1
	THEN
		SET NEW.DataInizio = data_progetto;
    END IF;
    
    IF    
        (NEW.StimaFine <= NEW.DataInizio
         OR
		 NEW.DataFine <= NEW.DataInizio)
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Gli inserimenti sulle date hanno valori inconsistenti.';
    END IF;
    
    IF
		(SELECT S.DataFine
		 FROM StadioDiAvanzamento S
         WHERE S.Numero = NEW.Numero-1
			  AND
               S.Progetto = NEW.Progetto)
		> 
        NEW.DataInizio
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Inizio dello Stadio deve essere maggiore rispetto a quello precedente.';
	END IF;
                         
    IF    
		data_progetto = data_stadio
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Progetto è finito.';
    END IF;
    
    IF
		NEW.Numero <= 0
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Numero deve essere maggiore o uguale ad 1.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'aggiornamento delle date dello Stadio di Avanzamento siano corrette e non presentino ovvi errori come la data di fine minore della data inizio 
DROP TRIGGER IF EXISTS ControllaAggiornamentoStadioAvanzamento;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoStadioAvanzamento
BEFORE UPDATE ON StadioDiAvanzamento
FOR EACH ROW
BEGIN
    IF    
        (NEW.StimaFine <= NEW.DataInizio
         OR
		 NEW.DataFine <= NEW.DataInizio)
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Gli inserimenti sulle date hanno valori inconsistenti.';
    END IF;
    
    IF
		(SELECT S.DataFine
		 FROM StadioDiAvanzamento S
         WHERE S.Numero = NEW.Numero-1
			  AND
               S.Progetto = NEW.Progetto)
		> 
        NEW.DataInizio
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Inizio dello Stadio deve essere maggiore rispetto a quello precedente.';
	END IF;
END $$
DELIMITER ;

# Controlla che gli inserimenti del Minimo Numero di Lavoratori e del Massimo Numero di Lavoratori in Tipologia di Lavoro siano adeguati
DROP TRIGGER IF EXISTS ControllaInserimentoNumeroLavoratori;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoNumeroLavoratori
BEFORE INSERT ON TipologiaLavoro
FOR EACH ROW
BEGIN
    IF    
		 NEW.NumeroMinimoLavoratori < 2
         OR
         NEW.NumeroMassimoLavoratori > 30
         OR 
         NEW.NumeroMinimoLavoratori > NEW.NumeroMassimoLavoratori
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il minimo numero di lavoratori < 2 o massimo numero di lavoratori > 30.';
    END IF;
END $$
DELIMITER ;

# Controlla che gli aggiornamenti del Minimo Numero di Lavoratori e del Massimo Numero di Lavoratori in Tipologia di Lavoro siano adeguati
DROP TRIGGER IF EXISTS ControllaAggiornamentoNumeroLavoratori;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoNumeroLavoratori
BEFORE UPDATE ON TipologiaLavoro
FOR EACH ROW
BEGIN
    IF    
		 NEW.NumeroMinimoLavoratori < 2
         OR
         NEW.NumeroMassimoLavoratori > 30
         OR 
         NEW.NumeroMinimoLavoratori > NEW.NumeroMassimoLavoratori
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare!  Il minimo numero di lavoratori < 2 o massimo numero di lavoratori > 30.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'inserimento del Tempo Stimato della Tipologia di Lavoro sia maggiore di 0
DROP TRIGGER IF EXISTS ControllaInserimentoTempoStimato;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoTempoStimato
BEFORE INSERT ON TipologiaLavoro
FOR EACH ROW
BEGIN
    IF    
		 NEW.TempoStimato <= 0
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Tempo Stimato non può essere minore di 0.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'aggiornamento del Tempo Stimato della Tipologia di Lavoro sia maggiore di 0
DROP TRIGGER IF EXISTS ControllaAggiornamentoTempoStimato;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoTempoStimato
BEFORE UPDATE ON TipologiaLavoro
FOR EACH ROW
BEGIN
    IF    
		 NEW.TempoStimato <= 0
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Il Tempo Stimato non può essere minore di 0.';
	END IF;
END $$
DELIMITER ;

# Controlla che l'inserimento delle date del Lavoro non abbiano la data di fine minore della data inizio 
DROP TRIGGER IF EXISTS ControllaInserimentoDateLavoro;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoDateLavoro
BEFORE INSERT ON Lavoro
FOR EACH ROW
BEGIN
    IF    
		NEW.DataFine < NEW.DataInizio
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! La Data della Fine del Lavoro non può essere minore della Data di Inizio.';
    END IF;
    
    IF
		NEW.DataInizio < (SELECT S.DataInizio
						  FROM StadioDiAvanzamento S
                          WHERE S.Numero = NEW.StadioDiAvanzamento
							   AND
                                S.Progetto = NEW.Progetto)
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Inzio del Lavoro non può essere minore di Inizio dello Stadio.';
	ELSEIF 
		NEW.DataFine > (SELECT S.DataFine
						  FROM StadioDiAvanzamento S
                          WHERE S.Numero = NEW.StadioDiAvanzamento
							   AND
                                S.Progetto = NEW.Progetto)
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Fine del Lavoro non può essere maggiore di Fine dello Stadio.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'aggiornamento delle date del Lavoro non abbiano la data di fine minore della data inizio, che il lavoro rispetti il numero minimo di lavoratori e che abbia almeno un Capocantiere
DROP TRIGGER IF EXISTS ControllaAggiornamentoDateLavoro;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoDateLavoro
BEFORE UPDATE ON Lavoro
FOR EACH ROW
BEGIN
    IF    
		 NEW.DataFine < NEW.DataInizio
	THEN
        SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! La Data della Fine del Lavoro non può essere minore della Data di Inizio.';
    END IF;
    
    IF
		NEW.DataFine IS NOT NULL
    THEN
		IF 
			NEW.TipologiaDiLavoro <> 'Ispezione Fondamenta'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Intelaiatura'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Chiusura'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Fissaggio'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Adattamento'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Caldaia'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Crepa'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Umidità di Risalita'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Umidità Esterna'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Danni da Alluvione'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Danni da Calore'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Finale'
			AND
			(SELECT IFNULL(COUNT(DISTINCT T.CodiceFiscale), 0)
			 FROM Turni_Di_Lavoro_Lavoratore T
			 WHERE T.Lavoro = NEW.Codice_Lavoro) 
			<
			(SELECT T.NumeroMinimoLavoratori
			 FROM TipologiaLavoro T
			 WHERE T.Nome = NEW.TipologiaDiLavoro)
		THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Impossibile aggiornare! Non è presente il numero minimo di lavoratori previsto in Turni di Lavoro.';	
		END IF;
		
		IF 
			NEW.TipologiaDiLavoro <> 'Ispezione Fondamenta'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Intelaiatura'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Chiusura'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Fissaggio'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Adattamento'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Caldaia'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Crepa'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Umidità di Risalita'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Umidità Esterna'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Danni da Alluvione'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Danni da Calore'
			AND
			NEW.TipologiaDiLavoro <> 'Ispezione Finale'
			AND
			(SELECT IFNULL(COUNT(DISTINCT T.CodiceFiscale), 0)
			 FROM Turni_Di_Lavoro_Capocantiere T
			 WHERE T.Lavoro = NEW.Codice_Lavoro) = 0
		THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Impossibile aggiornare! Non è stato inserito almeno un Capocantiere.';
		END IF;
		
		IF 
			(NEW.TipologiaDiLavoro = 'Ispezione Fondamenta'
			OR
			NEW.TipologiaDiLavoro = 'Ispezione Intelaiatura'
			OR
			NEW.TipologiaDiLavoro = 'Ispezione Chiusura'
			OR
			NEW.TipologiaDiLavoro = 'Ispezione Fissaggio'
			OR
			NEW.TipologiaDiLavoro = 'Ispezione Adattamento'
			OR
			NEW.TipologiaDiLavoro = 'Ispezione Caldaia'
			OR
			NEW.TipologiaDiLavoro = 'Ispezione Crepa'
			OR
			NEW.TipologiaDiLavoro = 'Ispezione Umidità di Risalita'
			OR
			NEW.TipologiaDiLavoro = 'Ispezione Umidità Esterna'
			OR
			NEW.TipologiaDiLavoro = 'Ispezione Danni da Alluvione'
			OR
			NEW.TipologiaDiLavoro = 'Ispezione Danni da Calore'
			OR
			NEW.TipologiaDiLavoro = 'Ispezione Finale')
			AND
			(SELECT IFNULL(COUNT(DISTINCT T.CodiceFiscale), 0)
			 FROM Turni_Di_Lavoro_Responsabile T
			 WHERE T.Lavoro = NEW.Codice_Lavoro) < 2
		THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Impossibile aggiornare! Non sono stati inseriti almeno due Responsabili in un lavoro di Ispezione.';		
		END IF;
	END IF;
    
    IF
		NEW.DataInizio < (SELECT S.DataInizio
						  FROM StadioDiAvanzamento S
						  WHERE S.Numero = NEW.StadioDiAvanzamento
							   AND
								S.Progetto = NEW.Progetto)
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! La Data di Inzio del Lavoro non può essere minore della Data di Inizio dello Stadio di Avanzamento.';
	ELSEIF 
		NEW.DataFine > (SELECT S.DataFine
	 				    FROM StadioDiAvanzamento S
						WHERE S.Numero = NEW.StadioDiAvanzamento
						     AND
							  S.Progetto = NEW.Progetto)
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! La Data di Fine del Lavoro non può essere maggiore della Data di Fine dello Stadio di Avanzamento.';
	END IF;
END $$
DELIMITER ;

# Controlla che il Costo di un Lavoro sia maggiore di 0
DROP TRIGGER IF EXISTS ControllaInserimentoCostoLavoro;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoCostoLavoro
BEFORE INSERT ON Lavoro
FOR EACH ROW
BEGIN
    IF    
		 NEW.Costo < 0
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Conto non può essere minore di 0.';
    END IF;
END $$
DELIMITER ;

# Controlla che il costo non sia negativo
DROP TRIGGER IF EXISTS AggiornamentoCostoLavoro;
DELIMITER $$
CREATE TRIGGER AggiornamentoCostoLavoro
BEFORE UPDATE ON Lavoro
FOR EACH ROW
BEGIN    
    IF
		NEW.Costo < 0
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Il costo è minore di 0.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'Inserimento di un Lavoro di tipo Riparazione Crepa tolga il Sensore di Posizione (se presente) una volta finito il lavoro
DROP TRIGGER IF EXISTS ControllaInserimentoRiparazioneCrepa;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoRiparazioneCrepa
AFTER INSERT ON Lavoro
FOR EACH ROW
BEGIN   
    IF
		(SELECT PE.Tipo
         FROM ProgettoEdilizio PE
         WHERE PE.ID_Progetto = NEW.Progetto) = 'Riparazione'
         AND
         NEW.TipologiaDiLavoro = 'Riparazione Crepa'
         AND
         NEW.DataFine IS NOT NULL
	THEN 
		UPDATE Crepa
        SET Riparato = TRUE
		WHERE Muro IN (SELECT M.Codice_Muro
					   FROM Muro M INNER JOIN Vano V ON M.Vano1 = V.Codice_Vano 
								   INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
					   WHERE P.Edificio = (SELECT PE.Edificio
										   FROM ProgettoEdilizio PE
										   WHERE PE.ID_Progetto = NEW.Progetto))
			 AND
			  Riparato = FALSE;
    END IF;
END $$
DELIMITER ;

# Controlla che l'Aggiornamento di un Lavoro di tipo Riparazione Crepa tolga il Sensore di Posizione (se presente) una volta finito il lavoro
DROP TRIGGER IF EXISTS ControllaAggiornamentoRiparazioneCrepa;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoRiparazioneCrepa
AFTER UPDATE ON Lavoro
FOR EACH ROW
BEGIN
	IF
		(SELECT PE.Tipo
         FROM ProgettoEdilizio PE
         WHERE PE.ID_Progetto = NEW.Progetto) = 'Riparazione'
         AND
         NEW.TipologiaDiLavoro = 'Riparazione Crepa'
         AND
         NEW.DataFine IS NOT NULL
	THEN 
		UPDATE Crepa
        SET Riparato = TRUE
		WHERE Muro IN (SELECT M.Codice_Muro
					   FROM Muro M INNER JOIN Vano V ON M.Vano1 = V.Codice_Vano 
								   INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
					   WHERE P.Edificio = (SELECT PE.Edificio
										   FROM ProgettoEdilizio PE
										   WHERE PE.ID_Progetto = NEW.Progetto))
			 AND
              Riparato = FALSE;
    END IF;
END $$
DELIMITER ;

# Controlla che l'inserimento dell sesso dei Lavoratori sia M per Maschio, F per Femmina o A per Altro, che lo Stipendio non sia minore di 0 e che gli assunti siano almeno maggiorenni 
DROP TRIGGER IF EXISTS ControlloInserimentoLavoratore;
DELIMITER $$
CREATE TRIGGER ControlloInserimentoLavoratore
BEFORE INSERT ON Lavoratore
FOR EACH ROW
BEGIN
	IF 
		NEW.Sesso <> 'M'
        AND
        NEW.Sesso <> 'F'
        AND
        NEW.Sesso <> 'A'
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! I sessi possono essere solo M per Maschio, F per Femmina e A per Altro.';
	END IF;
    
    IF
		NEW.Stipendio < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Uno Stipendio non può essere negativo.';
    END IF;
    
    IF
		NEW.DataNascita > NEW.DataAssunzione
        OR
        NEW.DataAssunzione < DATE_ADD(NEW.DataNascita, INTERVAL 18 YEAR)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Uno Stipendio non può essere negativo.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'aggiornamento dell sesso dei Lavoratori sia M per Maschio, F per Femmina o A per Altro, che lo Stipendio non sia minore di 0 e che gli assunti siano almeno maggiorenni 
DROP TRIGGER IF EXISTS ControlloAggiornamentoLavoratore;
DELIMITER $$
CREATE TRIGGER ControlloAggiornamentoLavoratore
BEFORE UPDATE ON Lavoratore
FOR EACH ROW
BEGIN
	IF 
		NEW.Sesso <> 'M'
        AND
        NEW.Sesso <> 'F'
        AND
        NEW.Sesso <> 'A'
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! I sessi possono essere solo M per Maschio, F per Femmina e A per Altro.';
	END IF;
    
    IF
		NEW.Stipendio < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Uno Stipendio non può essere negativo.';
    END IF;
    
    IF
		NEW.DataNascita > NEW.DataAssunzione
        OR
        NEW.DataAssunzione < DATE_ADD(NEW.DataNascita, INTERVAL 18 YEAR)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Uno Stipendio non può essere negativo.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'inserimento dell sesso dei Lavoratori sia M per Maschio, F per Femmina o A per Altro, che lo Stipendio non sia minore di 0, che gli assunti siano almeno maggiorenni e che il numero massimo di lavoratori sia tra 3 e 15
DROP TRIGGER IF EXISTS ControlloInserimentoCapocantiere;
DELIMITER $$
CREATE TRIGGER ControlloInserimentoCapocantiere
BEFORE INSERT ON Capocantiere
FOR EACH ROW
BEGIN
	IF 
		NEW.Sesso <> 'M'
        AND
        NEW.Sesso <> 'F'
        AND
        NEW.Sesso <> 'A'
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! I sessi possono essere solo M per Maschio, F per Femmina e A per Altro.';
	END IF;
    
    IF
		NEW.Stipendio < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Uno Stipendio non può essere negativo.';
    END IF;
    
    IF
		NEW.DataNascita > NEW.DataAssunzione
        OR
        NEW.DataAssunzione < DATE_ADD(NEW.DataNascita, INTERVAL 18 YEAR)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Uno Stipendio non può essere negativo.';
    END IF;
    
    IF
		NEW.NumeroMassimoLavoratori < 3
        OR
        NEW.NumeroMassimoLavoratori > 15
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Massimo Numero di Lavoratori deve essere tra 3 e 15.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'aggiornamento dell sesso dei Lavoratori sia M per Maschio, F per Femmina o A per Altro, che lo Stipendio non sia minore di 0, che gli assunti siano almeno maggiorenni e che il numero massimo di lavoratori sia tra 3 e 15
DROP TRIGGER IF EXISTS ControlloAggiornamentoCapocantiere;
DELIMITER $$
CREATE TRIGGER ControlloAggiornamentoCapocantiere
BEFORE UPDATE ON Capocantiere
FOR EACH ROW
BEGIN
	IF 
		NEW.Sesso <> 'M'
        AND
        NEW.Sesso <> 'F'
        AND
        NEW.Sesso <> 'A'
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! I sessi possono essere solo M per Maschio, F per Femmina e A per Altro.';
	END IF;
    
    IF
		NEW.Stipendio < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Uno Stipendio non può essere negativo.';
    END IF;
    
    IF
		NEW.DataNascita > NEW.DataAssunzione
        OR
        NEW.DataAssunzione < DATE_ADD(NEW.DataNascita, INTERVAL 18 YEAR)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Uno Stipendio non può essere negativo.';
    END IF;
    
	IF
		NEW.NumeroMassimoLavoratori < 3
        OR
        NEW.NumeroMassimoLavoratori > 15
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Il Massimo Numero di Lavoratori deve essere tra 3 e 15.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'inserimento dell sesso dei Responsabili sia M per Maschio, F per Femmina o A per Altro, che lo Stipendio non sia minore di 0 e che gli assunti siano almeno maggiorenni 
DROP TRIGGER IF EXISTS ControlloInserimentoResponsabile;
DELIMITER $$
CREATE TRIGGER ControlloInserimentoResponsabile
BEFORE INSERT ON Responsabile
FOR EACH ROW
BEGIN
	IF 
		NEW.Sesso <> 'M'
        AND
        NEW.Sesso <> 'F'
        AND
        NEW.Sesso <> 'A'
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! I sessi possono essere solo M per Maschio, F per Femmina e A per Altro.';
	END IF;
    
    IF
		NEW.Stipendio < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Uno Stipendio non può essere negativo.';
    END IF;
    
    IF
		NEW.DataNascita > NEW.DataAssunzione
        OR
        NEW.DataAssunzione < DATE_ADD(NEW.DataNascita, INTERVAL 18 YEAR)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Uno Stipendio non può essere negativo.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'aggiornamento dell sesso dei Responsabili sia M per Maschio, F per Femmina o A per Altro, che lo Stipendio non sia minore di 0 e che gli assunti siano almeno maggiorenni 
DROP TRIGGER IF EXISTS ControlloAggiornamentoResponsabile;
DELIMITER $$
CREATE TRIGGER ControlloAggiornamentoResponsabile
BEFORE UPDATE ON Responsabile
FOR EACH ROW
BEGIN
	IF 
		NEW.Sesso <> 'M'
        AND
        NEW.Sesso <> 'F'
        AND
        NEW.Sesso <> 'A'
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! I sessi possono essere solo M per Maschio, F per Femmina e A per Altro.';
	END IF;
    
    IF
		NEW.Stipendio < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Uno Stipendio non può essere negativo.';
    END IF;
    
    IF
		NEW.DataNascita > NEW.DataAssunzione
        OR
        NEW.DataAssunzione < DATE_ADD(NEW.DataNascita, INTERVAL 18 YEAR)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Uno Stipendio non può essere negativo.';
    END IF;
END $$
DELIMITER ;

# Controlla che non venga superato il massimo numero di lavoratori stabilita per la sicurezza all'interno di Tipologia di Lavoro
DROP TRIGGER IF EXISTS ControllaMassimoNumeroLavoratori;
DELIMITER $$
CREATE TRIGGER ControllaMassimoNumeroLavoratori
BEFORE INSERT ON Turni_Di_Lavoro_Lavoratore
FOR EACH ROW
BEGIN    
    IF    
		 ((
          SELECT IFNULL(COUNT(DISTINCT T.CodiceFiscale), 0)
          FROM Turni_Di_Lavoro_Lavoratore T
          WHERE T.Lavoro = NEW.Lavoro
			   AND
                T.OrarioInizio = NEW.OrarioInizio
		 )
         >
         (
          SELECT TL.NumeroMassimoLavoratori
          FROM TipologiaLavoro TL INNER JOIN Lavoro L ON TL.Nome = L.TipologiaDiLavoro
          WHERE L.Codice_Lavoro = NEW.Lavoro
         ))
         OR
         ((
          SELECT IFNULL(COUNT(DISTINCT T.CodiceFiscale), 0)
          FROM Turni_Di_Lavoro_Lavoratore T
          WHERE T.Lavoro = NEW.Lavoro
			   AND
                T.OrarioInizio = NEW.OrarioInizio
		 )
         >
         (
		  SELECT SUM(C.NumeroMassimoLavoratori)
          FROM Turni_Di_Lavoro_Capocantiere T INNER JOIN Capocantiere C ON T.CodiceFiscale = C.CodiceFiscale
          WHERE T.Lavoro = NEW.Lavoro
		 ))
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Per ragioni di sicurezza non si possono tenere così tanti lavoratori.';
    END IF;
END $$
DELIMITER ;

# Controlla che non venga inserito in Turni Di Lavoro per Lavoratore un Lavoratore Pensionato
DROP TRIGGER IF EXISTS ControlloPensionamentoLavoratori;
DELIMITER $$
CREATE TRIGGER ControlloPensionamentoLavoratori
BEFORE INSERT ON Turni_Di_Lavoro_Lavoratore
FOR EACH ROW
BEGIN
    IF    
		 (SELECT L.Pensione
          FROM Lavoratore L
          WHERE L.CodiceFiscale = NEW.CodiceFiscale) = TRUE
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Lavoratore è Pensionato.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'Orario di Fine non sia minore o uguale a quello dell'inizio in Turni Di Lavoro per Lavoratore nell'inserimento
DROP TRIGGER IF EXISTS ControlloInserimentoOrariLavoratori;
DELIMITER $$
CREATE TRIGGER ControlloInserimentoOrariLavoratori
BEFORE INSERT ON Turni_Di_Lavoro_Lavoratore
FOR EACH ROW
BEGIN
    IF    
		NEW.OrarioFine <= NEW.OrarioInizio
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Orario di Fine deve essere maggiore di quello di Inizio.';
    END IF;
    
    IF
		TIMEDIFF(TIMEDIFF(NEW.OrarioFine, NEW.OrarioInizio), CONCAT(NEW.OrePausa, ':00:00')) > CAST('10:00:00' AS TIME)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Un lavoratore non può lavorare per più di 10 ore.';
    END IF;
    
    IF
		TIMEDIFF(TIMEDIFF(NEW.OrarioFine, NEW.OrarioInizio), CONCAT(NEW.OrePausa, ':00:00')) < CAST('4:00:00' AS TIME)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Un lavoratore non può lavorare meno di 4 ore.';
    END IF;
    
    IF
		NEW.GiornoLibero < 2
        OR
        NEW.GiornoLibero > 7
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Da 2 a 7. La Domenica è già contata e varrebbe 1. ';
    END IF;
END $$
DELIMITER ;

# Controlla che l'Orario di Fine non sia minore o uguale a quello dell'inizio in Turni Di Lavoro per Lavoratore nell'aggiornamento
DROP TRIGGER IF EXISTS ControlloAggiornamentoOrariLavoratori;
DELIMITER $$
CREATE TRIGGER ControlloAggiornamentoOrariLavoratori
BEFORE UPDATE ON Turni_Di_Lavoro_Lavoratore
FOR EACH ROW
BEGIN
    IF    
		NEW.OrarioFine <= NEW.OrarioInizio
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Orario di Fine deve essere maggiore di quello di Inizio.';
    END IF;
    
    IF
		TIMEDIFF(TIMEDIFF(NEW.OrarioFine, NEW.OrarioInizio), CONCAT(NEW.OrePausa, ':00:00')) > CAST('10:00:00' AS TIME)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Un lavoratore non può lavorare per più di 10 ore di fila.';
    END IF;
    
    IF
		TIMEDIFF(TIMEDIFF(NEW.OrarioFine, NEW.OrarioInizio), CONCAT(NEW.OrePausa, ':00:00')) < CAST('4:00:00' AS TIME)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Un lavoratore non può lavorare meno di 4 ore.';
    END IF;
    
    IF
		NEW.GiornoLibero < 2
        OR
        NEW.GiornoLibero > 7
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Da 2 a 7. La Domenica è già contata e varrebbe 1. ';
    END IF;
END $$
DELIMITER ;

# Controlla che non venga inserito in Turni Di Lavoro per Capocantiere un Capocantiere Pensionato
DROP TRIGGER IF EXISTS ControlloPensionamentoCapocantieri;
DELIMITER $$
CREATE TRIGGER ControlloPensionamentoCapocantieri
BEFORE INSERT ON Turni_Di_Lavoro_Capocantiere
FOR EACH ROW
BEGIN
    IF    
		 (SELECT C.Pensione
          FROM Capocantiere C
          WHERE C.CodiceFiscale = NEW.CodiceFiscale) = TRUE
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Capocantiere è Pensionato.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'Orario di Fine non sia minore o uguale a quello dell'inizio in Turni Di Lavoro per Capocantiere nell'inserimento
DROP TRIGGER IF EXISTS ControlloInserimentoOrariCapocantieri;
DELIMITER $$
CREATE TRIGGER ControlloInserimentoOrariCapocantieri
BEFORE INSERT ON Turni_Di_Lavoro_Capocantiere
FOR EACH ROW
BEGIN
    IF    
		NEW.OrarioFine <= NEW.OrarioInizio
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Orario di Fine deve essere maggiore di quello di Inizio.';
    END IF;
    
    IF
		TIMEDIFF(TIMEDIFF(NEW.OrarioFine, NEW.OrarioInizio), CONCAT(NEW.OrePausa, ':00:00')) > CAST('10:00:00' AS TIME)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Un lavoratore non può lavorare per più di 10 ore di fila.';
    END IF;
    
    IF
		TIMEDIFF(TIMEDIFF(NEW.OrarioFine, NEW.OrarioInizio), CONCAT(NEW.OrePausa, ':00:00')) < CAST('4:00:00' AS TIME)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Un lavoratore non può lavorare meno di 4 ore.';
    END IF;
    
    IF
		NEW.GiornoLibero < 2
        OR
        NEW.GiornoLibero > 7
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Da 2 a 7. La Domenica è già contata e varrebbe 1. ';
    END IF;
END $$
DELIMITER ;

# Controlla che l'Orario di Fine non sia minore o uguale a quello dell'inizio in Turni Di Lavoro per Capocantiere nell'aggiornamento
DROP TRIGGER IF EXISTS ControlloAggiornamentoOrariCapocantieri;
DELIMITER $$
CREATE TRIGGER ControlloAggiornamentoOrariCapocantieri
BEFORE UPDATE ON Turni_Di_Lavoro_Capocantiere
FOR EACH ROW
BEGIN
    IF    
		NEW.OrarioFine <= NEW.OrarioInizio
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Orario di Fine deve essere maggiore di quello di Inizio.';
    END IF;
    
    IF
		TIMEDIFF(TIMEDIFF(NEW.OrarioFine, NEW.OrarioInizio), CONCAT(NEW.OrePausa, ':00:00')) > CAST('10:00:00' AS TIME)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Un lavoratore non può lavorare per più di 10 ore di fila.';
    END IF;
    
    IF
		TIMEDIFF(TIMEDIFF(NEW.OrarioFine, NEW.OrarioInizio), CONCAT(NEW.OrePausa, ':00:00')) < CAST('4:00:00' AS TIME)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Un lavoratore non può lavorare meno di 4 ore.';
    END IF;
    
    IF
		NEW.GiornoLibero < 2
        OR
        NEW.GiornoLibero > 7
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Da 2 a 7. La Domenica è già contata e varrebbe 1. ';
    END IF;
END $$
DELIMITER ;

# Controlla che non venga inserito in Turni Di Lavoro per Responsabile un Responsabile Pensionato
DROP TRIGGER IF EXISTS ControlloPensionamentoResponsabili;
DELIMITER $$
CREATE TRIGGER ControlloPensionamentoResponsabili
BEFORE INSERT ON Turni_Di_Lavoro_Responsabile
FOR EACH ROW
BEGIN
    IF    
		 (SELECT R.Pensione
          FROM Responsabile R
          WHERE R.CodiceFiscale = NEW.CodiceFiscale) = TRUE
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Responsabile è Pensionato.';
    END IF;
END $$
DELIMITER ;

# Controlla che l'Orario di Fine non sia minore o uguale a quello dell'inizio in Turni Di Lavoro per Responsabile nell'inserimento
DROP TRIGGER IF EXISTS ControlloInserimentoOrariResponsabili;
DELIMITER $$
CREATE TRIGGER ControlloInserimentoOrariResponsabili
BEFORE INSERT ON Turni_Di_Lavoro_Responsabile
FOR EACH ROW
BEGIN
    IF    
		NEW.OrarioFine <= NEW.OrarioInizio
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Orario di Fine deve essere maggiore di quello di Inizio.';
    END IF;
    
    IF
		TIMEDIFF(TIMEDIFF(NEW.OrarioFine, NEW.OrarioInizio), CONCAT(NEW.OrePausa, ':00:00')) > CAST('10:00:00' AS TIME)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Un lavoratore non può lavorare per più di 10 ore di fila.';
    END IF;
    
    IF
		TIMEDIFF(TIMEDIFF(NEW.OrarioFine, NEW.OrarioInizio), CONCAT(NEW.OrePausa, ':00:00')) < CAST('4:00:00' AS TIME)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Un lavoratore non può lavorare meno di 4 ore.';
    END IF;
    
    IF
		NEW.GiornoLibero < 2
        OR
        NEW.GiornoLibero > 7
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Da 2 a 7. La Domenica è già contata e varrebbe 1. ';
    END IF;
END $$
DELIMITER ;

# Controlla che l'Orario di Fine non sia minore o uguale a quello dell'inizio in Turni Di Lavoro per Responsabile nell'inserimento
DROP TRIGGER IF EXISTS ControlloAggiornamentoOrariResponsabili;
DELIMITER $$
CREATE TRIGGER ControlloAggiornamentoOrariResponsabili
BEFORE UPDATE ON Turni_Di_Lavoro_Responsabile
FOR EACH ROW
BEGIN
    IF    
		NEW.OrarioFine <= NEW.OrarioInizio
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Orario di Fine deve essere maggiore di quello di Inizio.';
    END IF;
    
    IF
		TIMEDIFF(TIMEDIFF(NEW.OrarioFine, NEW.OrarioInizio), CONCAT(NEW.OrePausa, ':00:00')) > CAST('10:00:00' AS TIME)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Un lavoratore non può lavorare per più di 10 ore di fila.';
    END IF;
    
    IF
		TIMEDIFF(TIMEDIFF(NEW.OrarioFine, NEW.OrarioInizio), CONCAT(NEW.OrePausa, ':00:00')) < CAST('4:00:00' AS TIME)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Un lavoratore non può lavorare meno di 4 ore.';
    END IF;
    
    IF
		NEW.GiornoLibero < 2
        OR
        NEW.GiornoLibero > 7
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Da 2 a 7. La Domenica è già contata e varrebbe 1. ';
    END IF;
END $$
DELIMITER ;

# Controlla che nell'inserimento di un Pericolo Geologico ci sia un Coefficiente di Rischio compreso tra 0 e 1
DROP TRIGGER IF EXISTS ControlloInserimentoPericoloGeologico;
DELIMITER $$
CREATE TRIGGER ControlloInserimentoPericoloGeologico
BEFORE INSERT ON PericoloGeologico
FOR EACH ROW
BEGIN
    IF    
		NEW.CoefficienteRischio <= 0
        OR 
        NEW.CoefficienteRischio > 1
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Coefficiente di Rischio non può essere 0 né maggiore di 1.';
    END IF;
END $$
DELIMITER ;

# Controlla che nell'aggiornamento di un Pericolo Geologico ci sia un Coefficiente di Rischio compreso tra 0 e 1
DROP TRIGGER IF EXISTS ControlloAggiornamentoPericoloGeologico;
DELIMITER $$
CREATE TRIGGER ControlloAggiornamentoPericoloGeologico
BEFORE UPDATE ON PericoloGeologico
FOR EACH ROW
BEGIN
    IF    
		NEW.CoefficienteRischio <= 0
        OR 
        NEW.CoefficienteRischio > 1
	THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Il Coefficiente di Rischio non può essere 0 né maggiore di 1.';
    END IF;
END $$
DELIMITER ;

# Controlla l'Inserimento di un Pericolo in Pericolo Geologico
DROP TRIGGER IF EXISTS ControlloPericolo;
DELIMITER $$
CREATE TRIGGER ControlloPericolo
BEFORE INSERT ON PericoloGeologico
FOR EACH ROW
BEGIN
	IF
		NEW.Pericolo <> 'Alluvione'
        AND
        NEW.Pericolo <> 'Ciclone'
        AND
        NEW.Pericolo <> 'Gelo'
        AND
        NEW.Pericolo <> 'Innalzamento Umidità Esterna'
        AND
        NEW.Pericolo <> 'Innalzamento Umidità Interna'
		AND
        NEW.Pericolo <> 'Eruzione Vulcanica'
		AND
		NEW.Pericolo <> 'Incendio'
        AND
        NEW.Pericolo <> 'Impatto Meteorico'
        AND
        NEW.Pericolo <> 'Inondazione'
        AND
        NEW.Pericolo <> 'Frana'
        AND
		NEW.Pericolo <> 'Ondata di Caldo' 
		AND
        NEW.Pericolo <> 'Ondata di Freddo' 
		AND
        NEW.Pericolo <> 'Terremoto'
        AND
        NEW.Pericolo <> 'Tornado'
        AND
        NEW.Pericolo <> 'Valanga'
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Pericolo non valido!';
    END IF;	
END $$;
DELIMITER ;

# Controlla l'Inserimento del Tipo di una Calamità 
DROP TRIGGER IF EXISTS ControlloInserimentoCalamita;
DELIMITER $$
CREATE TRIGGER ControlloInserimentoCalamita
BEFORE INSERT ON Calamita
FOR EACH ROW
BEGIN
	IF
		NEW.Nome <> 'Alluvione'
        AND
        NEW.Nome <> 'Ciclone'
        AND
        NEW.Nome <> 'Gelo'
        AND
        NEW.Nome <> 'Innalzamento Umidità Esterna'
        AND
        NEW.Nome <> 'Innalzamento Umidità Interna'
		AND
        NEW.Nome <> 'Eruzione Vulcanica'
		AND
		NEW.Nome <> 'Incendio'
        AND
        NEW.Nome <> 'Impatto Meteorico'
        AND
        NEW.Nome <> 'Inondazione'
        AND
        NEW.Nome <> 'Frana'
        AND
		NEW.Nome <> 'Ondata di Caldo' 
		AND
        NEW.Nome <> 'Ondata di Freddo' 
		AND
        NEW.Nome <> 'Terremoto'
        AND
        NEW.Nome <> 'Tornado'
        AND
        NEW.Nome <> 'Valanga'
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Pericolo non valido!';
    END IF;	
    
    IF
		NEW.Epicentro < 0 
    THEN 
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Epicentro non può essere negativo.';
	END IF;
    
	IF
		NEW.Intensita < 1
        OR
        NEW.Intensita > 12
    THEN 
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Intensità compresa tra 1 e 12.';
	END IF;
    
	IF
		(
			SELECT IFNULL(COUNT(*), 0)
			FROM Calamita C
			WHERE C.Area = NEW.Area
				 AND
				  C.Data = NEW.Data
				 AND
				  (C.Orario > NEW.Orario
				   AND
				   C.Orario < DATE_ADD(NEW.Orario, INTERVAL 10 MINUTE))
		) 
		>
		0
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Deve essere Orario+10m da ultima Calamità.';
	END IF;
END $$;
DELIMITER ;

# Controlla l'Aggiornamento del Tipo di una Calamità 
DROP TRIGGER IF EXISTS ControlloAggiornamentoCalamita;
DELIMITER $$
CREATE TRIGGER ControlloAggiornamentoCalamita
BEFORE UPDATE ON Calamita
FOR EACH ROW
BEGIN
	IF
		NEW.Nome <> 'Alluvione'
        AND
        NEW.Nome <> 'Ciclone'
        AND
        NEW.Nome <> 'Gelo'
        AND
        NEW.Nome <> 'Innalzamento Umidità Esterna'
        AND
        NEW.Nome <> 'Innalzamento Umidità Interna'
		AND
        NEW.Nome <> 'Eruzione Vulcanica'
		AND
		NEW.Nome <> 'Incendio'
        AND
        NEW.Nome <> 'Impatto Meteorico'
        AND
        NEW.Nome <> 'Inondazione'
        AND
        NEW.Nome <> 'Frana'
        AND
		NEW.Nome <> 'Ondata di Caldo' 
		AND
        NEW.Nome <> 'Ondata di Freddo' 
		AND
        NEW.Nome <> 'Terremoto'
        AND
        NEW.Nome <> 'Tornado'
        AND
        NEW.Nome <> 'Valanga'
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare!Pericolo non valido!';
    END IF;	
    
    IF
		NEW.Epicentro < 0 
    THEN 
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Epicentro non può essere negativo.';
	END IF;
    
        IF
		NEW.Intensita < 1
        OR
        NEW.Intensita > 12
    THEN 
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Intensità compresa tra 1 e 12.';
	END IF;    
    
    IF
		(
			SELECT IFNULL(COUNT(*), 0)
			FROM Calamita C
			WHERE C.Area = NEW.Area
				 AND
				  C.Data = NEW.Data
				 AND
				  (C.Orario >= NEW.Orario
				   AND
				   C.Orario < DATE_ADD(NEW.Orario, INTERVAL 10 MINUTE))
		) 
		>
		0
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! Deve essere Orario+10m da ultima Calamità.';
	END IF;
END $$;
DELIMITER ;

# Controlla che la quantità stoccata di un materiale non sia 0 in Altri Materiali, controlla che il costo sia maggiore o uguale a 0 e controlla il Codice Lotto
DROP TRIGGER IF EXISTS ControllaInserimentoAltriMateriali;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoAltriMateriali
BEFORE INSERT ON AltriMateriali
FOR EACH ROW
BEGIN
	IF
		NEW.QuantitaStoccata <= 0
        OR
        NEW.QuantitaStoccata <> NEW.QuantitaComprata
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Lotto non valido.';
	END IF;
    
    IF
		NEW.Codice_Lotto 
        IN
        (SELECT I.Codice_Lotto
		 FROM Intonaco I
         UNION
         SELECT M.Codice_Lotto
		 FROM Mattoni M
         UNION
         SELECT P.Codice_Lotto
		 FROM Piastrelle P
         UNION
         SELECT P.Codice_Lotto
		 FROM Pietre P)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire questo Codice Lotto!';
    END IF;
    
    IF
		NEW.Costo < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Costo è minore di 0.';
    END IF;
END $$
DELIMITER ;

# Controlla il Codice Lotto di Altri Materiali, controlla che il costo sia maggiore o uguale a 0 e QuantitaComprata non può essere messa minore di quella stoccata
DROP TRIGGER IF EXISTS ControllaAggiornamentoAltriMateriali;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoAltriMateriali
BEFORE UPDATE ON AltriMateriali
FOR EACH ROW
BEGIN   
    IF
		NEW.Codice_Lotto 
        IN
        (SELECT I.Codice_Lotto
		 FROM Intonaco I
         UNION
         SELECT M.Codice_Lotto
		 FROM Mattoni M
         UNION
         SELECT P.Codice_Lotto
		 FROM Piastrelle P
         UNION
         SELECT P.Codice_Lotto
		 FROM Pietre P)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire questo Codice Lotto!';
    END IF;
    
	IF
		NEW.Costo < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Il Costo è minore di 0.';
    END IF;
    
	IF
		NEW.QuantitaComprata < NEW.QuantitaStoccata
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! La Quantità Comprata non può essere minore di quella stoccata.';
    END IF;
END $$
DELIMITER ;

# Controlla che la quantità stoccata di un materiale non sia 0 in Intonaco, controlla che il costo sia maggiore o uguale a 0 e controlla il Codice Lotto
DROP TRIGGER IF EXISTS ControllaInserimentoIntonaco;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoIntonaco
BEFORE INSERT ON Intonaco
FOR EACH ROW
BEGIN
	IF
		NEW.QuantitaStoccata <= 0
	OR
        NEW.QuantitaStoccata <> NEW.QuantitaComprata
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Lotto non valido.';
	END IF;
    
	IF
		NEW.Codice_Lotto 
        IN
        (SELECT AM.Codice_Lotto
		 FROM AltriMateriali AM
         UNION
         SELECT M.Codice_Lotto
		 FROM Mattoni M
         UNION
         SELECT P.Codice_Lotto
		 FROM Piastrelle P
         UNION
         SELECT P.Codice_Lotto
		 FROM Pietre P)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire questo Codice Lotto!';
    END IF;
    
    IF
		NEW.Costo < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Costo è minore di 0.';
    END IF;
END $$
DELIMITER ;

# Controlla il Codice Lotto in Intonaco, controlla che il costo sia maggiore o uguale a 0 e QuantitaComprata non può essere messa minore di quella stoccata
DROP TRIGGER IF EXISTS ControllaAggiornamentoIntonaco;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoIntonaco
BEFORE UPDATE ON Intonaco
FOR EACH ROW
BEGIN    
	IF
		NEW.Codice_Lotto 
        IN
        (SELECT AM.Codice_Lotto
		 FROM AltriMateriali AM
         UNION
         SELECT M.Codice_Lotto
		 FROM Mattoni M
         UNION
         SELECT P.Codice_Lotto
		 FROM Piastrelle P
         UNION
         SELECT P.Codice_Lotto
		 FROM Pietre P)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare questo Codice Lotto!';
    END IF;
    
    IF
		NEW.Costo < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Il Costo è minore di 0.';
    END IF;
    
	IF
		NEW.QuantitaComprata < NEW.QuantitaStoccata
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! La Quantità Comprata non può essere minore di quella stoccata.';
    END IF;
END $$
DELIMITER ;

# Controlla che la quantità stoccata di un materiale non sia 0 in Mattoni, controlla che il costo sia maggiore o uguale a 0 e controlla il Codice Lotto
DROP TRIGGER IF EXISTS ControllaInserimentoMattoni;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoMattoni
BEFORE INSERT ON Mattoni
FOR EACH ROW
BEGIN
	IF
		NEW.QuantitaStoccata <= 0
	OR
        NEW.QuantitaStoccata <> NEW.QuantitaComprata
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Lotto non valido.';
	END IF;
    
	IF
		NEW.Codice_Lotto 
        IN
        (SELECT AM.Codice_Lotto
		 FROM AltriMateriali AM
         UNION
         SELECT I.Codice_Lotto
		 FROM Intonaco I
         UNION
         SELECT P.Codice_Lotto
		 FROM Piastrelle P
         UNION
         SELECT P.Codice_Lotto
		 FROM Pietre P)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire questo Codice Lotto!';
    END IF;
    
    IF
		NEW.Costo < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Costo è minore di 0.';
    END IF;
END $$
DELIMITER ;

# Controlla il Codice Lotto in Mattoni, controlla che il costo sia maggiore o uguale a 0 e QuantitaComprata non può essere messa minore di quella stoccata
DROP TRIGGER IF EXISTS ControllaAggiornamentoMattoni;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoMattoni
BEFORE UPDATE ON Mattoni
FOR EACH ROW
BEGIN    
	IF
		NEW.Codice_Lotto 
        IN
        (SELECT AM.Codice_Lotto
		 FROM AltriMateriali AM
         UNION
         SELECT I.Codice_Lotto
		 FROM Intonaco I
         UNION
         SELECT P.Codice_Lotto
		 FROM Piastrelle P
         UNION
         SELECT P.Codice_Lotto
		 FROM Pietre P)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare questo Codice Lotto!';
    END IF;
    
    IF
		NEW.Costo < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Il Costo è minore di 0.';
    END IF;
    
	IF
		NEW.QuantitaComprata < NEW.QuantitaStoccata
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! La Quantità Comprata non può essere minore di quella stoccata.';
    END IF;
END $$
DELIMITER ;

# Controlla che la quantità stoccata di un materiale non sia 0 in Piastrelle, guarda che la fuga non sia 0, controlla che il costo sia maggiore o uguale a 0 e controlla il Codice Lotto
DROP TRIGGER IF EXISTS ControllaInserimentoPiastrelle;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoPiastrelle
BEFORE INSERT ON Piastrelle
FOR EACH ROW
BEGIN
	IF
		NEW.QuantitaStoccata <= 0
	OR
        NEW.QuantitaStoccata <> NEW.QuantitaComprata
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Lotto non valido.';
	END IF;
    
	IF
		NEW.Codice_Lotto 
        IN
        (SELECT AM.Codice_Lotto
		 FROM AltriMateriali AM
         UNION
         SELECT I.Codice_Lotto
		 FROM Intonaco I
         UNION
         SELECT M.Codice_Lotto
		 FROM Mattoni M
         UNION
         SELECT P.Codice_Lotto
		 FROM Pietre P)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire questo Codice Lotto!';
    END IF;
    
	IF
		NEW.Fuga < 0
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Non puoi inserire una fuga minore di 0.';
	END IF;
    
    IF
		NEW.Costo < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Costo è minore di 0.';
    END IF;
END $$
DELIMITER ;

# Controlla che la fuga non sia 0 nell'aggiornamento delle Piastrelle e controlla il Codice Lotto, controlla che il costo sia maggiore o uguale a 0 e QuantitaComprata non può essere messa minore di quella stoccata
DROP TRIGGER IF EXISTS ControllaAggiornamentoPiastrelle;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoPiastrelle
BEFORE UPDATE ON Piastrelle
FOR EACH ROW
BEGIN
	IF
		NEW.Fuga < 0
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Non puoi inserire una fuga minore di 0.';
	END IF;
        
	IF
		NEW.Codice_Lotto 
        IN
        (SELECT AM.Codice_Lotto
		 FROM AltriMateriali AM
         UNION
         SELECT I.Codice_Lotto
		 FROM Intonaco I
         UNION
         SELECT M.Codice_Lotto
		 FROM Mattoni M
         UNION
         SELECT P.Codice_Lotto
		 FROM Pietre P)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare questo Codice Lotto!';
    END IF;
    
    IF
		NEW.Costo < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Il Costo è minore di 0.';
    END IF;
    
	IF
		NEW.QuantitaComprata < NEW.QuantitaStoccata
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! La Quantità Comprata non può essere minore di quella stoccata.';
    END IF;
END $$
DELIMITER ;

# Controlla che la quantità stoccata di un materiale non sia 0 in Pietre, lo spessore non può essere minore di 0, controlla che il costo sia maggiore o uguale a 0 e controlla il Codice Lotto
DROP TRIGGER IF EXISTS ControllaInserimentoPietre;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoPietre
BEFORE INSERT ON Pietre
FOR EACH ROW
BEGIN
	IF
		NEW.QuantitaStoccata <= 0
	OR
        NEW.QuantitaStoccata <> NEW.QuantitaComprata
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Quantita Errata.';
	END IF;
        
	IF
		NEW.Codice_Lotto 
        IN
        (SELECT AM.Codice_Lotto
		 FROM AltriMateriali AM
         UNION
         SELECT I.Codice_Lotto
		 FROM Intonaco I
         UNION
         SELECT M.Codice_Lotto
		 FROM Mattoni M
         UNION
         SELECT P.Codice_Lotto
		 FROM Piastrelle P)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire questo Codice Lotto!';
    END IF;
    
	IF
		NEW.Spessore < 0
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Non puoi inserire uno spessore minore di 0.';
	END IF;
    
    IF
		NEW.Costo < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Il Costo è minore di 0.';
    END IF;
END $$
DELIMITER ;

# Controlla che lo spessore non sia 0 nell'aggiornamento delle Pietre e controlla il Codice Lotto, controlla che il costo sia maggiore o uguale a 0 e QuantitaComprata non può essere messa minore di quella stoccata
DROP TRIGGER IF EXISTS ControllaAggiornamentoPietre;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoPietre
BEFORE UPDATE ON Pietre
FOR EACH ROW
BEGIN    
	IF
		NEW.Spessore < 0
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Non puoi inserire uno spessore minore di 0.';
	END IF;
    
	IF
		NEW.Codice_Lotto 
        IN
        (SELECT AM.Codice_Lotto
		 FROM AltriMateriali AM
         UNION
         SELECT I.Codice_Lotto
		 FROM Intonaco I
         UNION
         SELECT M.Codice_Lotto
		 FROM Mattoni M
         UNION
         SELECT P.Codice_Lotto
		 FROM Piastrelle P)
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare questo Codice Lotto!';
    END IF;
    
    IF
		NEW.Costo < 0
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Il Costo è minore di 0.';
    END IF;
    
	IF
		NEW.QuantitaComprata < NEW.QuantitaStoccata
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! La Quantità Comprata non può essere minore di quella stoccata.';
    END IF;
END $$
DELIMITER ;

# Controlla che lo spessore non sia 0 nell'inserimento dello Strato
DROP TRIGGER IF EXISTS ControllaInserimentoStrato;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoStrato
BEFORE INSERT ON Strato
FOR EACH ROW
BEGIN   
	IF
		NEW.Spessore <= 0
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! Non puoi inserire uno spessore minore di 0.';
	END IF;
END $$
DELIMITER ;

# Controlla che lo spessore non sia 0 nell'aggiornamento dello Strato
DROP TRIGGER IF EXISTS ControllaAggiornamentoStrato;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoStrato
BEFORE INSERT ON Strato
FOR EACH ROW
BEGIN    
	IF
		NEW.Spessore <= 0
	THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile aggiornare! Non puoi inserire uno spessore minore di 0.';
	END IF;
END $$
DELIMITER ;

# Controlla che non venga inserita una quantità maggiore rispetto a quella stoccata nel lotto selezionato negli Altri Materiali e aggiorna il lotto
DROP TRIGGER IF EXISTS ControllaInserimentoQuantitaImpiegoAltriMateriali;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoQuantitaImpiegoAltriMateriali
BEFORE INSERT ON ImpiegoAltriMateriali
FOR EACH ROW
BEGIN
	IF
		NEW.Quantita 
        >
        (
		 SELECT AM.QuantitaStoccata
         FROM AltriMateriali AM
         WHERE AM.Codice_Lotto = NEW.Lotto_Altri_Materiali
        )
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! La quantità richiesta è incorretta.';
	ELSEIF
		NEW.Quantita
        <=
		(
		 SELECT AM.QuantitaStoccata
         FROM AltriMateriali AM
         WHERE AM.Codice_Lotto = NEW.Lotto_Altri_Materiali
        )
	THEN
		UPDATE AltriMateriali
        SET QuantitaStoccata = QuantitaStoccata - NEW.Quantita
        WHERE Codice_Lotto = NEW.Lotto_Altri_Materiali;
    END IF;
END $$
DELIMITER ;

# Impedisce di inserire un Lotto in Impiego Altri Materiali se la sua data di compravendita è maggiore rispetto a quella di fine Lavoro
DROP TRIGGER IF EXISTS ControllaInserimentoDataImpiegoAltriMateriali;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoDataImpiegoAltriMateriali
BEFORE INSERT ON ImpiegoAltriMateriali
FOR EACH ROW
BEGIN
    IF
		(SELECT AM.DataAcquisto
         FROM AltriMateriali AM
         WHERE AM.Codice_Lotto = NEW.Lotto_Altri_Materiali)
		>
		(SELECT IFNULL(L.DataFine, '2000-01-01')
		 FROM Lavoro L
		 WHERE L.Codice_Lavoro = NEW.Lavoro)
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Lotto comprato dopo la fine del lavoro.';
    END IF;
END $$
DELIMITER ;

# Impedisce di aggiornare un Lotto in Impiego Altri Materiali se la sua data di compravendita è maggiore rispetto a quella di fine Lavoro
DROP TRIGGER IF EXISTS ControllaAggiornamentoDataImpiegoAltriMateriali;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoDataImpiegoAltriMateriali
BEFORE UPDATE ON ImpiegoAltriMateriali
FOR EACH ROW
BEGIN
    IF
		(SELECT AM.DataAcquisto
         FROM AltriMateriali AM
         WHERE AM.Codice_Lotto = NEW.Lotto_Altri_Materiali)
		>
		(SELECT L.DataFine
		 FROM Lavoro L
		 WHERE L.Codice_Lavoro = NEW.Lavoro)
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! Lotto comprato dopo la fine del lavoro.';
    END IF;
END $$
DELIMITER ;

# Controlla che non venga aggiornata una quantità maggiore rispetto a quella stoccata nel lotto selezionato negli Altri Materiali e aggiorna il lotto
DROP TRIGGER IF EXISTS ControllaAggiornamentoQuantitaImpiegoAltriMateriali;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoQuantitaImpiegoAltriMateriali
BEFORE UPDATE ON ImpiegoAltriMateriali
FOR EACH ROW
BEGIN
	IF
		NEW.Quantita > OLD.Quantita
    THEN
		IF
			(NEW.Quantita-OLD.Quantita)
			>
			(
			 SELECT AM.QuantitaStoccata
			 FROM AltriMateriali AM
			 WHERE AM.Codice_Lotto = NEW.Lotto_Altri_Materiali
			)
		THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Impossibile aggiornare! La quantità richiesta è incorretta.';
		ELSEIF
			(NEW.Quantita-OLD.Quantita)
			<=
			(
			 SELECT AM.QuantitaStoccata
			 FROM AltriMateriali AM
			 WHERE AM.Codice_Lotto = NEW.Lotto_Altri_Materiali
			)
		THEN
			UPDATE AltriMateriali
			SET QuantiataStoccata = QuantitaStoccata - (NEW.Quantita-OLD.Quantita)
			WHERE Codice_Lotto = NEW.Lotto_Altri_Materiali;
        END IF;
	ELSEIF
		NEW.Quantita
        <
		OLD.Quantita
	THEN
		UPDATE AltriMateriali
        SET QuantitaStoccata = QuantitaStoccata + (OLD.Quantita-NEW.Quantita)
        WHERE Codice_Lotto = NEW.Lotto_Altri_Materiali;
    END IF;
END $$
DELIMITER ;

# Controlla che non venga inserita una quantità maggiore rispetto a quella stoccata nel lotto selezionato nell'Intonaco e aggiorna il lotto
DROP TRIGGER IF EXISTS ControllaInserimentoQuantitaImpiegoIntonaco;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoQuantitaImpiegoIntonaco
BEFORE INSERT ON ImpiegoIntonaco
FOR EACH ROW
BEGIN
	IF
		NEW.Quantita 
        >
        (
		 SELECT I.QuantitaStoccata
         FROM Intonaco I
         WHERE I.Codice_Lotto = NEW.Lotto_Intonaco
        )
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! La quantità richiesta è incorretta.';
	ELSEIF
		NEW.Quantita
        <=
		(
		 SELECT I.QuantitaStoccata
         FROM Intonaco I
         WHERE I.Codice_Lotto = NEW.Lotto_Intonaco
        )
	THEN
		UPDATE Intonaco
        SET QuantitaStoccata = QuantitaStoccata - NEW.Quantita
        WHERE Codice_Lotto = NEW.Lotto_Intonaco;
    END IF;
END $$
DELIMITER ;

# Impedisce di inserire un Lotto in Impiego Intonaco se la sua data di compravendita è maggiore rispetto a quella di fine Lavoro
DROP TRIGGER IF EXISTS ControllaInserimentoDataImpiegoIntonaco;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoDataImpiegoIntonaco
BEFORE INSERT ON ImpiegoIntonaco
FOR EACH ROW
BEGIN
    IF
		(SELECT I.DataAcquisto
         FROM Intonaco I
         WHERE I.Codice_Lotto = NEW.Lotto_Intonaco)
		>
		(SELECT IFNULL(L.DataFine, '2000-01-01')
		 FROM Lavoro L
		 WHERE L.Codice_Lavoro = NEW.Lavoro)
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Lotto comprato dopo la fine del lavoro.';
    END IF;
END $$
DELIMITER ;

# Impedisce di aggiornare un Lotto in Impiego Intonaco se la sua data di compravendita è maggiore rispetto a quella di fine Lavoro
DROP TRIGGER IF EXISTS ControllaAggiornamentoDataImpiegoIntonaco;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoDataImpiegoIntonaco
BEFORE UPDATE ON ImpiegoIntonaco
FOR EACH ROW
BEGIN
    IF
		(SELECT I.DataAcquisto
         FROM Intonaco I
         WHERE I.Codice_Lotto = NEW.Lotto_Intonaco)
		>
		(SELECT L.DataFine
		 FROM Lavoro L
		 WHERE L.Codice_Lavoro = NEW.Lavoro)
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! Lotto comprato dopo la fine del lavoro.';
    END IF;
END $$
DELIMITER ;

# Controlla che non venga aggiornata una quantità maggiore rispetto a quella stoccata nel lotto selezionato nell'Intonaco e aggiorna il lotto
DROP TRIGGER IF EXISTS ControllaAggiornamentoQuantitaImpiegoIntonaco;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoQuantitaImpiegoIntonaco
BEFORE UPDATE ON ImpiegoIntonaco
FOR EACH ROW
BEGIN
	IF
		NEW.Quantita 
        >
		OLD.Quantita
    THEN
		IF
			(NEW.Quantita-OLD.Quantita)
			>
			(
			 SELECT I.QuantitaStoccata
			 FROM Intonaco I
			 WHERE I.Codice_Lotto = NEW.Lotto_Intonaco
			)
		THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Impossibile aggiornare! La quantità richiesta è incorretta.';
		ELSEIF
			(NEW.Quantita-OLD.Quantita)
			<=
			(
			 SELECT I.QuantitaStoccata
			 FROM Intonaco I
			 WHERE I.Codice_Lotto = NEW.Lotto_Intonaco
			)
		THEN
			UPDATE Intonaco
			SET QuantitaStoccata = QuantitaStoccata - (NEW.Quantita-OLD.Quantita)
			WHERE Codice_Lotto = NEW.Lotto_Intonaco;
        END IF;
	ELSEIF
		NEW.Quantita
        <
		OLD.Quantita
	THEN
		UPDATE Intonaco
        SET QuantitaStoccata = QuantitaStoccata + (OLD.Quantita-NEW.Quantita)
        WHERE Codice_Lotto = NEW.Lotto_Intonaco;
    END IF;
END $$
DELIMITER ;

# Controlla che non venga inserita una quantità maggiore rispetto a quella stoccata nel lotto selezionato nei Mattoni e aggiorna il lotto
DROP TRIGGER IF EXISTS ControllaInserimentoQuantitaImpiegoMattoni;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoQuantitaImpiegoMattoni
BEFORE INSERT ON ImpiegoMattoni
FOR EACH ROW
BEGIN
	IF
		NEW.Quantita 
        >
        (
		 SELECT M.QuantitaStoccata
         FROM Mattoni M
         WHERE M.Codice_Lotto = NEW.Lotto_Mattoni
        )
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! La quantità richiesta è incorretta.';
	ELSEIF
		NEW.Quantita
        <=
		(
		 SELECT M.QuantitaStoccata
         FROM Mattoni M
         WHERE M.Codice_Lotto = NEW.Lotto_Mattoni
        )
	THEN
		UPDATE Mattoni
        SET QuantitaStoccata = QuantitaStoccata - NEW.Quantita
        WHERE Codice_Lotto = NEW.Lotto_Mattoni;
    END IF;
END $$
DELIMITER ;

# Impedisce di inserire un Lotto in Impiego Mattoni se la sua data di compravendita è maggiore rispetto a quella di fine Lavoro
DROP TRIGGER IF EXISTS ControllaInserimentoDataImpiegoMattoni;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoDataImpiegoMattoni
BEFORE INSERT ON ImpiegoMattoni
FOR EACH ROW
BEGIN
    IF
		(SELECT M.DataAcquisto
         FROM Mattoni M
         WHERE M.Codice_Lotto = NEW.Lotto_Mattoni)
		>
		(SELECT IFNULL(L.DataFine, '2000-01-01')
		 FROM Lavoro L
		 WHERE L.Codice_Lavoro = NEW.Lavoro)
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Lotto comprato dopo la fine del lavoro.';
    END IF;
END $$
DELIMITER ;

# Impedisce di aggiornare un Lotto in Impiego Mattoni se la sua data di compravendita è maggiore rispetto a quella di fine Lavoro
DROP TRIGGER IF EXISTS ControllaAggiornamentoDataImpiegoMattoni;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoDataImpiegoMattoni
BEFORE UPDATE ON ImpiegoMattoni
FOR EACH ROW
BEGIN
    IF
		(SELECT M.DataAcquisto
         FROM Mattoni M
         WHERE M.Codice_Lotto = NEW.Lotto_Mattoni)
		>
		(SELECT L.DataFine
		 FROM Lavoro L
		 WHERE L.Codice_Lavoro = NEW.Lavoro)
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! Lotto comprato dopo la fine del lavoro.';
    END IF;
END $$
DELIMITER ;

# Controlla che non venga aggiornata una quantità maggiore rispetto a quella stoccata nel lotto selezionato nei Mattoni e aggiorna il lotto
DROP TRIGGER IF EXISTS ControllaAggiornamentoQuantitaImpiegoMattoni;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoQuantitaImpiegoMattoni
BEFORE UPDATE ON ImpiegoMattoni
FOR EACH ROW
BEGIN
	IF
		NEW.Quantita 
        >
		OLD.Quantita
    THEN
		IF
			(NEW.Quantita-OLD.Quantita)
			>
			(
			 SELECT M.QuantitaStoccata
			 FROM Mattoni M
			 WHERE M.Codice_Lotto = NEW.Lotto_Mattoni
			)
		THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Impossibile aggiornare! La quantità richiesta è incorretta.';
		ELSEIF
			(NEW.Quantita-OLD.Quantita)
			<=
			(
			 SELECT M.QuantitaStoccata
			 FROM Mattoni M
			 WHERE M.Codice_Lotto = NEW.Lotto_Mattoni
			)
		THEN
			UPDATE Mattoni
			SET QuantitaStoccata = QuantitaStoccata - (NEW.Quantita-OLD.Quantita)
			WHERE Codice_Lotto = NEW.Lotto_Mattoni;
        END IF;
	ELSEIF
		NEW.Quantita
        <
		OLD.Quantita
	THEN
		UPDATE Mattoni
        SET QuantitaStoccata = QuantitaStoccata + (OLD.Quantita-NEW.Quantita)
        WHERE Codice_Lotto = NEW.Lotto_Mattoni;
    END IF;
END $$
DELIMITER ;

# Controlla che non venga inserita una quantità maggiore rispetto a quella stoccata nel lotto selezionato nelle Piastrelle e aggiorna il lotto
DROP TRIGGER IF EXISTS ControllaInserimentoQuantitaImpiegoPiastrelle;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoQuantitaImpiegoPiastrelle
BEFORE INSERT ON ImpiegoPiastrelle
FOR EACH ROW
BEGIN
	IF
		NEW.Quantita 
        >
        (
		 SELECT P.QuantitaStoccata
         FROM Piastrelle P
         WHERE P.Codice_Lotto = NEW.Lotto_Piastrelle
        )
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! La quantità richiesta è incorretta.';
	ELSEIF
		NEW.Quantita
        <=
		(
		 SELECT P.QuantitaStoccata
         FROM Piastrelle P
         WHERE P.Codice_Lotto = NEW.Lotto_Piastrelle
        )
	THEN
		UPDATE Piastrelle
        SET QuantitaStoccata = QuantitaStoccata - NEW.Quantita
        WHERE Codice_Lotto = NEW.Lotto_Piastrelle;
    END IF;
END $$
DELIMITER ;

# Impedisce di inserire un Lotto in Impiego Piastrelle se la sua data di compravendita è maggiore rispetto a quella di fine Lavoro
DROP TRIGGER IF EXISTS ControllaInserimentoDataImpiegoPiastrelle;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoDataImpiegoPiastrelle
BEFORE INSERT ON ImpiegoPiastrelle
FOR EACH ROW
BEGIN
    IF
		(SELECT P.DataAcquisto
         FROM Piastrelle P
         WHERE P.Codice_Lotto = NEW.Lotto_Piastrelle)
		>
		(SELECT IFNULL(L.DataFine, '2000-01-01')
		 FROM Lavoro L
		 WHERE L.Codice_Lavoro = NEW.Lavoro)
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Lotto comprato dopo la fine del lavoro.';
    END IF;
END $$
DELIMITER ;

# Impedisce di aggiornare un Lotto in Impiego Piastrelle se la sua data di compravendita è maggiore rispetto a quella di fine Lavoro
DROP TRIGGER IF EXISTS ControllaAggiornamentoDataImpiegoPiastrelle;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoDataImpiegoPiastrelle
BEFORE UPDATE ON ImpiegoPiastrelle
FOR EACH ROW
BEGIN
    IF
		(SELECT P.DataAcquisto
         FROM Piastrelle P
         WHERE P.Codice_Lotto = NEW.Lotto_Piastrelle)
		>
		(SELECT L.DataFine
		 FROM Lavoro L
		 WHERE L.Codice_Lavoro = NEW.Lavoro)
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! Lotto comprato dopo la fine del lavoro.';
    END IF;
END $$
DELIMITER ;

# Controlla che non venga aggiornata una quantità maggiore rispetto a quella stoccata nel lotto selezionato nelle Piastrelle e aggiorna il lotto
DROP TRIGGER IF EXISTS ControllaAggiornamentoQuantitaImpiegoPiastrelle;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoQuantitaImpiegoPiastrelle
BEFORE UPDATE ON ImpiegoPiastrelle
FOR EACH ROW
BEGIN
	IF
		NEW.Quantita 
        >
		OLD.Quantita
    THEN
		IF
			(NEW.Quantita-OLD.Quantita)
			>
			(
			 SELECT P.QuantitaStoccata
			 FROM Piastrelle P
			 WHERE P.Codice_Lotto = NEW.Lotto_Piastrelle
			)
		THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Impossibile aggiornare! La quantità richiesta è incorretta.';
		ELSEIF
			(NEW.Quantita-OLD.Quantita)
			<=
            (
			 SELECT P.QuantitaStoccata
			 FROM Piastrelle P
			 WHERE P.Codice_Lotto = NEW.Lotto_Piastrelle
			)
		THEN
			UPDATE Piastrelle
			SET QuantitaStoccata = QuantitaStoccata - (NEW.Quantita-OLD.Quantita)
			WHERE Codice_Lotto = NEW.Lotto_Piastrelle;
        END IF;
	ELSEIF
		NEW.Quantita
        <
		OLD.Quantita
	THEN
		UPDATE Piastrelle
        SET QuantitaStoccata = QuantitaStoccata + (OLD.Quantita-NEW.Quantita)
        WHERE Codice_Lotto = NEW.Lotto_Piastrelle;
    END IF;
END $$
DELIMITER ;

# Controlla che non venga inserita una quantità maggiore rispetto a quella stoccata nel lotto selezionato nelle Pietre e aggiorna il lotto
DROP TRIGGER IF EXISTS ControllaInserimentoQuantitaImpiegoPietre;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoQuantitaImpiegoPietre
BEFORE INSERT ON ImpiegoPietre
FOR EACH ROW
BEGIN
	IF
		NEW.Quantita 
        >
        (
		 SELECT P.QuantitaStoccata
         FROM Pietre P
         WHERE P.Codice_Lotto = NEW.Lotto_Pietre
        )
    THEN
		SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Impossibile inserire! La quantità richiesta è incorretta.';
	ELSEIF
		NEW.Quantita
        <=
		(
		 SELECT P.QuantitaStoccata
         FROM Pietre P
         WHERE P.Codice_Lotto = NEW.Lotto_Pietre
        )
	THEN
		UPDATE Pietre
        SET QuantitaStoccata = QuantitaStoccata - NEW.Quantita
        WHERE Codice_Lotto = NEW.Lotto_Pietre;
    END IF;
END $$
DELIMITER ;

# Impedisce di inserire un Lotto in Impiego Pietre se la sua data di compravendita è maggiore rispetto a quella di fine Lavoro
DROP TRIGGER IF EXISTS ControllaInserimentoDataImpiegoPietre;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoDataImpiegoPietre
BEFORE INSERT ON ImpiegoPietre
FOR EACH ROW
BEGIN
    IF
		(SELECT P.DataAcquisto
         FROM Pietre P
         WHERE P.Codice_Lotto = NEW.Lotto_Pietre)
		>
		(SELECT IFNULL(L.DataFine, '2000-01-01')
		 FROM Lavoro L
		 WHERE L.Codice_Lavoro = NEW.Lavoro)
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Lotto comprato dopo la fine del lavoro.';
    END IF;
END $$
DELIMITER ;

# Impedisce di aggiornare un Lotto in Impiego Pietre se la sua data di compravendita è maggiore rispetto a quella di fine Lavoro
DROP TRIGGER IF EXISTS ControllaAggiornamentoDataImpiegoPietre;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoDataImpiegoPietre
BEFORE UPDATE ON ImpiegoPietre
FOR EACH ROW
BEGIN
    IF
		(SELECT P.DataAcquisto
         FROM Pietre P
         WHERE P.Codice_Lotto = NEW.Lotto_Pietre)
		>
		(SELECT L.DataFine
		 FROM Lavoro L
		 WHERE L.Codice_Lavoro = NEW.Lavoro)
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! Lotto comprato dopo la fine del lavoro.';
    END IF;
END $$
DELIMITER ;

# Controlla che non venga aggiornata una quantità maggiore rispetto a quella stoccata nel lotto selezionato nelle Pietre e aggiorna il lotto
DROP TRIGGER IF EXISTS ControllaAggiornamentoQuantitaImpiegoPietre;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoQuantitaImpiegoPietre
BEFORE UPDATE ON ImpiegoPietre
FOR EACH ROW
BEGIN
	IF
		NEW.Quantita 
        >
		OLD.Quantita
    THEN
		IF
			(NEW.Quantita-OLD.Quantita)
			>
			(
			 SELECT P.QuantitaStoccata
			 FROM Pietre P
			 WHERE P.Codice_Lotto = NEW.Lotto_Pietre
			)
		THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Impossibile aggiornare! La quantità richiesta è incorretta.';
		ELSEIF
			(NEW.Quantita-OLD.Quantita)
			<=
			(
			 SELECT P.QuantitaStoccata
			 FROM Pietre P
			 WHERE P.Codice_Lotto = NEW.Lotto_Pietre
			)
		THEN
			UPDATE Pietre
			SET QuantitaStoccata = QuantitaStoccata - (NEW.Quantita-OLD.Quantita)
			WHERE Codice_Lotto = NEW.Lotto_Pietre;
        END IF;
	ELSEIF
		NEW.Quantita
        <
		OLD.Quantita
	THEN
		UPDATE Pietre
        SET QuantitaStoccata = QuantitaStoccata + (OLD.Quantita-NEW.Quantita)
        WHERE Codice_Lotto = NEW.Lotto_Pietre;
    END IF;
END $$
DELIMITER ;

# Controlla l'inserimento dei Sensori
DROP TRIGGER IF EXISTS ControllaInserimentoSensore;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoSensore
BEFORE INSERT ON Sensore
FOR EACH ROW
BEGIN
	IF
        NEW.Categoria <> 'Accelerometro X'
        AND
        NEW.Categoria <> 'Accelerometro Y'
        AND
        NEW.Categoria <> 'Accelerometro Z'
        AND
        NEW.Categoria <> 'Giroscopio X'
        AND
        NEW.Categoria <> 'Giroscopio Y'
        AND
        NEW.Categoria <> 'Giroscopio Z'
        AND
        NEW.Categoria <> 'Termostato Esterno Caldo'
        AND
        NEW.Categoria <> 'Termostato Esterno Freddo'
        AND
        NEW.Categoria <> 'Termostato Interno Caldo'
        AND
        NEW.Categoria <> 'Termostato Interno Freddo'
        AND
        NEW.Categoria <> 'Igrometro Esterno'
		AND
		NEW.Categoria <> 'Igrometro Interno'
		AND 
		NEW.Categoria <> 'Pluviometro'
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! La categoria non è quella valida!';
    END IF;   
    
	IF
		NEW.Categoria = 'Accelerometro X' OR NEW.Categoria = 'Accelerometro Y' OR NEW.Categoria = 'Accelerometro Z'
		OR
		NEW.Categoria = 'Giroscopio X' OR NEW.Categoria = 'Giroscopio Y' OR NEW.Categoria = 'Giroscopio Z'
		OR
		NEW.Categoria = 'Termostato Esterno Caldo' OR NEW.Categoria = 'Termostato Esterno Freddo'
        OR
		NEW.Categoria = 'Igrometro Esterno'
		OR
		NEW.Categoria = 'Pluviometro'
	THEN
		IF
			NOT EXISTS (SELECT M.Codice_Muro
						FROM Muro M INNER JOIN Vano V ON M.Vano1 = V.Codice_Vano OR M.Vano2 = V.Codice_Vano
						WHERE M.Vano2 IS NULL
							 AND 
							  V.Codice_Vano = NEW.Vano)
		THEN 
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Impossibile inserire! Il Vano non possiede Mura verso la parte esterna!';
		END IF;
	END IF;
    
	IF	
		(NEW.Categoria = 'Accelerometro X'
         OR
         NEW.Categoria = 'Accelerometro Y'
         OR
         NEW.Categoria = 'Accelerometro Z')
        AND
        NEW.UnitaMisura <> 'Km'
		AND
		NEW.UnitaMisura <> 'm'
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Unità di misura sbaglita. Km o m.';
	ELSEIF
		(NEW.Categoria = 'Giroscopio X'
         OR
         NEW.Categoria = 'Giroscopio Y'
         OR
         NEW.Categoria = 'Giroscopio Z')
        AND
        NEW.UnitaMisura <> '°/s'
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Unità di misura sbaglita. °/s.';
	ELSEIF
		(NEW.Categoria = 'Termostato Esterno Caldo'
         OR
         NEW.Categoria = 'Termostato Esterno Freddo'
         OR
         NEW.Categoria = 'Termostato Esterno Freddo'
         OR
         NEW.Categoria = 'Termostato Interno Freddo')
        AND
        NEW.UnitaMisura <> '°C'
        AND
		NEW.UnitaMisura <> '°K'
        AND
		NEW.UnitaMisura <> '°F'
        AND
		NEW.UnitaMisura <> '°Re'
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Unità di misura sbaglita. °C, °K, °F o °Re.';
	ELSEIF
		(NEW.Categoria = 'Igrometro Interno'
         OR
         NEW.Categoria = 'Igrometro Esterno')
        AND
        NEW.UnitaMisura <> 'kg/m³'
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Unità di misura sbaglita. kg/m³.';
	ELSEIF
		NEW.Categoria = 'Pluviometro'
        AND
        NEW.UnitaMisura <> 'mm'
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Unità di misura sbaglita. mm.';
    END IF;
END $$
DELIMITER ;

# Controlla l'aggiornamento dei Sensori
DROP TRIGGER IF EXISTS ControllaAggiornamentoSensore;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoSensore
BEFORE UPDATE ON Sensore
FOR EACH ROW
BEGIN
	IF
		NEW.Categoria <> 'Accelerometro X'
		AND
		NEW.Categoria <> 'Accelerometro Y'
		AND
		NEW.Categoria <> 'Accelerometro Z'
		AND
		NEW.Categoria <> 'Giroscopio X'
		AND
		NEW.Categoria <> 'Giroscopio Y'
		AND
		NEW.Categoria <> 'Giroscopio Z'
		AND
		NEW.Categoria <> 'Termostato Esterno Caldo'
		AND
		NEW.Categoria <> 'Termostato Esterno Freddo'
		AND
		NEW.Categoria <> 'Termostato Interno Caldo'
		AND
		NEW.Categoria <> 'Termostato Interno Freddo'
		AND
		NEW.Categoria <> 'Igrometro Esterno'
		AND
		NEW.Categoria <> 'Igrometro Interno'
		AND 
		NEW.Categoria <> 'Pluviometro'
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! La categoria non è quella valida!';
    END IF;    
    
	IF
		NEW.Vano <> OLD.Vano
	THEN
		IF
			NEW.Categoria = 'Accelerometro' OR NEW.Categoria = 'Accelerometro X' OR NEW.Categoria = 'Accelerometro Y' OR NEW.Categoria = 'Accelerometro Z'
			OR
			NEW.Categoria = 'Giroscopio' OR NEW.Categoria = 'Giroscopio X' OR NEW.Categoria = 'Giroscopio Y' OR NEW.Categoria = 'Giroscopio Z'
			OR
			NEW.Categoria = 'Termostato Esterno' OR NEW.Categoria = 'Termostato Esterno Caldo' OR NEW.Categoria = 'Termostato Esterno Freddo'
            OR
			NEW.Categoria = 'Igrometro Esterno'
			OR
			NEW.Categoria = 'Pluviometro'
		THEN
			IF
				NOT EXISTS (SELECT M.Codice_Muro
							FROM Muro M INNER JOIN Vano V ON M.Vano1 = V.Codice_Vano OR M.Vano2 = V.Codice_Vano
							WHERE M.Vano2 IS NULL
								 AND 
								  V.Codice_Vano = NEW.Vano)
			THEN 
				SIGNAL SQLSTATE '45000'
				SET MESSAGE_TEXT = 'Impossibile aggiornare! Il Vano non possiede Mura verso la parte esterna!';
			END IF;
		END IF;
	END IF;
    
		IF	
		(NEW.Categoria = 'Accelerometro X'
         OR
         NEW.Categoria = 'Accelerometro Y'
         OR
         NEW.Categoria = 'Accelerometro Z')
        AND
        NEW.UnitaMisura <> 'Km'
		AND
		NEW.UnitaMisura <> 'm'
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Unità di misura sbaglita. Km o m.';
	ELSEIF
		(NEW.Categoria = 'Giroscopio X'
         OR
         NEW.Categoria = 'Giroscopio Y'
         OR
         NEW.Categoria = 'Giroscopio Z')
        AND
        NEW.UnitaMisura <> '°/s'
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Unità di misura sbaglita. °/s.';
	ELSEIF
		(NEW.Categoria = 'Termostato Esterno Caldo'
         OR
         NEW.Categoria = 'Termostato Esterno Freddo'
         OR
         NEW.Categoria = 'Termostato Esterno Freddo'
         OR
         NEW.Categoria = 'Termostato Interno Freddo')
        AND
        NEW.UnitaMisura <> '°C'
        AND
		NEW.UnitaMisura <> '°K'
        AND
		NEW.UnitaMisura <> '°F'
        AND
		NEW.UnitaMisura <> '°Re'
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Unità di misura sbaglita. °C, °K, °F o °Re.';
	ELSEIF
		(NEW.Categoria = 'Igrometro Interno'
         OR
         NEW.Categoria = 'Igrometro Esterno')
        AND
        NEW.UnitaMisura <> 'kg/m³'
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Unità di misura sbaglita. kg/m³.';
	ELSEIF
		NEW.Categoria = 'Pluviometro'
        AND
        NEW.UnitaMisura <> 'mm'
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Unità di misura sbaglita. mm.';
    END IF;
END $$
DELIMITER ;

# Dopo una Registrazione anomala mi inserisce un Danno
DROP TRIGGER IF EXISTS RegistrazioneAnomala;
DELIMITER $$
CREATE TRIGGER RegistrazioneAnomala
AFTER INSERT ON Registrazione
FOR EACH ROW
BEGIN    
	DECLARE delta FLOAT DEFAULT 0;
	DECLARE allerta FLOAT DEFAULT 0;
    DECLARE coeff_tmp FLOAT DEFAULT 0;
    DECLARE tipo_sensore VARCHAR(50) DEFAULT '';
    DECLARE edificio INT DEFAULT 0;
    DECLARE stato FLOAT DEFAULT 0;
    DECLARE k FLOAT DEFAULT 0;
    DECLARE zona_colpita VARCHAR(100) DEFAULT '';
    DECLARE ora_registrazione TIME DEFAULT NULL;
    DECLARE data_registrazione DATE DEFAULT NULL;
    DECLARE area_registrazione INT DEFAULT 0;
    DECLARE nuovo_danno INT DEFAULT 0;
    
    SET allerta = 
	(
		SELECT S.Alert
		FROM Sensore S
		WHERE S.Codice_Seriale = NEW.ID_Sensore AND S.Categoria = NEW.TipoSensore
	);
    
	SET tipo_sensore =
		(
			SELECT S.Categoria
			FROM Sensore S
			WHERE S.Codice_Seriale = NEW.ID_sensore AND S.Categoria = NEW.TipoSensore
		);
    
    SET edificio = 
        (
			SELECT E.ID
            FROM Edificio E INNER JOIN Pianta P ON E.ID = P.Edificio
							INNER JOIN Vano V ON P.Codice_Pianta = V.Pianta
							INNER JOIN Sensore S ON V.Codice_Vano = S.Vano
            WHERE S.Codice_Seriale = NEW.ID_sensore AND S.Categoria = NEW.TipoSensore
        );
        
	SET stato = 
        (
			SELECT E.Stato
            FROM Edificio E
            WHERE E.ID = edificio
        );
    
	IF 
		NEW.ValoreRegistrato > allerta
        AND
        NEW.TipoSensore <> 'Termostato Interno Freddo'
        AND 
        NEW.TipoSensore <> 'Termostato Esterno Freddo'
    THEN        
        IF
			tipo_sensore = 'Accelerometro X' OR tipo_sensore = 'Accelerometro Y' OR tipo_sensore = 'Accelerometro Z'
            OR
            tipo_sensore = 'Giroscopio X' OR tipo_sensore = 'Giroscopio Y' OR tipo_sensore = 'Giroscopio Z'
        THEN
			SET k = 0.5;
			SET coeff_tmp =
				(
					SELECT IFNULL(AVG(P.CoefficienteRischio), 0)
					FROM AreaGeografica A INNER JOIN Edificio E ON A.ID_Area = E.Locazione
										  INNER JOIN Pianta P1 ON E.ID = P1.Edificio
                                          INNER JOIN Vano V ON P1.Codice_Pianta = V.Pianta
										  INNER JOIN Sensore S ON V.Codice_Vano = S.Vano
										  INNER JOIN PericoloGeologico P ON A.ID_Area = P.Area
					WHERE S.Codice_Seriale = NEW.ID_Sensore AND S.Categoria = NEW.TipoSensore
						 AND
                          (P.Pericolo = 'Terremoto'
						   OR
						   P.Pericolo = 'Ciclone'
						   OR
                           P.Pericolo = 'Frana'
						   OR
                           P.Pericolo = 'Tornado'
						   OR
                           P.Pericolo = 'Valanga')
				);
            SET zona_colpita = 'Struttura Portante';
            
        ELSEIF
			tipo_sensore = 'Termostato Interno Caldo' 
		THEN
			SET k = 1;
			SET coeff_tmp =
				(
					SELECT IFNULL(P.CoefficienteRischio, 0)
					FROM AreaGeografica A INNER JOIN Edificio E ON A.ID_Area = E.Locazione
										  INNER JOIN Pianta P1 ON E.ID = P1.Edificio
                                          INNER JOIN Vano V ON P1.Codice_Pianta = V.Pianta
										  INNER JOIN Sensore S ON V.Codice_Vano = S.Vano
										  INNER JOIN PericoloGeologico P ON A.ID_Area = P.Area
					WHERE S.Codice_Seriale = NEW.ID_Sensore AND S.Categoria = NEW.TipoSensore
						 AND
						  P.Pericolo = 'Incendio'
				);
			SET zona_colpita = 'Impianto di Raffreddamento';

        ELSEIF
            tipo_sensore = 'Termostato Esterno Caldo'
		THEN
			SET k = 1;
			SET coeff_tmp =
				(
					SELECT IFNULL(AVG(P.CoefficienteRischio), 0)
					FROM AreaGeografica A INNER JOIN Edificio E ON A.ID_Area = E.Locazione
										  INNER JOIN Pianta P1 ON E.ID = P1.Edificio
                                          INNER JOIN Vano V ON P1.Codice_Pianta = V.Pianta
										  INNER JOIN Sensore S ON V.Codice_Vano = S.Vano
										  INNER JOIN PericoloGeologico P ON A.ID_Area = P.Area
					WHERE S.Codice_Seriale = NEW.ID_Sensore AND S.Categoria = NEW.TipoSensore
						 AND
                          (P.Pericolo = 'Ondata di Caldo'
						   OR
						   P.Pericolo = 'Eruzione Vulcanica')
				);
			SET zona_colpita = 'Impianto di Raffreddamento';
            
		ELSEIF
			tipo_sensore = 'Pluviometro'
        THEN
			SET k = 0.75;
			SET coeff_tmp =
				(
					SELECT IFNULL(AVG(P.CoefficienteRischio), 0)
					FROM AreaGeografica A INNER JOIN Edificio E ON A.ID_Area = E.Locazione
										  INNER JOIN Pianta P1 ON E.ID = P1.Edificio
                                          INNER JOIN Vano V ON P1.Codice_Pianta = V.Pianta
										  INNER JOIN Sensore S ON V.Codice_Vano = S.Vano
										  INNER JOIN PericoloGeologico P ON A.ID_Area = P.Area
					WHERE S.Codice_Seriale = NEW.ID_Sensore AND S.Categoria = NEW.TipoSensore
                          (P.Pericolo = 'Alluvione'
						   OR
						   P.Pericolo = 'Inondazione')
				);
            SET zona_colpita = 'Impianto Elettrico';    
			
		ELSEIF
			tipo_sensore = 'Igrometro Interno'
        THEN
			SET k = 0.5;
			SET coeff_tmp =
				(
					SELECT IFNULL(P.CoefficienteRischio, 0)
					FROM AreaGeografica A INNER JOIN Edificio E ON A.ID_Area = E.Locazione
										  INNER JOIN Pianta P1 ON E.ID = P1.Edificio
                                          INNER JOIN Vano V ON P1.Codice_Pianta = V.Pianta
										  INNER JOIN Sensore S ON V.Codice_Vano = S.Vano
										  INNER JOIN PericoloGeologico P ON A.ID_Area = P.Area
					WHERE S.Codice_Seriale = NEW.ID_Sensore AND S.Categoria = NEW.TipoSensore
						 AND
                          P.Pericolo = 'Innalzamento Umidità Interna'
				);
			SET zona_colpita = 'Sistema di Deumidificazione';
		
		ELSEIF
            tipo_sensore = 'Igrometro Esterno'
        THEN
			SET k = 0.5;
			SET coeff_tmp =
				(
					SELECT IFNULL(P.CoefficienteRischio, 0)
					FROM AreaGeografica A INNER JOIN Edificio E ON A.ID_Area = E.Locazione
										  INNER JOIN Pianta P1 ON E.ID = P1.Edificio
                                          INNER JOIN Vano V ON P1.Codice_Pianta = V.Pianta
										  INNER JOIN Sensore S ON V.Codice_Vano = S.Vano
										  INNER JOIN PericoloGeologico P ON A.ID_Area = P.Area
					WHERE S.Codice_Seriale = NEW.ID_Sensore AND S.Categoria = NEW.TipoSensore
						 AND
                          P.Pericolo = 'Innalzamento Umidità Esterna'
				);
			SET zona_colpita = 'Sistema di Deumidificazione';
        END IF;
        
	ELSEIF
		NEW.ValoreRegistrato < allerta
        AND
        (NEW.TipoSensore = 'Termostato Interno Freddo'
         OR 
         NEW.TipoSensore = 'Termostato Esterno Freddo')
    THEN
		IF
            tipo_sensore = 'Termostato Esterno Freddo'
		THEN
			SET k = 1;
			SET coeff_tmp =
				(
					SELECT IFNULL(P.CoefficienteRischio, 0)
					FROM AreaGeografica A INNER JOIN Edificio E ON A.ID_Area = E.Locazione
										  INNER JOIN Pianta P1 ON E.ID = P1.Edificio
                                          INNER JOIN Vano V ON P1.Codice_Pianta = V.Pianta
										  INNER JOIN Sensore S ON V.Codice_Vano = S.Vano
										  INNER JOIN PericoloGeologico P ON A.ID_Area = P.Area
					WHERE S.Codice_Seriale = NEW.ID_Sensore AND S.Categoria = NEW.TipoSensore
						 AND
                          P.Pericolo = 'Ondata di Freddo'
				);
			SET zona_colpita = 'Impianto di Riscaldamento';
            
		ELSEIF
			tipo_sensore = 'Termostato Interno Freddo' 
		THEN
			SET k = 1;
			SET coeff_tmp =
				(
					SELECT IFNULL(P.CoefficienteRischio, 0)
					FROM AreaGeografica A INNER JOIN Edificio E ON A.ID_Area = E.Locazione
										  INNER JOIN Pianta P1 ON E.ID = P1.Edificio
                                          INNER JOIN Vano V ON P1.Codice_Pianta = V.Pianta
										  INNER JOIN Sensore S ON V.Codice_Vano = S.Vano
										  INNER JOIN PericoloGeologico P ON A.ID_Area = P.Area
					WHERE S.Codice_Seriale = NEW.ID_Sensore AND S.Categoria = NEW.TipoSensore
						 AND
						   P.Pericolo = 'Gelo'
				);
			SET zona_colpita = 'Impianto di Riscaldamento';
		END IF;
	END IF;
            
	IF
		stato + k * coeff_tmp < 4
        AND
		NOT EXISTS
                (
					SELECT *
                    FROM Danno D
                    WHERE D.Edificio = edificio AND D.Zona = zona_colpita
				)
		AND
		(zona_colpita <> '' AND zona_colpita IS NOT NULL)
	THEN
		INSERT INTO Danno(Entita, Zona, Edificio)
		VALUES (k*coeff_tmp, zona_colpita, edificio);
                
		SET nuovo_danno = 1;
	
    ELSEIF
		stato + k * coeff_tmp < 4
        AND
		EXISTS
			(
				SELECT *
                FROM Danno D
                WHERE D.Edificio = edificio AND D.Zona = zona_colpita
			)
		AND
		(zona_colpita <> '' AND zona_colpita IS NOT NULL)
    THEN
		UPDATE Danno D 
        SET D.Entita = D.Entita + k * coeff_tmp
        WHERE D.Zona = zona_colpita AND D.Edificio = edificio;
                
		SET nuovo_danno = 1;
			
	ELSEIF
		stato + k * coeff_tmp >= 4
		AND
		NOT EXISTS
                (
					SELECT *
                    FROM Danno D
                    WHERE D.Edificio = edificio AND D.Zona = zona_colpita
				)
		AND
		(zona_colpita <> '' AND zona_colpita IS NOT NULL)
	THEN
		INSERT INTO Danno(Entita, Zona, Edificio)
		VALUES(3, zona_colpita, edificio);
               
		SET nuovo_danno = 1;
        
	ELSEIF
		stato + k * coeff_tmp >= 4
		AND
		EXISTS
              (
				SELECT *
                FROM Danno D
				WHERE D.Edificio = edificio AND D.Zona = zona_colpita
			  )
		AND
		(zona_colpita <> '' AND zona_colpita IS NOT NULL)
    THEN
		UPDATE Danno D 
        SET D.Entita = 3
        WHERE D.Zona = zona_colpita AND D.Edificio = edificio;
                
        SET nuovo_danno = 1;
	END IF;
    
	SET area_registrazione =
    (
		SELECT E.Locazione
        FROM Edificio E INNER JOIN Pianta P ON E.ID = P.Edificio INNER JOIN Vano V ON P.Codice_pianta = V.Pianta INNER JOIN Sensore S ON V.Codice_vano = S.Vano 
        WHERE S.Codice_Seriale = NEW.ID_Sensore AND S.Categoria = NEW.TipoSensore
    );
    
    SET ora_registrazione =
    (
		SELECT R.Orario
        FROM Registrazione R
        WHERE R.ID_sensore = NEW.ID_sensore AND R.TipoSensore = NEW.TipoSensore AND R.Data = NEW.Data
    );
    
    SET data_registrazione =
    (
		SELECT R.Data
        FROM Registrazione R
        WHERE R.ID_sensore = NEW.ID_sensore AND R.TipoSensore = NEW.TipoSensore AND R.Data = NEW.Data
    );
        
	IF 
		nuovo_danno <> 0
        AND
		(zona_colpita <> '' AND zona_colpita IS NOT NULL)
	THEN
		SET nuovo_danno = (SELECT MAX(Codice_Danno) 
						   FROM Danno);
        IF 
			EXISTS
                (
					SELECT *
                    FROM Calamita C
                    WHERE C.Data = data_registrazione AND C.Orario BETWEEN SUBTIME(ora_registrazione, '00:00:03') AND ADDTIME(ora_registrazione, '00:00:03') AND C.Area = area_registrazione 
                )
		THEN 
			SET ora_registrazione = # NB le calamità non possono ravvicinate per un tempo < 10 minuti
			(
				SELECT C.Orario
				FROM Calamita C
				WHERE C.Data = data_registrazione AND C.Orario BETWEEN SUBTIME(ora_registrazione, '00:00:03') AND ADDTIME(ora_registrazione, '00:00:03') AND C.Area = area_registrazione 
			);
				
			INSERT INTO CausaDanneggiamento(Danno, Area, Data, Orario)
			VALUES (nuovo_danno, area_registrazione, data_registrazione, ora_registrazione);
		END IF;
	END IF;
END $$
DELIMITER ;

# Controlla che i Valori Registrati inseriti siano consoni al Sensore
DROP TRIGGER IF EXISTS ControllaInserimentoRegistrazione;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoRegistrazione
BEFORE INSERT ON Registrazione
FOR EACH ROW
BEGIN
	IF
		(NEW.TipoSensore = 'Pluviometro'
         OR
         NEW.TipoSensore = 'Igrometro Esterno'
         OR
         NEW.TipoSensore = 'Igrometro Interno')
        AND
        NEW.ValoreRegistrato < 0
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Il Valore Registrato non può essere negativo in questo caso!';
    END IF;
END $$
DELIMITER ;

# Controlla che i Valori Registrati aggiornati siano consoni al Sensore
DROP TRIGGER IF EXISTS ControllaAggiornamentoRegistrazione;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoRegistrazione
BEFORE UPDATE ON Registrazione
FOR EACH ROW
BEGIN
	IF
		(NEW.TipoSensore = 'Pluviometro'
         OR
         NEW.TipoSensore = 'Igrometro Esterno'
         OR
         NEW.TipoSensore = 'Igrometro Interno')
        AND
        NEW.ValoreRegistrato < 0
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! Il Valore Registrato non può essere negativo in questo caso!';
    END IF;
END $$
DELIMITER ;

# Calcolo la variazione dello Stato di un Edificio quando il valore di Registrazione supera l'Alert del Sensore
DROP TRIGGER IF EXISTS CalcoloDeltaStatoInserimento;
DELIMITER $$
CREATE TRIGGER CalcoloDeltaStatoInserimento
AFTER INSERT ON Danno
FOR EACH ROW
BEGIN
	DECLARE stato FLOAT DEFAULT 0;
    
    SET stato = 
        (
			SELECT E.Stato
			FROM Edificio E
			WHERE E.ID = NEW.Edificio
        );
    
	IF
		stato + NEW.Entita < 4
	THEN
		UPDATE Edificio
		SET Stato = Stato + NEW.Entita
		WHERE ID = NEW.Edificio;
	ELSE
		UPDATE Edificio
		SET Stato = 4
		WHERE ID = NEW.Edificio;
    END IF;
END $$
DELIMITER ;

# Calcolo la variazione dello Stato di un Edificio quando il valore aggiornato di Registrazione supera l'Alert del Sensore
DROP TRIGGER IF EXISTS CalcoloDeltaStatoAggiornamento;
DELIMITER $$
CREATE TRIGGER CalcoloDeltaStatoAggiornamento
AFTER UPDATE ON Danno
FOR EACH ROW
BEGIN
	DECLARE stato FLOAT DEFAULT 0;
    
    SET stato = 
        (
			SELECT E.Stato
			FROM Edificio E
			WHERE E.ID = NEW.Edificio
        );
        
	IF 
		NEW.Entita > OLD.Entita
        AND
        NEW.Riparato = FALSE
	THEN
		IF
			stato + (NEW.Entita - OLD.Entita) < 4
		THEN
			UPDATE Edificio
			SET Stato = Stato + (NEW.Entita - OLD.Entita)
			WHERE ID = NEW.Edificio;
		ELSE
			UPDATE Edificio
			SET Stato = 4
			WHERE ID = NEW.Edificio;
		END IF;
	ELSEIF
		NEW.Entita < OLD.Entita
        AND
        NEW.Riparato = FALSE
	THEN
		UPDATE Edificio
		SET Stato = Stato - (OLD.Entita - NEW.Entita)
		WHERE ID = NEW.Edificio;
    END IF;
END $$
DELIMITER ;

# Controlla che un Danno riparato sia presente in Ristrutturazione
DROP TRIGGER IF EXISTS ControllaAggiornamentoDanno;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoDanno
BEFORE UPDATE ON Danno
FOR EACH ROW
BEGIN        
	IF
		NEW.Riparato = TRUE
        AND
        NEW.Codice_Danno NOT IN (
									SELECT R.Danno
									FROM Ristrutturazione R
								)
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! Il Danno non è stato riparato.';
    END IF;
END $$
DELIMITER ;

# Controlla che la Crepa non presenti irregolarità e che si aggiorni lo Stato dell'Edificio
DROP TRIGGER IF EXISTS ControllaInserimentoCrepa;
DELIMITER $$
CREATE TRIGGER ControllaInserimentoCrepa
BEFORE INSERT ON Crepa
FOR EACH ROW
BEGIN        
	DECLARE delta_stato FLOAT DEFAULT 0;
    
	IF
		NEW.UltimaLunghezzaRegistrata < 0
        OR
        NEW.UltimaAngolazioneRegistrata < 0
        OR
        NEW.AlertLunghezza < 0
        OR
        NEW.AlertAngolo < 0
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Valore minore di 0!';
    END IF;
    
    IF
		NEW.UnitaMisura <> 'mm'
        AND
        NEW.UnitaMisura <> 'cm'
        AND
        NEW.UnitaMisura <> 'dm'
        AND
        NEW.UnitaMisura <> 'm'
        AND
        NEW.UnitaMisura <> 'in'
	THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile inserire! Unità di Misura non consistente!';
    END IF;
    
    IF
		NEW.Entita = 0
        OR
        NEW.Entita IS NULL
	THEN
		IF
			NEW.UltimaLunghezzaRegistrata >= NEW.AlertLunghezza
		THEN
			SET delta_stato = delta_stato + 0.5;
		ELSEIF
			NEW.UltimaLunghezzaRegistrata < NEW.AlertLunghezza
		THEN
			SET delta_stato = delta_stato + 0.05;		
		END IF;
		
		IF
			NEW.UltimaAngolazioneRegistrata >= NEW.AlertAngolo
		THEN
			SET delta_stato = delta_stato + 0.5;
		ELSEIF
			NEW.UltimaAngolazioneRegistrata < NEW.AlertAngolo
		THEN
			SET delta_stato = delta_stato + 0.05;
		END IF;
    END IF;
    
    IF
		delta_stato <= 3
        AND
        delta_stato >= 0.01
	THEN
		SET NEW.Entita = delta_stato;
	END IF;
END $$
DELIMITER ;

# Controlla che non venga inserito un Sensore che non sia di Posizione in Aggiornamento
DROP TRIGGER IF EXISTS ControllaAggiornamentoCrepa;
DELIMITER $$
CREATE TRIGGER ControllaAggiornamentoCrepa
BEFORE UPDATE ON Crepa
FOR EACH ROW
BEGIN
	DECLARE delta_stato FLOAT DEFAULT 0;
	
	IF
		(OLD.Riparato = TRUE
         AND
         NEW.Riparato = FALSE)
        OR
        (OLD.Riparato = TRUE
         AND
         NEW.Riparato = TRUE)
    THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Impossibile aggiornare! Ormai la crepa è riparata!';
        
	ELSEIF
		OLD.Riparato = FALSE
        AND
        NEW.Riparato = FALSE
    THEN
        IF
			NEW.UltimaLunghezzaRegistrata < 0
			OR
			NEW.UltimaAngolazioneRegistrata < 0
			OR
			NEW.AlertLunghezza < 0
			OR
			NEW.AlertAngolo < 0
		THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Impossibile aggiornare! Valore minore di 0!';
		END IF;
		
        IF
			NEW.UnitaMisura <> 'mm'
			AND
			NEW.UnitaMisura <> 'cm'
			AND
			NEW.UnitaMisura <> 'dm'
			AND
			NEW.UnitaMisura <> 'm'
			AND
			NEW.UnitaMisura <> 'in'
		THEN
			SIGNAL SQLSTATE '45000'
			SET MESSAGE_TEXT = 'Impossibile aggiornare! Unità di Misura non consistente!';
		END IF;
		
        IF
			OLD.Entita = NEW.Entita
        THEN
			IF
				NEW.UltimaLunghezzaRegistrata >= NEW.AlertLunghezza
				AND
				NEW.UltimaLunghezzaRegistrata > OLD.UltimaLunghezzaRegistrata
				AND
				NEW.Riparato = FALSE
			THEN
				SET delta_stato = delta_stato + 0.5;
			ELSEIF
				NEW.UltimaLunghezzaRegistrata < NEW.AlertLunghezza
				AND
				NEW.UltimaLunghezzaRegistrata > OLD.UltimaLunghezzaRegistrata
				AND
				NEW.Riparato = FALSE
			THEN
				SET delta_stato = delta_stato + 0.01;		
			END IF;
					
			IF
				NEW.UltimaAngolazioneRegistrata >= NEW.AlertAngolo
				AND
				NEW.UltimaAngolazioneRegistrata > OLD.UltimaAngolazioneRegistrata
				AND
				NEW.Riparato = FALSE
			THEN
				SET delta_stato = delta_stato + 0.5;
			ELSEIF
				NEW.UltimaAngolazioneRegistrata < NEW.AlertAngolo
				AND
				NEW.UltimaAngolazioneRegistrata > OLD.UltimaAngolazioneRegistrata
				AND
				NEW.Riparato = FALSE
			THEN
				SET delta_stato = delta_stato + 0.01;
			END IF;
        END IF;
        
		IF
			NEW.Entita + delta_stato <= 3
            AND
            NEW.Entita + delta_stato >= 0.01
        THEN
			SET NEW.Entita = NEW.Entita + delta_stato;
		ELSE
			SET NEW.Entita = 3;
        END IF;
	END IF;
END $$
DELIMITER ;

# Se viene inserita una Crepa, si aggiorna lo Stato dell'Edificio
DROP TRIGGER IF EXISTS AggiornaStatoEdificioDopoInserimento;
DELIMITER $$
CREATE TRIGGER AggiornaStatoEdificioDopoInserimento
AFTER INSERT ON Crepa
FOR EACH ROW
BEGIN
	DECLARE stato FLOAT DEFAULT 0;
    DECLARE edificio INT DEFAULT 0;
    
	SET stato = 
        (
			SELECT E.Stato
			FROM Muro M INNER JOIN Vano V ON M.Vano1 = V.Codice_Vano
						INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
                        INNER JOIN Edificio E ON P.Edificio = E.ID
			WHERE M.Codice_Muro = NEW.Muro
        );
        
	SET edificio = 
        (
			SELECT P.Edificio
			FROM Muro M INNER JOIN Vano V ON M.Vano1 = V.Codice_Vano
						INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
			WHERE M.Codice_Muro = NEW.Muro
        );

    IF
		stato + NEW.Entita < 4
        AND
        NEW.Entita > 0
        AND
        NEW.Riparato = FALSE
	THEN
		UPDATE Edificio
		SET Stato = Stato + NEW.Entita
		WHERE ID = edificio;
	ELSEIF
		stato + NEW.Entita >= 4
        AND
        NEW.Entita > 0
        AND
        NEW.Riparato = FALSE
    THEN
		UPDATE Edificio
		SET Stato = 4
		WHERE ID = edificio;
    END IF;
END $$
DELIMITER ;

# Se viene aggiornata una Crepa, eventualmente si aggiorna lo Stato dell'Edificio
DROP TRIGGER IF EXISTS AggiornaStatoEdificioDopoAggiornamento;
DELIMITER $$
CREATE TRIGGER AggiornaStatoEdificioDopoAggiornamento
AFTER UPDATE ON Crepa
FOR EACH ROW
BEGIN
	DECLARE stato FLOAT DEFAULT 0;
    DECLARE edificio INT DEFAULT 0;
    
	SET stato = 
        (
			SELECT E.Stato
			FROM Muro M INNER JOIN Vano V ON M.Vano1 = V.Codice_Vano
						INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
                        INNER JOIN Edificio E ON P.Edificio = E.ID
			WHERE M.Codice_Muro = NEW.Muro
        );
        
	SET edificio = 
        (
			SELECT P.Edificio
			FROM Muro M INNER JOIN Vano V ON M.Vano1 = V.Codice_Vano
						INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
			WHERE M.Codice_Muro = NEW.Muro
        );
        
	IF
		OLD.Riparato = FALSE
        AND
        NEW.Riparato = FALSE
    THEN
        IF
			NEW.Entita > OLD.Entita
        THEN
			IF
				stato + (NEW.Entita - OLD.Entita) < 4
				AND
				(NEW.Entita - OLD.Entita) > 0
			THEN
				UPDATE Edificio
				SET Stato = Stato + (NEW.Entita - OLD.Entita)
				WHERE ID = edificio;
			ELSEIF
				stato + (NEW.Entita - OLD.Entita) >= 4
				AND
				(NEW.Entita - OLD.Entita) > 0
            THEN
				UPDATE Edificio
				SET Stato = 4
				WHERE ID = edificio;
			END IF;
        END IF;
	
    ELSEIF
		OLD.Riparato = FALSE
        AND
        NEW.Riparato = TRUE
    THEN
        IF
            stato - OLD.Entita > 1
		THEN
			UPDATE Edificio
			SET Stato = Stato - OLD.Entita
			WHERE ID = edificio;
		ELSEIF
            stato - OLD.Entita <= 1
        THEN
			UPDATE Edificio
			SET Stato = 1
			WHERE ID = edificio;
		END IF;
    END IF;
END $$
DELIMITER ;

# Aggiornamento giornaliero per lavori in cui viene inserita direttamente la data d'inizio e la data di fine, ma non il costo
DROP EVENT IF EXISTS Aggiornamento_Costo_Lavori;
CREATE EVENT Aggiornamento_Costo_Lavori
ON SCHEDULE EVERY 1 DAY
STARTS '2017-12-31 23:50:00'
DO
	CALL Procedura_Aggiornamento_Costo_Lavori();	


# OPERAZIONI

# Operazione che restituisce il Lotto più conveniente (non ancora comprato) dato una determinata Tipologia di Materiale e un Materiale
DROP PROCEDURE IF EXISTS Lotto_Conveniente;
DELIMITER $$
CREATE PROCEDURE Lotto_Conveniente(_tipologia VARCHAR(50), _materiale VARCHAR(50))
BEGIN
	CASE
    WHEN _tipologia = 'Altri Materiali' OR _tipologia = 'AltriMateriali' THEN
		SELECT AM.Codice_Lotto, AM.Costo AS Costo_in_kg
		FROM AltriMateriali AM
		WHERE AM.Nome = _materiale
			 AND
			  AM.QuantitaStoccata <> 0
			 AND
              AM.Costo IN (SELECT MIN(AM1.Costo)
						   FROM AltriMateriali AM1
						   WHERE AM.Nome = AM1.Nome
							    AND
								 AM1.QuantitaStoccata <> 0);
                                       
	WHEN _tipologia = 'Intonaco' OR _tiplogia = 'Intonaci' THEN
		SELECT I.Codice_Lotto, I.Costo AS Costo_in_kg
		FROM Intonaco I
		WHERE I.Nome = _materiale 
			 AND
			  I.QuantitaStoccata <> 0
			 AND
              I.Costo IN (SELECT MIN(I1.Costo)
						  FROM Intonaco I1
						  WHERE I.Nome = I1.Nome
							   AND
								I1.QuantitaStoccata <> 0);
                                       
	WHEN _tipologia = 'Mattoni' OR _tipologia = 'Mattone' THEN
		SELECT M.Codice_Lotto, M.Costo AS Costo_in_kg
		FROM Mattoni M
		WHERE M.Nome = _materiale 
			AND
			 M.QuantitaStoccata <> 0
			AND
             M.Costo IN (SELECT MIN(M1.Costo)
						 FROM Mattoni M1
						 WHERE M.Nome = M1.Nome
						      AND
                               M1.QuantitaStoccata <> 0);
	
	WHEN _tipologia = 'Piastrelle' OR _tipologia = 'Piastrella' THEN
		SELECT P.Codice_Lotto, P.Costo AS Costo_in_kg
		FROM Piastrelle P
		WHERE P.Nome = _materiale 
			 AND
			  P.QuantitaStoccata <> 0
			 AND
              P.Costo IN (SELECT MIN(P1.Costo)
						  FROM Piastrelle P1
						  WHERE P.Nome = P1.Nome
						       AND
                                P1.QuantitaStoccata <> 0);
       
	WHEN _tipologia = 'Pietre' OR _tipologia = 'Pietra' THEN
		SELECT P.Codice_Lotto, P.Costo AS Costo_in_kg
		FROM Pietre P
		WHERE P.Nome = _materiale 
			 AND
			  P.QuantitaStoccata <> 0
			 AND
              P.Costo IN (SELECT MIN(P1.Costo)
						  FROM Pietre P1
						  WHERE P.Nome = P1.Nome
						       AND
                                P1.QuantitaStoccata <> 0);
                                
	WHEN _tipologia = '' OR _tipologia = ' ' OR _tipologia IS NULL THEN
		(SELECT AM.Codice_Lotto, AM.Costo AS Costo_in_kg
		 FROM AltriMateriali AM
		 WHERE AM.Nome = _materiale
			 AND
			  AM.QuantitaStoccata <> 0
			 AND
              AM.Costo IN (SELECT MIN(AM1.Costo)
						   FROM AltriMateriali AM1
						   WHERE AM.Nome = AM1.Nome
							    AND
								 AM1.QuantitaStoccata <> 0))
		UNION
		(SELECT I.Codice_Lotto, I.Costo AS Costo_in_kg
		 FROM Intonaco I
		 WHERE I.Nome = _materiale 
			  AND
			   I.QuantitaStoccata <> 0
			  AND
               I.Costo IN (SELECT MIN(I1.Costo)
						   FROM Intonaco I1
						   WHERE I.Nome = I1.Nome
							    AND
								 I1.QuantitaStoccata <> 0))
		UNION
		(SELECT M.Codice_Lotto, M.Costo AS Costo_in_kg
		 FROM Mattoni M
		 WHERE M.Nome = _materiale 
			 AND
			  M.QuantitaStoccata <> 0
			 AND
              M.Costo IN (SELECT MIN(M1.Costo)
						  FROM Mattoni M1
						  WHERE M.Nome = M1.Nome
						       AND
                                M1.QuantitaStoccata <> 0))
		UNION
		(SELECT P.Codice_Lotto, P.Costo AS Costo_in_kg
		 FROM Piastrelle P
		 WHERE P.Nome = _materiale 
			  AND
			   P.QuantitaStoccata <> 0
			  AND
               P.Costo IN (SELECT MIN(P1.Costo)
					 	   FROM Piastrelle P1
						   WHERE P.Nome = P1.Nome
						        AND
                                 P1.QuantitaStoccata <> 0))
		UNION
		(SELECT P.Codice_Lotto, P.Costo AS Costo_in_kg
		 FROM Piastrelle P
		 WHERE P.Nome = _materiale 
			  AND
			   P.QuantitaStoccata <> 0
			  AND
               P.Costo IN (SELECT MIN(P1.Costo)
						   FROM Piastrelle P1
						   WHERE P.Nome = P1.Nome
						        AND
                                 P1.QuantitaStoccata <> 0));	
                                   
	WHEN _tipologia <> 'Altri Materiali' AND _tipologia <> 'AltriMateriali' AND _tipologia <> 'Intonaco' AND _tipologia <> 'Intonaci' AND _tipologia <> 'Mattoni' AND _tipologia <> 'Mattone' AND _tipologia <> 'Piastrelle' AND _tipologia <> 'Piastrella' AND _tipologia <> 'Pietre' AND _tipologia <> 'Pietra' AND _tipologia <> '' AND _tipologia <> ' ' AND _tipologia IS NOT NULL THEN
		SELECT NULL;
    END CASE;
END $$;
DELIMITER ;

# Operazione che restituisce i lavori attualmente in corso e ordinati per data di inizio dei lavori
DROP PROCEDURE IF EXISTS Ordine_Lavori;
DELIMITER $$
CREATE PROCEDURE Ordine_Lavori()
BEGIN
	SELECT L.Codice_Lavoro, L.TipologiaDiLavoro, RANK() OVER(ORDER BY DataInizio) AS Posizione
	FROM Lavoro L
	WHERE L.DataFine IS NULL;
END $$;
DELIMITER ;

# Operazione che resitutisce i lavoratori meno occupati
DROP PROCEDURE IF EXISTS Lavoratori_Meno_Occupati;
DELIMITER $$
CREATE PROCEDURE Lavoratori_Meno_Occupati()
BEGIN
	CREATE TEMPORARY TABLE IF NOT EXISTS _Classifica 
	(
		Lavoratore VARCHAR(50) NOT NULL,
        Nome VARCHAR(50),
        Cognome VARCHAR(50),
		Tot_Lavori INT NOT NULL,
		PRIMARY KEY(Lavoratore)
	);

	TRUNCATE TABLE _Classifica;

	INSERT INTO _Classifica(Lavoratore, Nome, Cognome, Tot_Lavori)
		SELECT T1.CodiceFiscale, L_1.Nome, L_1.Cognome, IFNULL(COUNT(DISTINCT T1.Lavoro), 0) AS Tot_Lavori
		FROM Turni_Di_Lavoro_Lavoratore T1 INNER JOIN Lavoro L1 ON L1.Codice_Lavoro = T1.Lavoro
										   INNER JOIN Lavoratore L_1 ON T1.CodiceFiscale = L_1.CodiceFiscale 
		WHERE L1.DataFine IS NULL
		GROUP BY T1.CodiceFiscale
        UNION
        SELECT DISTINCT T2.CodiceFiscale, L_2.Nome, L_2.Cognome, 0 AS Tot_Lavori
		FROM Turni_Di_Lavoro_Lavoratore T2 INNER JOIN Lavoro L2 ON L2.Codice_Lavoro = T2.Lavoro
										  INNER JOIN Lavoratore L_2 ON T2.CodiceFiscale = L_2.CodiceFiscale 
		WHERE L2.DataFine IS NOT NULL
			 AND 
              T2.CodiceFiscale NOT IN (
										SELECT DISTINCT T.CodiceFiscale
										FROM Turni_Di_Lavoro_Lavoratore T INNER JOIN Lavoro L ON L.Codice_Lavoro = T.Lavoro
										WHERE L.DataFine IS NULL
									 );
		
	SELECT *, RANK() OVER(ORDER BY C.Tot_Lavori) AS Posizione
	FROM _Classifica C;
END $$
DELIMITER ;

/*
# Operazione che resitutisce i lavoratori meno occupati. L'output è attendibile se i dati inseriti sono corretti e i vani sono inseriti interamente
DROP FUNCTION IF EXISTS Calcolo_Area_Vano;
DELIMITER $$
CREATE FUNCTION Calcolo_Area_Vano(cod_vano INT)
RETURNS FLOAT DETERMINISTIC 
BEGIN
    DECLARE finito INT DEFAULT 0;
    DECLARE diagonale_principale, diagonale_secondaria FLOAT DEFAULT 0;
    DECLARE primo_x, primo_y, x1, y1, x2, y2 FLOAT DEFAULT NULL;
    
    DECLARE cursore_vertici CURSOR FOR
		SELECT DISTINCT M.X1 AS X, M.Y1 AS Y
		FROM Muro M
		WHERE M.Vano1 = cod_vano OR (M.Vano2 IS NOT NULL AND M.Vano2 = cod_vano)
		UNION
		SELECT DISTINCT M.X2 AS X, M.Y2 AS Y
		FROM Muro M
		WHERE M.Vano1 = cod_vano OR (M.Vano2 IS NOT NULL AND M.Vano2 = cod_vano);
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
        
	OPEN cursore_vertici;
    ciclo: LOOP
		FETCH cursore_vertici INTO x2, y2;
        IF
			finito = 1
        THEN
			SET diagonale_principale = diagonale_principale + primo_x * y2;
            SET diagonale_secondaria = diagonale_secondaria + primo_y * x2;
			LEAVE ciclo;
        END IF;
        
        IF
			x1 IS NULL
            AND
            y1 IS NULL
        THEN
			SET primo_x = x2;
            SET primo_y = y2;
            SET x1 = x2;
            SET y1 = y2;
		ELSE
			SET diagonale_principale = diagonale_principale + y1 * x2;
            SET diagonale_secondaria = diagonale_secondaria + x1 * y2;
            SET x1 = x2;
            SET y1 = y2;
        END IF;
    END LOOP;
	CLOSE cursore_vertici;

    RETURN ABS( diagonale_principale - diagonale_secondaria ) / 2;
END $$
DELIMITER ;
*/

# Mostra le Caratteristiche di un Vano
DROP PROCEDURE IF EXISTS Caratteristiche_Vano;
DELIMITER $$
CREATE PROCEDURE Caratteristiche_Vano(cod_vano INT)
BEGIN
    SELECT DISTINCT V.Codice_Vano, V.Funzione, V.LunghezzaMax, V.LarghezzaMax, V.AltezzaMax, COUNT(M.Codice_Muro) AS Muri#, Calcolo_Area_Vano(cod_vano)
	FROM Vano V INNER JOIN Muro M ON V.Codice_Vano = M.Vano1 OR V.Codice_Vano = M.Vano2
	WHERE V.Codice_Vano = cod_vano
    GROUP BY V.Codice_Vano;
END $$
DELIMITER ;
 
# Calcolo dell'orientazione di un'apertura che da sull'esterno. 
# È possibile effettuare con certezza il calcolo se e solo se il vano presenta muri che formano una spezzata chiusa. 
DROP PROCEDURE IF EXISTS Ambiguita_Punto_Cardinale;
DELIMITER $$
CREATE PROCEDURE Ambiguita_Punto_Cardinale(IN cod_apertura INT, INOUT risultato VARCHAR(10))
BEGIN
	DECLARE coefficiente_angolare FLOAT DEFAULT 0;
    DECLARE caso_verticale BOOL DEFAULT FALSE;
    DECLARE ap_x1, ap_y1, ap_x2, ap_y2 FLOAT DEFAULT 0;
    DECLARE direzione_problema VARCHAR(10) DEFAULT NULL;
    
    SET ap_x1 =
    (
		SELECT X1
        FROM Apertura
        WHERE Codice_apertura = cod_apertura
	);
    
    SET ap_x2 =
    (
		SELECT X2
        FROM Apertura
        WHERE Codice_apertura = cod_apertura
	);
    
    SET ap_y1 =
    (
		SELECT Y1
        FROM Apertura
        WHERE Codice_apertura = cod_apertura
	);
    
    SET ap_y2 =
    (
		SELECT Y2
        FROM Apertura
        WHERE Codice_apertura = cod_apertura
	);
    
    IF
		((
			SELECT A.Tipologia
			FROM Apertura A
			WHERE A.Codice_Apertura = cod_apertura
         )
         = 
         'Finestra'
         OR
         (
			SELECT A.Tipologia
			FROM Apertura A
			WHERE A.Codice_Apertura = cod_apertura
         )
         =
         'Porta-Finestra'
         OR
         (
			SELECT A.Tipologia
			FROM Apertura A
			WHERE A.Codice_Apertura = cod_apertura
         )
         = 'Porta Esterna')
    THEN
		IF 
			ap_x1 <> ap_x2
		THEN
			SET coefficiente_angolare = (ap_y2 - ap_y1) / (ap_x2 - ap_x1);
		ELSE
			SET caso_verticale = TRUE;
		END IF;
		
		IF 
			coefficiente_angolare > (-0.414213) AND coefficiente_angolare <= 0.414213 AND caso_verticale = FALSE 
		THEN
			SET direzione_problema = 'n-s';
		ELSEIF
			coefficiente_angolare > 0.414213 AND coefficiente_angolare <= 2.414213 AND caso_verticale = FALSE
		THEN
			SET direzione_problema = 'n-o/s-e';
		ELSEIF
			coefficiente_angolare > 2.414213 OR caso_verticale = TRUE
		THEN
			SET direzione_problema = 'e-o';
		ELSEIF
			coefficiente_angolare > (-2.414213) AND coefficiente_angolare <= (-0.414212) AND caso_verticale = FALSE
		THEN
			SET direzione_problema = 'n-e/s-o';
		END IF;
    END IF;
    
    SET risultato = direzione_problema;
END $$
DELIMITER ;

# Calcola il Punto Cardinale
DROP PROCEDURE IF EXISTS Punto_Cardinale_Caso_Definito;
DELIMITER $$
CREATE PROCEDURE Punto_Cardinale_Caso_Definito(IN cod_apertura INT, INOUT risultato VARCHAR(10))
BEGIN
	DECLARE direzione_problema VARCHAR(10) DEFAULT NULL;
    DECLARE punto_cardinale VARCHAR(5) DEFAULT NULL;
    DECLARE cod_muro, cod_vano INT DEFAULT 0;
    DECLARE ap_x1, ap_y1, ap_x2, ap_y2 FLOAT DEFAULT 0;
    DECLARE xm, ym FLOAT DEFAULT 0;
    DECLARE numero_intersezioni INT DEFAULT 0;
    
    SET cod_muro =
    (
		SELECT Muro
        FROM Apertura 
        WHERE Codice_apertura = cod_apertura
    );
    
    SET cod_vano = 
    (
		SELECT Vano1
        FROM Muro
        WHERE Codice_muro = cod_muro
    );
	
	CALL Ambiguita_Punto_Cardinale(cod_apertura, direzione_problema);
    
    SET ap_x1 =
    (
		SELECT X1
        FROM Apertura
        WHERE Codice_apertura = cod_apertura
	);
    
    SET ap_x2 =
    (
		SELECT X2
        FROM Apertura
        WHERE Codice_apertura = cod_apertura
	);
    
    SET ap_y1 =
    (
		SELECT Y1
        FROM Apertura
        WHERE Codice_apertura = cod_apertura
	);
    
    SET ap_y2 =
    (
		SELECT Y2
        FROM Apertura
        WHERE Codice_apertura = cod_apertura
	);
    
    SET xm = (ap_x2 + ap_x1) / 2;
    
    SET ym = (ap_y2 + ap_y1) / 2;
    
    IF
		direzione_problema = 'n-s'
	THEN
		CALL Intersezione_Aperture(xm, ym + 0.0001, cod_vano, numero_intersezioni);
		IF numero_intersezioni % 2 = 1 THEN SET punto_cardinale = 'S'; ELSE SET punto_cardinale = 'N'; END IF;
	END IF;
    
    IF
		direzione_problema = 'e-o'
	THEN
		CALL Intersezione_Aperture(xm + 0.0001, ym, cod_vano, numero_intersezioni);
		IF numero_intersezioni % 2 = 1 THEN SET punto_cardinale = 'O'; ELSE SET punto_cardinale = 'E'; END IF;
	END IF;
    
    IF
		direzione_problema = 'n-o/s-e'
	THEN
		CALL Intersezione_Aperture(xm - 0.0001, ym + 0.0001, cod_vano, numero_intersezioni);
		IF numero_intersezioni % 2 = 1 THEN SET punto_cardinale = 'S-E'; ELSE SET punto_cardinale = 'N-O'; END IF;
	END IF;
    
    IF
		direzione_problema = 'n-e/s-o'
	THEN
		CALL Intersezione_Aperture(xm + 0.0001, ym + 0.0001, cod_vano, numero_intersezioni);
		IF numero_intersezioni % 2 = 1 THEN SET punto_cardinale = 'S-O'; ELSE SET punto_cardinale = 'N-E'; END IF;
	END IF;
    
    SET risultato = punto_cardinale;
END $$
DELIMITER ;

# Operazione che calcola, dopo l'inserimento di un'apertura, la relativa orientazione dove la tipologia è finestra / porta-finestra / porta esterna 
DROP PROCEDURE IF EXISTS Orientazione_Apertura;
DELIMITER $$
CREATE PROCEDURE Orientazione_Apertura(cod_apertura INT)
BEGIN
	DECLARE chiuso BOOL DEFAULT TRUE;
    DECLARE finito INT DEFAULT 0;
    DECLARE cod_vano INT DEFAULT 0;
    DECLARE cod_vano_2 INT DEFAULT 0;
    DECLARE cod_muro INT DEFAULT 0;
    DECLARE ext BOOL DEFAULT FALSE;
    DECLARE punto_cardinale VARCHAR(10) DEFAULT NULL;
    DECLARE numero_muri INT DEFAULT NULL;
    DECLARE numero_vertici INT DEFAULT NULL;
    DECLARE _x1, _y1, _x2, _y2 FLOAT DEFAULT NULL;
    
    DECLARE cursore_muri CURSOR FOR
		SELECT x1, y1, x2, y2
        FROM Muro M
        WHERE M.Vano1 = cod_vano OR (M.Vano2 IS NOT NULL AND M.Vano2 = cod_vano);
	
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
    
	CREATE TEMPORARY TABLE IF NOT EXISTS Vertici
	(
		X FLOAT NOT NULL,
		Y FLOAT NOT NULL,
        PRIMARY KEY(X, Y)
	);
    
	TRUNCATE TABLE Vertici;
    
    SET cod_muro = (
		SELECT Muro
        FROM Apertura A
        WHERE A.Codice_apertura = cod_apertura
    );
    
    SET cod_vano = 
    (
		SELECT Vano1
        FROM Muro
        WHERE Codice_muro = cod_muro
    );
    
    SET cod_vano_2 =
    (
		SELECT Vano2
        FROM Muro
        WHERE Codice_muro = cod_muro
    );
    
    SET numero_muri = 
    (
		SELECT COUNT(*)
        FROM Muro M 
        WHERE M.Vano1 = cod_vano OR (M.Vano2 IS NOT NULL AND M.Vano2 = cod_vano)
    );
    
    OPEN cursore_muri;
    ciclo: LOOP
		FETCH cursore_muri INTO _x1, _y1, _x2, _y2;
        
		IF 
			finito = 1
		THEN 
			LEAVE ciclo;
		END IF;
        
        IF
			NOT EXISTS
            (
				SELECT *
                FROM Vertici
                WHERE X = _x1 AND Y = _y1
            )
		THEN
			INSERT INTO Vertici(X, Y) VALUES (_x1, _y1);
		END IF;
		
        IF
			NOT EXISTS
            (
				SELECT *
                FROM Vertici
                WHERE X = _x2 AND Y = _y2
            )
		THEN
			INSERT INTO Vertici(X, Y) VALUES (_x2, _y2);
		END IF;
        
	END LOOP;
    
    SET numero_vertici =
	(
		SELECT COUNT(*)
        FROM Vertici
    );
    
    IF 
		numero_vertici = numero_muri
	THEN
        CALL Punto_Cardinale_Caso_Definito(cod_apertura, punto_cardinale);
	ELSE
		CALL Ambiguita_Punto_Cardinale(cod_apertura, punto_cardinale);
	END IF;

    IF
		cod_vano_2 IS NOT NULL
	THEN
		SET punto_cardinale = NULL;
	END IF;
    
    SELECT punto_cardinale;
END $$
DELIMITER ;

# Operazione che restituisce gli Edifici che abbiano uno stato maggiore o uguale dell'input x
DROP PROCEDURE IF EXISTS Mostra_Edifici_Per_Stato;
DELIMITER $$
CREATE PROCEDURE Mostra_Edifici_Per_Stato(IN _x INT)
BEGIN
	SELECT *
	FROM Edificio E
	WHERE E.Stato >= _x
    ORDER BY E.Stato, E.ID;
END $$
DELIMITER ;

# Operazione che restituisce un elenco delle Calamità in ordine di gravità decrescente dato in input un anno
DROP PROCEDURE IF EXISTS Elenco_Calamita;
DELIMITER $$
CREATE PROCEDURE Elenco_Calamita(IN _anno INT)
BEGIN
	CREATE TEMPORARY TABLE IF NOT EXISTS _CalamitaAnnue 
	(
		Area VARCHAR(50) NOT NULL, 
		Data DATE NOT NULL,
		Orario TIME NOT NULL,
		Nome VARCHAR(50) NOT NULL,
        Epicentro FLOAT,
        Intensita INT,
		PRIMARY KEY(Area, Data, Orario)
	);
    
	TRUNCATE TABLE _CalamitaAnnue;
    
    INSERT INTO _CalamitaAnnue(Area, Data, Orario, Nome, Epicentro, Intensita)
		SELECT *
        FROM Calamita C
        WHERE YEAR(C.Data) = _anno;
	
    SELECT * 
    FROM _CalamitaAnnue C
    ORDER BY C.Intensita DESC;
END $$
DELIMITER ;

# Operazione che data in input una pianta restituisce in output i vani presenti in quella pianta con i relativi vertici
DROP PROCEDURE IF EXISTS Elenco_Vani_Vertici;
DELIMITER $$
CREATE PROCEDURE Elenco_Vani_Vertici(IN cod_pianta INT)
BEGIN
	DROP TABLE IF EXISTS TEMP_Elenco;
    
	CREATE TABLE TEMP_Elenco
	(
		Vano INT NOT NULL,
		X FLOAT NOT NULL,
		Y FLOAT NOT NULL,
        PRIMARY KEY(Vano, X, Y)
	);
    
    INSERT INTO TEMP_Elenco(Vano, X, Y)
		SELECT DISTINCT M.Vano1, M.X1, M.Y1
        FROM Muro M
        WHERE M.Vano1 IN
        (
			SELECT V.Codice_Vano
            FROM Vano V
            WHERE V.Pianta = cod_pianta
        )
        AND 
			 M.Vano1 NOT IN 
        (
			SELECT E.Vano
            FROM TEMP_Elenco E
            WHERE E.Vano = M.Vano1 AND E.X = M.X1 AND E.Y = M.Y1 
        );
        
	INSERT INTO TEMP_Elenco(Vano, X, Y)
		SELECT DISTINCT M.Vano2, M.X1, M.Y1
        FROM Muro M
        WHERE M.Vano2 IN
        (
			SELECT V.Codice_Vano
            FROM Vano V
            WHERE V.Pianta = cod_pianta
        )
        AND
		 M.Vano2 IS NOT NULL
        AND 
			 M.Vano2 NOT IN
        (
			SELECT E.Vano
            FROM TEMP_Elenco E
            WHERE E.Vano = M.Vano2 AND E.X = M.X1 AND E.Y = M.Y1 
        );
        
    INSERT INTO TEMP_Elenco(Vano, X, Y)
		SELECT DISTINCT M.Vano1, M.X2, M.Y2
        FROM Muro M
        WHERE M.Vano1 IN
        (
			SELECT V.Codice_Vano
            FROM Vano V
            WHERE V.Pianta = cod_pianta
        )
        AND 
			 M.Vano1 NOT IN
        (
			SELECT E.Vano
            FROM TEMP_Elenco E
            WHERE E.Vano = M.Vano1 AND E.X = M.X2 AND E.Y = M.Y2
        );
        
    INSERT INTO TEMP_Elenco(Vano, X, Y)
		SELECT DISTINCT M.Vano2, M.X2, M.Y2
        FROM Muro M
        WHERE M.Vano2 IN
        (
			SELECT V.Codice_Vano
            FROM Vano V
            WHERE V.Pianta = cod_pianta
        )
        AND
		 M.Vano2 IS NOT NULL
        AND 
			 M.Vano2 NOT IN
        (
			SELECT E.Vano
            FROM TEMP_Elenco E
            WHERE E.Vano = M.Vano2 AND E.X = M.X2 AND E.Y = M.Y2 
        );
        
	SELECT *
    FROM TEMP_Elenco E;
    
    DROP TABLE TEMP_Elenco;
END $$
DELIMITER ;

# Operazione che restituisce in output tutti i materiali stoccati nell'azienda e la quantità stoccata
DROP PROCEDURE IF EXISTS Elenco_Materiali;
DELIMITER $$
CREATE PROCEDURE Elenco_Materiali()
BEGIN
	(SELECT AM.Nome, SUM(AM.QuantitaStoccata) AS QuantitaStoccataTotale
	 FROM AltriMateriali AM
     GROUP BY AM.Nome)
    UNION
    (SELECT I.Nome, SUM(I.QuantitaStoccata) AS QuantitaStoccataTotale
	 FROM Intonaco I
     GROUP BY I.Nome)
    UNION
    (SELECT M.Nome, SUM(M.QuantitaStoccata) AS QuantitaStoccataTotale
	 FROM Mattoni M
     GROUP BY M.Nome)
	UNION
    (SELECT P.Nome, SUM(P.QuantitaStoccata) AS QuantitaStoccataTotale
	 FROM Piastrelle P
     GROUP BY P.Nome)
    UNION
    (SELECT P.Nome, SUM(P.QuantitaStoccata) AS QuantitaStoccataTotale
	 FROM Pietre P
     GROUP BY P.Nome);		
END $$
DELIMITER ;

# Operazione che dato in input un Edificio restituisce in output se è stato costruito, se è in costruzione, o se è in riparazione
DROP PROCEDURE IF EXISTS Status_Edificio;
DELIMITER $$
CREATE PROCEDURE Status_Edificio(IN edificio INT)
BEGIN
	DECLARE status VARCHAR(50) DEFAULT '';
    DECLARE data_inizio, data_fine DATE DEFAULT NULL;
    
    SET data_inizio = (SELECT MAX(PE.DataInizio)
					   FROM ProgettoEdilizio PE
                       WHERE PE.Edificio = edificio);
	
    SET status = (SELECT PE.Tipo
				  FROM ProgettoEdilizio PE
				  WHERE PE.Edificio = edificio
					   AND
                        PE.DataInizio = data_inizio);
                        
	SET data_fine = (SELECT PE.DataFine
					 FROM ProgettoEdilizio PE
					 WHERE PE.DataInizio = data_inizio);
	
    IF
         data_fine IS NOT NULL
    THEN
		SET status = 'Costruito';
    END IF;
    
    SELECT status;
END $$
DELIMITER ;

# Operazione che data in input una Calmaità, calcola la sua gravità di un Calamità. La gravità è un indice numerico dei danni ricevuti dall'azienda.
DROP FUNCTION IF EXISTS Calcolo_Gravita;
DELIMITER $$
CREATE FUNCTION Calcolo_Gravita(_area_colpita INT, _data DATE, _orario TIME)
RETURNS FLOAT DETERMINISTIC
BEGIN
	DECLARE gravita FLOAT DEFAULT 0;
	DECLARE nome VARCHAR(50) DEFAULT '';
    DECLARE n_edifici INT DEFAULT 0;
	DECLARE n_sensori INT DEFAULT 0;
    
    SET nome = (SELECT C.Nome
				FROM Calamita C
                WHERE C.Area = _area_colpita AND C.Data = _data AND C.Orario = _orario);
                
	SET n_edifici = (SELECT IFNULL(COUNT(*), 0)
					 FROM Edificio E
                     WHERE E.Locazione = _area_colpita);
	
    IF
		n_edifici <> 0
	THEN 
		IF 
			nome = 'Terremoto'
			OR
			nome = 'Ciclone'
			OR
			nome = 'Frana'
			OR
			nome = 'Tornado'
			OR
			nome = 'Valanga'
		THEN
			SET n_sensori = 
			(
				SELECT IFNULL(COUNT(*), 0)
				FROM Registrazione R INNER JOIN Sensore S ON R.ID_Sensore = S.Codice_Seriale 
									 INNER JOIN Vano V on V.Codice_Vano = S.Vano 
									 INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
									 INNER JOIN Edificio E ON P.Edificio = E.ID
				WHERE R.Data = _data 
					 AND 
					 (R.Orario BETWEEN _orario AND DATE_ADD(_orario, INTERVAL 1 HOUR)) 
					 AND 
					  E.Locazione = _area_colpita
					 AND 
					  (S.Categoria = 'Accelerometro X' OR S.Categoria = 'Accelerometro Y' OR S.Categoria = 'Accelerometro Z' 
					   OR S.Categoria = 'Giroscopio X' OR S.Categoria = 'Giroscopio Y' OR S.Categoria = 'Giroscopio Z') 
				);
				SET gravita = n_sensori / n_edifici;
			ELSEIF
				nome = 'Ondata di Caldo'
				OR
				nome = 'Eruzione Vulcanica'
			THEN		
				SET n_sensori = 
				(
					SELECT IFNULL(COUNT(*), 0)
					FROM Registrazione R INNER JOIN Sensore S ON R.ID_Sensore = S.Codice_Seriale 
										 INNER JOIN Vano V on V.Codice_Vano = S.Vano 
										 INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
										 INNER JOIN Edificio E ON P.Edificio = E.ID
					WHERE R.Data = _data 
						 AND 
						 (R.Orario BETWEEN _orario AND DATE_ADD(_orario, INTERVAL 1 HOUR)) 
						 AND 
						  E.Locazione = _area_colpita
						 AND 
						  (S.Categoria = 'Termostato Esterno Caldo' OR S.Categoria = 'Termostato Interno Caldo')
					);
				SET gravita = n_sensori / n_edifici;
			ELSEIF
				nome = 'Alluvione'
				OR
				nome = 'Inondazione'
			THEN		
				SET n_sensori = 
				(
					SELECT IFNULL(COUNT(*), 0)
					FROM Registrazione R INNER JOIN Sensore S ON R.ID_Sensore = S.Codice_Seriale 
										 INNER JOIN Vano V on V.Codice_Vano = S.Vano 
										 INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
										 INNER JOIN Edificio E ON P.Edificio = E.ID
					WHERE R.Data = _data 
						 AND 
						 (R.Orario BETWEEN _orario AND DATE_ADD(_orario, INTERVAL 1 HOUR)) 
						 AND 
						  E.Locazione = _area_colpita
						 AND 
						  S.Categoria = 'Pluviometro'
					);
					SET gravita = n_sensori / n_edifici;
			ELSEIF
				nome = 'Innalzamento Umidità Esterna'
			THEN		
				SET n_sensori = 
				(
					SELECT IFNULL(COUNT(*), 0)
					FROM Registrazione R INNER JOIN Sensore S ON R.ID_Sensore = S.Codice_Seriale 
										 INNER JOIN Vano V on V.Codice_Vano = S.Vano 
										 INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
										 INNER JOIN Edificio E ON P.Edificio = E.ID
					WHERE R.Data = _data 
						 AND 
						 (R.Orario BETWEEN _orario AND DATE_ADD(_orario, INTERVAL 1 HOUR)) 
						 AND 
						  E.Locazione = _area_colpita
						 AND 
						  S.Categoria = 'Igrometro Esterno'
					);
					SET gravita = n_sensori / n_edifici;
			ELSEIF
				nome = 'Innalzamento Umidità Interna'
			THEN		
				SET n_sensori = 
				(
					SELECT IFNULL(COUNT(*), 0)
					FROM Registrazione R INNER JOIN Sensore S ON R.ID_Sensore = S.Codice_Seriale 
										 INNER JOIN Vano V on V.Codice_Vano = S.Vano 
										 INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
										 INNER JOIN Edificio E ON P.Edificio = E.ID
					WHERE R.Data = _data 
						 AND 
						 (R.Orario BETWEEN _orario AND DATE_ADD(_orario, INTERVAL 1 HOUR)) 
						 AND 
						  E.Locazione = _area_colpita 
						 AND 
						  S.Categoria = 'Igrometro Interno'
					);
					SET gravita = n_sensori / n_edifici;
			ELSEIF
				nome = 'Incendio'
			THEN		
				SET n_sensori = 
				(
					SELECT IFNULL(COUNT(*), 0)
					FROM Registrazione R INNER JOIN Sensore S ON R.ID_Sensore = S.Codice_Seriale 
										 INNER JOIN Vano V on V.Codice_Vano = S.Vano 
										 INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
										 INNER JOIN Edificio E ON P.Edificio = E.ID
					WHERE R.Data = _data
						 AND 
						 (R.Orario BETWEEN _orario AND DATE_ADD(_orario, INTERVAL 1 HOUR)) 
						 AND 
						  E.Locazione = _area_colpita 
						 AND 
						  S.Categoria = 'Termostato Interno Caldo'
					);
					SET gravita = n_sensori / n_edifici;
			ELSEIF
				nome = 'Ondata di Freddo'    
			THEN		
				SET n_sensori = 
				(
					SELECT IFNULL(COUNT(*), 0)
					FROM Registrazione R INNER JOIN Sensore S ON R.ID_Sensore = S.Codice_Seriale 
										 INNER JOIN Vano V on V.Codice_Vano = S.Vano 
										 INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
										 INNER JOIN Edificio E ON P.Edificio = E.ID
					WHERE R.Data = _data 
						 AND 
						 (R.Orario BETWEEN _orario AND DATE_ADD(_orario, INTERVAL 1 HOUR)) 
						 AND 
						  E.Locazione = _area_colpita
						 AND 
						  (S.Categoria = 'Termostato Esterno Freddo' OR S.Categoria = 'Termostato Interno Freddo')
					);
					SET gravita = n_sensori / n_edifici;
			ELSEIF
				nome = 'Gelo'
			THEN		
				SET n_sensori = 
				(
					SELECT IFNULL(COUNT(*), 0)
							FROM Registrazione R INNER JOIN Sensore S ON R.ID_Sensore = S.Codice_Seriale 
										 INNER JOIN Vano V on V.Codice_Vano = S.Vano 
										 INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
										 INNER JOIN Edificio E ON P.Edificio = E.ID
					WHERE R.Data = _data 
						 AND 
						 (R.Orario BETWEEN _orario AND DATE_ADD(_orario, INTERVAL 1 HOUR)) 
						 AND 
						  E.Locazione = _area_colpita
						 AND 
						  S.Categoria = 'Termostato Interno Freddo'
					);
					SET gravita = n_sensori / n_edifici;
		END IF;
    END IF;
    
    RETURN gravita;
END $$
DELIMITER ;

# Operazione che dato in input un Progetto Edilizio restituisce in output il suo Costo se il Progetto è finito
DROP PROCEDURE IF EXISTS Costo_Progetto;
DELIMITER $$
CREATE PROCEDURE Costo_Progetto(IN _progetto_edilizio INT)
BEGIN
	DECLARE data_fine DATE DEFAULT NULL;
    
    SET data_fine = (SELECT PE.DataFine
					 FROM ProgettoEdilizio PE
                     WHERE PE.ID_Progetto = _progetto_edilizio);
	
    IF
		data_fine IS NOT NULL
    THEN
		SELECT L.Progetto, PE.Edificio, PE.Tipo, SUM(L.Costo) AS Costo, 'Euro' AS Valuta
		FROM Lavoro L INNER JOIN ProgettoEdilizio PE ON L.Progetto = PE.ID_Progetto
		WHERE L.Progetto = _progetto_edilizio
			 AND
			  PE.DataFine IS NOT NULL; 
    ELSEIF
		data_fine IS NULL
    THEN
		SELECT NULL;
    END IF;
END $$
DELIMITER ;

# Operazione che dati input un Codice Muro e la lungheza di una Crepa provvederà all'inserimento di istenza di un sensore di posizione in Crepa
DROP PROCEDURE IF EXISTS Inserimento_Crepa;
DELIMITER $$
CREATE PROCEDURE Inserimento_Crepa(IN cod_muro INT, IN lunghezza FLOAT, IN angolazione FLOAT)
BEGIN
    DECLARE lunghezza_allerta FLOAT DEFAULT 0;
    
    SET lunghezza_allerta =
    (
		SELECT SQRT((X2 - X1) * (X2 - X1) + (Y2 - Y1) * (Y2 - Y1)) / 2
        FROM Muro
        WHERE Codice_muro = cod_muro
    );
    
	INSERT INTO Crepa(UltimaLunghezzaMisurata, UltimaAngolazioneMisurata, AlertAngolo, AlertLunghezza, UnitaMisura, Muro)
	VALUES (lunghezza, angolazione, 30, lunghezza_allerta, 'mm', cod_muro);
END $$
DELIMITER ;

# Aggiornamento tempo impiegato per Tipologia di Lavoro ogni anno
DROP EVENT IF EXISTS Aggiorna_Tempo_Per_Lavoro;
CREATE EVENT Aggiorna_Tempo_Per_Lavoro
ON SCHEDULE EVERY 1 YEAR
STARTS '2017-12-30 23:50:00'
DO
		UPDATE TipologiaLavoro
        SET TempoStimato = (SELECT IFNULL(FLOOR(AVG(Differenza_Date_Senza_Weekend(L.DataFine, L.DataInizio))), 0)
							FROM Lavoro L
                            WHERE L.TipologiaDiLavoro = Nome
								 AND
                                  YEAR(L.DataFine) = YEAR(CURRENT_DATE()));

# Aggiornamento numero massimo di Lavoratori per Capocantiere ogni anno
DROP EVENT IF EXISTS Aggiorna_Lavoratori_Per_Capocantiere;
CREATE EVENT Aggiorna_Lavoratori_Per_Capocantiere
ON SCHEDULE EVERY 1 YEAR
STARTS '2017-12-31 23:50:00'
DO
		CALL Aggiornamento_Max_N();
    
    
# DATA ANALYTICS

# Consigli di Intervento
DROP PROCEDURE IF EXISTS Consigli_Intervento;
DELIMITER $$
CREATE PROCEDURE Consigli_Intervento(IN edificio INT)
BEGIN
	DECLARE consigli VARCHAR(400);
    DECLARE stipendio_medio_2_responsabili, stipendio_medio_2_capocantiere, stipendio_medio_5_lavoratori FLOAT DEFAULT 0;
    
    SET SQL_SAFE_UPDATES = 0;
    
	DROP TABLE IF EXISTS TEMP_TEMP_Danni_Consigli;
    CREATE TABLE TEMP_Danni_Consigli(
		Codice_Danno INT PRIMARY KEY,
        Gravita INT NOT NULL,
        Zona VARCHAR(50) NOT NULL,
        Lavori_Consigliati VARCHAR(400) DEFAULT NULL,
        Materiali_Consigliati VARCHAR(400) DEFAULT NULL,
        Priorita VARCHAR(50) DEFAULT NULL,
        Priorita_Int INT DEFAULT NULL,
        Approssimazione_Costo_Riparazione FLOAT DEFAULT NULL
    )ENGINE = INNODB DEFAULT CHARSET = LATIN1;
    
    TRUNCATE TABLE TEMP_Danni_Consigli;
    
    INSERT INTO TEMP_Danni_Consigli(Codice_Danno, Gravita, Zona)
		SELECT D.Codice_Danno, D.Entita, D.Zona
		FROM Danno D
		WHERE D.Riparato = FALSE 
			 AND 
              D.Edificio = edificio;
	
	SET stipendio_medio_2_responsabili =
										(
											SELECT AVG(R.Stipendio) * 2
											FROM Responsabile R
                                        );
                                        
	SET stipendio_medio_2_capocantiere =
										(
											SELECT AVG(C.Stipendio) * 2
											FROM Capocantiere C
                                        );
	
    SET stipendio_medio_5_lavoratori =
										(
											SELECT AVG(L.Stipendio) * 5
											FROM Lavoratore L
                                        );
    
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Ispezione Fondamenta e/o Ispezione Chiusura', Materiali_Consigliati = 'Nessuno', Priorita = 'Medio-Bassa', Priorita_Int = 2,
		Approssimazione_Costo_Riparazione = stipendio_medio_2_responsabili / 30 * (
																					 SELECT AVG(T.TempoStimato)
																					 FROM TipologiaLavoro T
																					 WHERE T.Nome = 'Ispezione Fondamenta'
																						  OR
																						   T.Nome = 'Ispezione Chiusura'
																				  )
	WHERE D.Zona = 'Struttura Portante'
		 AND
		  D.Gravita < 1;
          
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Riparazione Fondamenta e/o Riparazione Facciata', Materiali_Consigliati = 'Acciaio, Calcestruzzo, Intonaco a Base di Malta, Intonaco Cementizio e Legno', Priorita = 'Alta', Priorita_Int = 5,
		Approssimazione_Costo_Riparazione = (stipendio_medio_2_capocantiere + stipendio_medio_5_lavoratori) / 30 * (
																													 SELECT AVG(T.TempoStimato)
																													 FROM TipologiaLavoro T
																													 WHERE T.Nome = 'Riparazione Fondamenta'
																														  OR
																														   T.Nome = 'Riparazione Facciata'
																												   )
										   +
                                           (
												SELECT IFNULL(AVG(AM.Costo), 1100)
                                                FROM AltriMateriali AM INNER JOIN ImpiegoAltriMateriali IAM ON AM.Codice_Lotto = IAM.Lotto_Altri_Materiali
																	   INNER JOIN Lavoro L ON IAM.Lavoro = L.Codice_Lavoro
                                                WHERE (AM.Nome = 'Acciaio'
													   OR 
                                                       AM.Nome = 'Calcestruzzo'
                                                       OR 
                                                       AM.Nome = 'Legno')
													 AND
                                                      (L.TipologiaDiLavoro = 'Riparazione Fondamenta'
                                                       OR
                                                       L.TipologiaDiLavoro = 'Riparazione Facciata')
                                           )
                                           +
                                           (
												SELECT IFNULL(AVG(I.Costo), 1500)
                                                FROM Intonaco I INNER JOIN ImpiegoIntonaco II ON I.Codice_Lotto = II.Lotto_Intonaco
																	   INNER JOIN Lavoro L ON II.Lavoro = L.Codice_Lavoro
                                                WHERE (I.Nome = 'Intonaco a Base di Malta'
													   OR 
                                                       I.Nome = 'Intonaco Cementizio')
													 AND
                                                      (L.TipologiaDiLavoro = 'Riparazione Fondamenta'
                                                       OR
                                                       L.TipologiaDiLavoro = 'Riparazione Facciata')
                                           )                                          
	WHERE D.Zona = 'Struttura Portante'
		 AND
		  D.Gravita >= 1;
        
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Ispezione Danni da Calore', Materiali_Consigliati = 'Nessuno', Priorita = 'Bassa', Priorita_Int = 1,
		Approssimazione_Costo_Riparazione = stipendio_medio_2_responsabili / 30 * (
																					 SELECT T.TempoStimato
																					 FROM TipologiaLavoro T
																					 WHERE T.Nome = 'Ispezione Danni da Calore'
																			      )
	WHERE D.Zona = 'Impianto di Raffreddamento'
		 AND
		  D.Gravita < 1;
          
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Installazione o Riparazione Aria Condizionata', Materiali_Consigliati = 'Acciaio e Ferro', Priorita = 'Media', Priorita_Int = 3,
		Approssimazione_Costo_Riparazione = (stipendio_medio_2_capocantiere + stipendio_medio_5_lavoratori) / 30 * (
																													 SELECT T.TempoStimato
																													 FROM TipologiaLavoro T
																													 WHERE T.Nome = 'Installazione o Riparazione Aria Condizionata'
																												   )
										   +
                                           (
												SELECT IFNULL(AVG(AM.Costo), 1000)
                                                FROM AltriMateriali AM INNER JOIN ImpiegoAltriMateriali IAM ON AM.Codice_Lotto = IAM.Lotto_Altri_Materiali
																	   INNER JOIN Lavoro L ON IAM.Lavoro = L.Codice_Lavoro
                                                WHERE (AM.Nome = 'Acciaio'
													   OR 
                                                       AM.Nome = 'Ferro')
													 AND
                                                      L.TipologiaDiLavoro = 'Installazione o Riparazione Aria Condizionata'
                                                       
                                           )
	WHERE D.Zona = 'Impianto di Raffreddamento'
		 AND
		  D.Gravita >= 1;
        
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Ispezione Impianto Elettrico', Materiali_Consigliati = 'Nessuno', Priorita = 'Bassa', Priorita_Int = 1,
		Approssimazione_Costo_Riparazione = stipendio_medio_2_responsabili / 30 * (
																					 SELECT T.TempoStimato
																					 FROM TipologiaLavoro T
																					 WHERE T.Nome = 'Ispezione Impianto Elettrico'
																			      )
	WHERE D.Zona = 'Impianto Elettrico'
		 AND
		  D.Gravita < 1;
          
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Riparazione Impianto Elettrico', Materiali_Consigliati = 'Oro, Piombo, Rame', Priorita = 'Medio-Alta', Priorita_Int = 4,
		Approssimazione_Costo_Riparazione = (stipendio_medio_2_capocantiere + stipendio_medio_5_lavoratori) / 30 * (
																													 SELECT T.TempoStimato
																													 FROM TipologiaLavoro T
																													 WHERE T.Nome = 'Riparazione Impianto Elettrico'
																												   )
										   +
                                           (
												SELECT IFNULL(AVG(AM.Costo), 3000)
                                                FROM AltriMateriali AM INNER JOIN ImpiegoAltriMateriali IAM ON AM.Codice_Lotto = IAM.Lotto_Altri_Materiali
																	   INNER JOIN Lavoro L ON IAM.Lavoro = L.Codice_Lavoro
                                                WHERE (AM.Nome = 'Oro'
													   OR 
                                                       AM.Nome = 'Piombo'
                                                       OR
                                                       AM.Nome = 'Rame')
													 AND
                                                      L.TipologiaDiLavoro = 'Riparazione Impianto Elettrico'
										  )
	WHERE D.Zona = 'Impianto Elettrico'
		 AND
		  D.Gravita >= 1;
	
    UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Ispezione Impianto Telefonico', Materiali_Consigliati = 'Nessuno', Priorita = 'Bassa', Priorita_Int = 1,
		Approssimazione_Costo_Riparazione = stipendio_medio_2_responsabili / 30 * (
																					 SELECT T.TempoStimato
																					 FROM TipologiaLavoro T
																					 WHERE T.Nome = 'Ispezione Impianto Telefonico'
																			      )
	WHERE D.Zona = 'Impianto Telefonico'
		 AND
		  D.Gravita < 1;
          
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Riparazione Impianto Telefonico', Materiali_Consigliati = 'Oro, Piombo, Rame', Priorita = 'Medio-Alta', Priorita_Int = 4,
		Approssimazione_Costo_Riparazione = (stipendio_medio_2_capocantiere + stipendio_medio_5_lavoratori) / 30 * (
																													 SELECT T.TempoStimato
																													 FROM TipologiaLavoro T
																													 WHERE T.Nome = 'Riparazione Impianto Telefonico'
																												   																																																	   
																												   )
										   +
                                           (
												SELECT IFNULL(AVG(AM.Costo), 3000)
                                                FROM AltriMateriali AM INNER JOIN ImpiegoAltriMateriali IAM ON AM.Codice_Lotto = IAM.Lotto_Altri_Materiali
																	   INNER JOIN Lavoro L ON IAM.Lavoro = L.Codice_Lavoro
                                                WHERE (AM.Nome = 'Oro'
													   OR 
                                                       AM.Nome = 'Piombo'
                                                       OR
                                                       AM.Nome = 'Rame')
													 AND
                                                      L.TipologiaDiLavoro = 'Riparazione Impianto Telefonico'
                                           )
	WHERE D.Zona = 'Impianto Telefonico'
		 AND
		  D.Gravita >= 1;
          
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Ispezione Impianto Idraulico', Materiali_Consigliati = 'Nessuno', Priorita = 'Bassa', Priorita_Int = 1,
		Approssimazione_Costo_Riparazione = stipendio_medio_2_responsabili / 30 * (
																					 SELECT AVG(T.TempoStimato)
																					 FROM TipologiaLavoro T
																					 WHERE T.Nome = 'Ispezione Impianto Idraulico'
																			      )
	WHERE D.Zona = 'Impianto Idraulico'
		 AND
		  D.Gravita < 1;
          
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Riparazione Impianto Idraulico', Materiali_Consigliati = 'Acciaio, Ferro, Rame', Priorita = 'Medio-Alta', Priorita_Int = 4,
		Approssimazione_Costo_Riparazione = (stipendio_medio_2_capocantiere + stipendio_medio_5_lavoratori) / 30 * (
																													 SELECT T.TempoStimato
																													 FROM TipologiaLavoro T
																													 WHERE T.Nome = 'Riparazione Impianto Idraulico'
																												   )
										   +
                                           (
												SELECT IFNULL(AVG(AM.Costo), 1100)
                                                FROM AltriMateriali AM INNER JOIN ImpiegoAltriMateriali IAM ON AM.Codice_Lotto = IAM.Lotto_Altri_Materiali
																	   INNER JOIN Lavoro L ON IAM.Lavoro = L.Codice_Lavoro
                                                WHERE (AM.Nome = 'Acciaio'
													   OR 
                                                       AM.Nome = 'Ferro'
                                                       OR
                                                       AM.Nome = 'Rame')
													 AND
                                                      L.TipologiaDiLavoro = 'Riparazione Impianto Idraulico'
                                           )
	WHERE D.Zona = 'Impianto Idraulico'
		 AND
		  D.Gravita >= 1;
        
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Ispezione Umidità di Risalita e/o Ispezione Umidità Esterna', Materiali_Consigliati = 'Nessuno', Priorita = 'Bassa', Priorita_Int = 1,
		Approssimazione_Costo_Riparazione = stipendio_medio_2_responsabili / 30 * (
																					 SELECT AVG(T.TempoStimato)
																					 FROM TipologiaLavoro T
																					 WHERE T.Nome = 'Ispezione Umidità di Risalita'
																						  OR
																						   T.Nome = 'Ispezione Umidità Esterna'
																			      )
    WHERE D.Zona = 'Sistema di Deumidificazione'
		 AND
		  D.Gravita < 1;
          
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Applicazione Intonaci Deumidificanti', Materiali_Consigliati = 'Intonaco Deumidificante', Priorita = 'Media', Priorita_Int = 3,
		Approssimazione_Costo_Riparazione = (stipendio_medio_2_capocantiere + stipendio_medio_5_lavoratori) / 30 * (
																													 SELECT T.TempoStimato
																													 FROM TipologiaLavoro T
																													 WHERE T.Nome = 'Applicazione Intonaci Deumidificanti'
																												   )
										   +
                                           (
												SELECT IFNULL(I.Costo, 2000)
                                                FROM Intonaco I INNER JOIN ImpiegoIntonaco II ON I.Codice_Lotto = II.Lotto_Intonaco
																	   INNER JOIN Lavoro L ON II.Lavoro = L.Codice_Lavoro
                                                WHERE I.Nome = 'Intonaco Deumidificante'
													 AND
                                                      L.TipologiaDiLavoro = 'Applicazione Intonaci Deumidificanti'
                                           )
    WHERE D.Zona = 'Sistema di Deumidificazione'
		 AND
		  D.Gravita >= 1;
        
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Ispezione Caldaia', Materiali_Consigliati = 'Nessuno', Priorita = 'Medio-Bassa', Priorita_Int = 2,
		Approssimazione_Costo_Riparazione = stipendio_medio_2_responsabili / 30 * (
																					 SELECT T.TempoStimato
																					 FROM TipologiaLavoro T
																					 WHERE T.Nome = 'Ispezione Caldaia'
																				  )
    WHERE D.Zona = 'Impianto di Riscaldamento'
		 AND
		  D.Gravita < 1;
          
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Riparazione Caldaia', Priorita = 'Medio-Alta', Materiali_Consigliati = 'Acciaio e Ferro', Priorita_Int = 4,
		Approssimazione_Costo_Riparazione = (stipendio_medio_2_capocantiere + stipendio_medio_5_lavoratori) / 30 * (
																													 SELECT T.TempoStimato
																													 FROM TipologiaLavoro T
																													 WHERE T.Nome = 'Riparazione Caldaia'
																												   )
										   +
                                           (
												SELECT IFNULL(AVG(AM.Costo), 500)
                                                FROM AltriMateriali AM INNER JOIN ImpiegoAltriMateriali IAM ON AM.Codice_Lotto = IAM.Lotto_Altri_Materiali
																	   INNER JOIN Lavoro L ON IAM.Lavoro = L.Codice_Lavoro
                                                WHERE (AM.Nome = 'Acciaio'
													   OR 
                                                       AM.Nome = 'Ferro')
													 AND
                                                      L.TipologiaDiLavoro = 'Riparazione Caldaia'
                                           )
    WHERE D.Zona = 'Impianto di Riscaldamento'
		 AND
		  D.Gravita >= 1;
          
	UPDATE TEMP_Danni_Consigli D
	SET Lavori_Consigliati = 'Riparazione Apertura', Priorita = 'Media', Materiali_Consigliati = 'Acciaio, Ferro, Legno, Vetro', Priorita_Int = 3,
		Approssimazione_Costo_Riparazione = (stipendio_medio_2_capocantiere + stipendio_medio_5_lavoratori) / 30 * (
																													 SELECT T.TempoStimato
																													 FROM TipologiaLavoro T
																													 WHERE T.Nome = 'Riparazione Apertura'
																												   )
										   +
                                           (
												SELECT IFNULL(AVG(AM.Costo), 300)
                                                FROM AltriMateriali AM INNER JOIN ImpiegoAltriMateriali IAM ON AM.Codice_Lotto = IAM.Lotto_Altri_Materiali
																	   INNER JOIN Lavoro L ON IAM.Lavoro = L.Codice_Lavoro
                                                WHERE (AM.Nome = 'Acciaio'
													   OR 
                                                       AM.Nome = 'Ferro'
                                                       OR
                                                       AM.Nome = 'Legno'
                                                       OR
                                                       AM.Nome = 'Vetro')
													 AND
                                                      L.TipologiaDiLavoro = 'Riparazione Apertura'
                                           )
    WHERE D.Zona = 'Apertura' OR D.Zona = 'Aperture'
		 AND
		  D.Gravita >= 1;
	
    IF
		(
			SELECT COUNT(*)
            FROM TEMP_Danni_Consigli
        )
        > 0
    THEN
		SELECT Codice_Danno, Gravita, Zona, Lavori_Consigliati, Priorita, Approssimazione_Costo_Riparazione
        FROM TEMP_Danni_Consigli
        ORDER BY Priorita_INT DESC;
	ELSE
		SELECT 'Non sono necessari interventi di manutenzione per questo Edificio';
    END IF;

    DROP TABLE TEMP_Danni_Consigli;
    
    SET SQL_SAFE_UPDATES = 1;
END $$
DELIMITER ;


# Stima dei Danni
DROP PROCEDURE IF EXISTS Simulazione_Calamita;
DELIMITER $$
CREATE PROCEDURE Simulazione_Calamita(IN _edificio INT, IN _tipologia VARCHAR(50), IN _epicentro INT, IN _intensita FLOAT)
BEGIN
	DECLARE media FLOAT DEFAULT 0;
    DECLARE casi FLOAT DEFAULT 0;
    DECLARE somma_con_intensita FLOAT DEFAULT 0;
    DECLARE casi_con_simulazione FLOAT DEFAULT 0;
    DECLARE delta_stato FLOAT DEFAULT 0;
    
	DROP TABLE IF EXISTS TEMP_Dati_Raccolti;
    CREATE TABLE TEMP_Dati_Raccolti(
		Codice INT PRIMARY KEY,
		Priorita FLOAT NOT NULL,
        Rapporto_epicentro_intensita FLOAT NOT NULL
    )ENGINE = INNODB DEFAULT CHARSET = LATIN1;
    
    TRUNCATE TABLE TEMP_Dati_Raccolti; 
    
	INSERT INTO TEMP_Dati_Raccolti(Codice, Priorita, Rapporto_epicentro_intensita)
		SELECT D.Codice_Danno, D.Entita, C.Epicentro / C.Intensita
        FROM Danno D INNER JOIN CausaDanneggiamento CD ON D.Codice_danno = CD.Danno 
					 INNER JOIN Calamita C ON CD.Area = C.Area AND CD.Data = C.Data AND CD.Orario = C.Orario
        WHERE D.Edificio = _edificio AND C.Nome = _tipologia;
        
	IF
		_intensita < 1 
        OR 
        _intensita > 12
        OR
		_epicentro < 0
    THEN
		SELECT NULL as delta_stato;
    ELSE
		SET somma_con_intensita =
		(
			SELECT SUM(Priorita * (Rapporto_epicentro_intensita))
			FROM TEMP_Dati_Raccolti
		);
		
		SET casi =
		(
			SELECT COUNT(*)
			FROM TEMP_Dati_Raccolti
		);
		
		SET media = somma_con_intensita / casi;
		
		SET delta_stato = ( media * (casi + 1) - somma_con_intensita ) * _intensita / _epicentro ;
		
		DROP TABLE TEMP_Dati_Raccolti;
		
		SELECT delta_stato;
    END IF;
END $$
DELIMITER ;


# Custom Analytic
DROP PROCEDURE IF EXISTS Probabilita_Danni_Muro;
DELIMITER $$
CREATE PROCEDURE Probabilita_Danni_Muro(IN _muro INT)
BEGIN
	DECLARE percentuale, danno, costo FLOAT DEFAULT 0;
    DECLARE edificio, danni_riparati, danni_attuali, giorni_ultima_riparazione, crepe_stessi_lotti INT DEFAULT 0;
    DECLARE gravita_danno_media FLOAT DEFAULT 0;
    
    SET edificio = 
					(
						SELECT E.ID
                        FROM Edificio E INNER JOIN Pianta P ON E.ID = P.Edificio
										INNER JOIN Vano V ON P.Codice_Pianta = V.Pianta
                                        INNER JOIN Muro M ON M.Vano1 = V.Codice_Vano
                        WHERE M.Codice_Muro = _muro
                    );
    
    SET danni_riparati = 
							(
								SELECT IFNULL(COUNT(*), 0)
								FROM Danno D
								WHERE (D.Zona = 'Muratura' 
									   OR
									   D.Zona = 'Muro'
									   OR
									   D.Zona = 'Muri'
									   OR
									   D.Zona = 'Apertura'
									   OR
									   D.Zona = 'Aperture'
									   OR
									   D.Zona = 'Sistema di Deumidificazione'
									   OR
									   D.Zona = 'Struttura Portante')
									 AND
									  D.Entita >= 0.1
									 AND
                                      D.Riparato = TRUE
									 AND
									  D.Edificio = edificio
							);
                            
	SET danni_attuali = 
							(
								SELECT IFNULL(COUNT(*), 0)
								FROM Danno D
								WHERE (D.Zona = 'Muratura' 
									   OR
									   D.Zona = 'Muro'
									   OR
									   D.Zona = 'Muri'
									   OR
									   D.Zona = 'Apertura'
									   OR
									   D.Zona = 'Aperture'
									   OR
									   D.Zona = 'Sistema di Deumidificazione'
									   OR
									   D.Zona = 'Struttura Portante')
									 AND
									  D.Entita >= 0.1
									 AND
                                      D.Riparato = FALSE
									 AND
									  D.Edificio = edificio
							);
                            
	IF
		_muro > 
				 (
					SELECT COUNT(*)
                    FROM Muro
                 )
    THEN
		SELECT CONCAT(percentuale, '%') AS Probabilita_Danno_Stimata, danno AS Danno_Stimato, costo AS Costo_Stimato;
    ELSE
		IF
			danni_riparati >= 1
			AND
			danni_riparati <= 5
		THEN
			SET percentuale = percentuale + 0.1;
		ELSEIF
			danni_riparati > 5
			AND
			danni_riparati <= 10
		THEN
			SET percentuale = percentuale + 0.5;
		ELSEIF
			danni_riparati > 10
		THEN
			SET percentuale = percentuale + 1;
		END IF;
		
		IF
			danni_attuali >= 1
			AND
			danni_attuali <= 5
		THEN
			SET percentuale = percentuale + 1;
		ELSEIF
			danni_attuali > 5
			AND
			danni_attuali <= 10
		THEN
			SET percentuale = percentuale + 5;
		ELSEIF
			danni_attuali > 10
		THEN
			SET percentuale = percentuale + 10;
		END IF;
		
		SET giorni_ultima_riparazione =
											(
												SELECT DATEDIFF(CURRENT_DATE(), IFNULL(MAX(PE.DataFine), (
																										   SELECT PE1.DataFine
																										   FROM ProgettoEdilizio PE1
																										   WHERE PE1.Edificio = edificio
																												AND
																												 PE1.Tipo = 'Costruzione')))
												FROM ProgettoEdilizio PE
												WHERE PE.Edificio = edificio
													 AND
													  PE.Tipo = 'Riparazione'
											);
											
		IF
			giorni_ultima_riparazione > 720
			AND
			giorni_ultima_riparazione <= 15720
		THEN
			SET percentuale = percentuale + (giorni_ultima_riparazione - 720) / 1000;
		ELSEIF
			giorni_ultima_riparazione > 15720
		THEN
			SET percentuale = percentuale + 15;
		END IF;
		
		SET crepe_stessi_lotti =
									(
										SELECT IFNULL(COUNT(DISTINCT D.Muro), 0)
										FROM (
												SELECT C.Codice_Crepa, S.Muro, S.Lotto_Intonaco AS Lotto
												FROM Crepa C INNER JOIN Strato S ON C.Muro = S.Muro
												UNION
												SELECT C.Codice_Crepa, M.Muro, M.Lotto_Mattoni AS Lotto
												FROM Crepa C INNER JOIN Muratura M ON C.Muro = M.Muro
												UNION
												SELECT C.Codice_Crepa, D.Muro, D.Lotto_Pietre AS Lotto
												FROM Crepa C INNER JOIN Decorazione D ON C.Muro = D.Muro
											 ) AS D
										WHERE D.Muro <> _muro
									);
									
		IF
			crepe_stessi_lotti >= 1
			AND
			crepe_stessi_lotti <= 2500
		THEN
			SET percentuale = percentuale + (crepe_stessi_lotti / 5);
		ELSEIF
			crepe_stessi_lotti > 2500
		THEN
			SET percentuale = percentuale + 50;
		END IF;
		
		IF
			_muro IN (SELECT C.Muro
					  FROM Crepa C
					  WHERE C.Riparato = FALSE)
		THEN
			SET percentuale = percentuale + 25;
		ELSEIF
			_muro IN (SELECT C.Muro
					  FROM Crepa C
					  WHERE C.Riparato = TRUE)
		THEN
			SET percentuale = percentuale + 0.5;
		END IF;
		
		SET gravita_danno_media = (SELECT IFNULL(AVG(D.Entita), 0.01)
								   FROM (SELECT IFNULL(D1.Entita, 0) AS Entita
									     FROM Danno D1
									     WHERE (D1.Zona = 'Muratura' 
											    OR
											    D1.Zona = 'Muro'
											    OR
											    D1.Zona = 'Muri'
											    OR
											    D1.Zona = 'Apertura'
											    OR
												D1.Zona = 'Aperture'
											    OR
											    D1.Zona = 'Sistema di Deumidificazione'
											    OR
											    D1.Zona = 'Struttura Portante')
											   AND
											    D1.Edificio = edificio
									    UNION
									    SELECT IFNULL(C1.Entita, 0) AS Entita
									    FROM Crepa C1
									    WHERE C1.Muro = _muro) AS D);
		IF
			gravita_danno_media > 1
		THEN
			SET gravita_danno_media = 1;
		END IF;
		
		SET danno = percentuale/1000 + gravita_danno_media;
		
		IF
			percentuale > 90
		THEN
			SET percentuale = 90;
		END IF;
		
		IF
			(SELECT M.Vano2
			 FROM Muro M
			 WHERE M.Codice_Muro = _muro) IS NULL
		THEN
			SET costo = 
						(
							SELECT IFNULL(AVG(L.Costo), 1000)
							FROM Lavoro L INNER JOIN ProgettoEdilizio PE ON L.Progetto = PE.ID_Progetto
							WHERE PE.Edificio = edificio
								 AND
								  PE.Tipo = 'Costruzione'
								 AND 
								  L.TipologiaDiLavoro = 'Costruzione Pareti Esterne'
						)
						/
						(
							SELECT IFNULL(COUNT(*), 1)
							FROM Muro M INNER JOIN Vano V ON M.Vano1 = V.Codice_Vano # Il Muro va sull'Esterno
										INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
							WHERE P.Edificio = edificio
								 AND
								  M.Vano2 IS NULL
						);
		ELSEIF
			(SELECT M.Vano2
			 FROM Muro M
			 WHERE M.Codice_Muro = _muro) IS NOT NULL
		THEN
			SET costo = 
						(
							SELECT IFNULL(AVG(L.Costo), 1000)
							FROM Lavoro L INNER JOIN ProgettoEdilizio PE ON L.Progetto = PE.ID_Progetto
							WHERE PE.Edificio = edificio
								 AND
								  PE.Tipo = 'Costruzione'
								 AND 
								  L.TipologiaDiLavoro = 'Costruzione Pareti Interne'
						)
						/
						(
							SELECT IFNULL(COUNT(*), 1)
							FROM Muro M INNER JOIN Vano V ON M.Vano1 = V.Codice_Vano # Siamo sicuri che i due Vani siano sulla stessa Pianta
										INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
							WHERE P.Edificio = edificio
								 AND
								  M.Vano2 IS NOT NULL
						 );
		END IF;
		
		SET costo = costo*danno;
		
		IF
			danno > 1.5
		THEN
			SET danno = 1.5;
		END IF;
		
		SELECT CONCAT(percentuale, '%') AS Probabilita_Danno_Stimata, danno AS Danno_Stimato, costo AS Costo_Stimato;
    END IF;
END $$
DELIMITER ;


# POPOLAMENTO

INSERT INTO AreaGeografica(ID_Area, Nome, Nazione)
VALUES (001, 'Abruzzo', 'Italia'),
	   (002, 'Basilicata', 'Italia'),
       (003, 'Calabria', 'Italia'),
       (004, 'Campania', 'Italia'),
       (005, 'Emilia Romagna', 'Italia'),
       (006, 'Friuli-Venezia-Giulia', 'Italia'),
       (007, 'Lazio', 'Italia'),
       (008, 'Liguria', 'Italia'),
       (009, 'Lombardia', 'Italia'),
       (010, 'Marche', 'Italia'),
       (011, 'Molise', 'Italia'),
       (012, 'Piemonte', 'Italia'),
       (013, 'Puglia', 'Italia'),
       (014, 'Sardegna', 'Italia'),
       (015, 'Sicilia', 'Italia'),
       (016, 'Toscana', 'Italia'),
       (017, 'Trentino-Alto Adige', 'Italia'),
       (018, 'Umbria', 'Italia'),
       (019, 'Val di Aosta', 'Italia'),
       (020, 'Veneto', 'Italia');
       
       
INSERT INTO PericoloGeologico(Area, Pericolo, CoefficienteRischio)
VALUES (001, 'Incendio', 0.2),
	   (001, 'Inondazione', 0.1),
       (001, 'Terremoto', 0.8),
       (002, 'Alluvione', 0.1),
       (002, 'Incendio', 0.2),
       (002, 'Frana', 0.3),
       (002, 'Ondata di Caldo', 0.3),
       (002, 'Terremoto', 0.3),
       (003, 'Incendio', 0.4),
       (003, 'Inondazione', 0.4),
       (003, 'Ondata di Caldo', 0.5),
       (003, 'Terremoto', 0.5),
       (003, 'Tornado', 0.1),
       (004, 'Alluvione', 0.4),
       (004, 'Eruzione Vulcanica', 0.3),
       (004, 'Frana', 0.6),
       (004, 'Incendio', 0.6),
       (004, 'Inondazione', 0.4),
       (004, 'Terremoto', 0.5),
       (004, 'Tornado', 0.1),
       (005, 'Ciclone', 0.6),
	   (005, 'Innalzamento Umidità Esterna', 0.6),
       (005, 'Innalzamento Umidità Interna', 0.6),
       (005, 'Incendio', 0.2),
       (005, 'Terremoto', 0.1),
       (005, 'Tornado', 0.5),
       (006, 'Alluvione', 0.3),
       (006, 'Ciclone', 0.5),
       (006, 'Gelo', 0.2),
       (006, 'Incendio', 0.2),
       (006, 'Inondazione', 0.2),
       (006, 'Ondata di Freddo', 0.2),
       (006, 'Terremoto', 0.1),
       (006, 'Tornado', 0.6),
       (007, 'Ciclone', 0.2),
       (007, 'Eruzione Vulcanica', 0.1),
       (007, 'Incendio', 0.2),
       (007, 'Innalzamento Umidità Esterna', 0.4),
       (007, 'Innalzamento Umidità Interna', 0.4),
       (007, 'Inondazione', 0.3),
       (007, 'Terremoto', 0.3),
       (007, 'Tornado', 0.1),
       (008, 'Alluvione', 0.6),
       (008, 'Incendio', 0.2),
       (008, 'Inondazione', 0.4),
       (008, 'Terremoto', 0.2),
       (008, 'Tornado', 0.1),
       (009, 'Alluvione', 0.2),
       (009, 'Ciclone', 0.4),
       (009, 'Gelo', 0.2),
       (009, 'Incendio', 0.2),
       (009, 'Innalzamento Umidità Esterna', 0.3),
       (009, 'Innalzamento Umidità Interna', 0.3),
       (009, 'Ondata di Freddo', 0.2),
       (009, 'Terremoto', 0.1),
       (009, 'Tornado', 0.4),
       (009, 'Valanga', 0.3),
       (010, 'Alluvione', 0.2),
       (010, 'Incendio', 0.2),
       (010, 'Terremoto', 0.8),
       (011, 'Alluvione', 0.1),
       (011, 'Incendio', 0.2),
       (011, 'Inondazione', 0.1),
       (011, 'Frana', 0.1),
       (011, 'Ondata di Caldo', 0.1),
       (011, 'Terremoto', 0.1),
       (012, 'Alluvione', 0.7),
       (012, 'Ciclone', 0.3),
       (012, 'Gelo', 0.4),
       (012, 'Incendio', 0.2),
       (012, 'Ondata di Freddo', 0.5),
       (012, 'Tornado', 0.3),
       (012, 'Valanga', 0.3),
       (013, 'Ciclone', 0.7),
       (013, 'Incendio', 0.5),
       (013, 'Innalzamento Umidità Esterna', 0.1),
       (013, 'Innalzamento Umidità Interna', 0.1),
       (013, 'Inondazione', 0.4),
       (013, 'Ondata di Caldo', 0.5),
       (013, 'Tornado', 0.7),
       (013, 'Terremoto', 0.2),
       (014, 'Frana', 0.2),
       (014, 'Incendio', 0.2),
       (014, 'Innalzamento Umidità Esterna', 0.1),
       (014, 'Innalzamento Umidità Interna', 0.1),
       (014, 'Inondazione', 0.5),
       (014, 'Ondata di Caldo', 0.3),
       (015, 'Alluvione', 0.1),
       (015, 'Ciclone', 0.1),
       (015, 'Eruzione Vulcanica', 0.8),
       (015, 'Frana', 0.1),
       (015, 'Incendio', 0.5),
       (015, 'Innalzamento Umidità Esterna', 0.2),
       (015, 'Innalzamento Umidità Interna', 0.2),
       (015, 'Inondazione', 0.4),
       (015, 'Ondata di Caldo', 0.6),
       (015, 'Terremoto', 0.4),
       (015, 'Tornado', 0.1),
       (016, 'Alluvione', 0.6),
       (016, 'Frana', 0.3),
       (016, 'Gelo', 0.1),
       (016, 'Incendio', 0.2),
       (016, 'Innalzamento Umidità Esterna', 0.7),
       (016, 'Innalzamento Umidità Interna', 0.7),
       (016, 'Inondazione', 0.2),
       (016, 'Terremoto', 0.3),
       (016, 'Valanga', 0.2),
       (017, 'Alluvione', 0.1),
       (017, 'Frana', 0.6),
       (017, 'Gelo', 0.5),
       (017, 'Incendio', 0.2),
       (017, 'Ondata di Freddo', 0.7),
       (017, 'Tornado', 0.1),
       (017, 'Valanga', 0.5),
       (018, 'Frana', 0.1),
       (018, 'Gelo', 0.1),
       (018, 'Incendio', 0.2),
       (018, 'Terremoto', 0.4),
       (018, 'Valanga', 0.1),
       (019, 'Frana', 0.7),
	   (019, 'Gelo', 0.5),
       (019, 'Incendio', 0.2),
       (019, 'Ondata di Freddo', 0.7),
       (019, 'Valanga', 0.7),
       (020, 'Alluvione', 0.8),
       (020, 'Ciclone', 0.6),
       (020, 'Incendio', 0.2),
       (020, 'Innalzamento Umidità Esterna', 0.2),
       (020, 'Innalzamento Umidità Interna', 0.2),
       (020, 'Inondazione', 0.8),
       (020, 'Terremoto', 0.2),
       (020, 'Tornado', 0.6);


INSERT INTO Edificio(Stato, Tipologia, Locazione)
VALUES (1, 'Abitazione', 016),
	   (1, 'Appartamenti', 016),
	   (1, 'Abitazione', 020),
	   (1, 'Negozio', 005),
	   (1, 'Abitazione', 016);
       
INSERT INTO Pianta(Edificio, NumeroPiano)
VALUES (001, 0),
	   (002, 0),
       (002, 1),
       (002, 2),
       (002, 3),
       (003, 0),
       (003, 1),
       (004, 0),
       (004, 1),
       (005, -1),
       (005, 0);
       
INSERT INTO Vano(Funzione, AltezzaMax, Pianta)
VALUES ('Camera', 2.8, 001),
	   ('Camera', 2.8, 001),
       ('Cucina', 2.8, 001),
	   ('Bagno', 2.8, 001),
       ('Salotto', 3, 001),
       ('Garage', 2.8, 001),
       ('Corridoio', 2.8, 001),
       ('Entrata', 3, 002),
       ('Ascensore', 3, 002),
       ('Cucina', 3, 002),
       ('Bagno', 3, 002),
       ('Camera', 3, 002),
       ('Corridoio', 3, 003),
       ('Ascensore', 3, 003),
       ('Bagno', 3, 003),
       ('Cucina', 3, 003),
       ('Camera', 3, 003),
       ('Bagno', 3, 003),
       ('Cucina', 3, 003),
       ('Camera', 3, 003),
       ('Bagno', 3, 003),
       ('Cucina', 3, 003),
       ('Camera', 3, 003),
       ('Bagno', 3, 003),
       ('Cucina', 3, 003),
       ('Camera', 3, 003),
       ('Bagno', 3, 003),
       ('Cucina', 3, 003),
       ('Camera', 3, 003),
       ('Bagno', 3, 003),
       ('Cucina', 3, 003),
       ('Camera', 3, 003),
       ('Bagno', 3, 003),
       ('Cucina', 3, 003),
       ('Camera', 3, 003),
       ('Corridoio', 3, 004),
       ('Ascensore', 3, 004),
       ('Bagno', 3, 004),
       ('Cucina', 3, 004),
       ('Camera', 3, 004),
       ('Bagno', 3, 004),
       ('Cucina', 3, 004),
       ('Camera', 3, 004),
       ('Bagno', 3, 004),
       ('Cucina', 3, 004),
       ('Camera', 3, 004),
       ('Bagno', 3, 004),
       ('Cucina', 3, 004),
       ('Camera', 3, 004),
       ('Bagno', 3, 004),
       ('Cucina', 3, 004),
       ('Camera', 3, 004),
       ('Bagno', 3, 004),
       ('Cucina', 3, 004),
       ('Camera', 3, 004),
       ('Bagno', 3, 004),
       ('Cucina', 3, 004),
       ('Camera', 3, 004),
       ('Corridoio', 3, 005),
       ('Ascensore', 3, 005),
       ('Bagno', 3, 005),
       ('Cucina', 3, 005),
       ('Camera', 3, 005),
       ('Bagno', 3, 005),
       ('Cucina', 3, 005),
       ('Camera', 3, 005),
       ('Bagno', 3, 005),
       ('Cucina', 3, 005),
       ('Camera', 3, 005),
       ('Bagno', 3, 005),
       ('Cucina', 3, 005),
       ('Camera', 3, 005),
       ('Bagno', 3, 005),
       ('Cucina', 3, 005),
       ('Camera', 3, 005),
       ('Bagno', 3, 005),
       ('Cucina', 3, 005),
       ('Camera', 3, 005),
       ('Bagno', 3, 005),
       ('Cucina', 3, 005),
       ('Camera', 3, 005),
       ('Corridoio', 2.8, 006),
       ('Cucina', 2.8, 006),
       ('Sala da Pranzo', 2.8, 006),
       ('Salotto', 2.8, 006),
       ('Salotto', 2.8, 006),
       ('Corridoio', 2.8, 007),
       ('Camera', 2.8, 007),
       ('Bagno', 2.8, 007),
       ('Camera', 2.8, 007),
       ('Camera', 2.8, 007),
       ('Sgabuzzino', 2.8, 007),
       ('Corridoio', 2.8, 008),
       ('Cucina', 2.8, 008),
       ('Camera', 2.8, 008),
       ('Salotto', 2.8, 008),
       ('Salotto', 2.8, 008),
       ('Corridoio', 2.8, 009),
       ('Camera', 2.8, 009),
       ('Bagno', 2.8, 009),
       ('Camera', 2.8, 009),
       ('Camera', 2.8, 009),
       ('Sgabuzzino', 2.8, 009),
       ('Sgabuzzino', 2.3, 010),
       ('Bagno', 2.7, 011),
       ('Camera', 2.7, 011),
       ('Cucina', 2.7, 011),
       ('Salotto', 2.7, 011);

INSERT INTO Muro(Vano1, Vano2, X1, Y1, X2, Y2)
VALUES # Pianta 001
	   (007, NULL, 4, 0, 6, 0),
	   (001, NULL, 0, 0, 4, 0),
       (001, 007, 4, 0, 4, 6),
       (001, 002, 4, 6, 0, 6),
       (001, NULL, 4, 0, 0, 0),
       (002, 007, 4, 6, 4, 12),
       (002, 005, 4, 12, 0, 12),
       (002, NULL, 0, 12 , 0, 6),
       (003, NULL, 6, 0, 10, 0),
       (003, NULL, 10, 0, 10, 6),
       (003, 004, 10, 6, 6, 6),
       (003, 007, 6, 6, 6, 0),
       (004, NULL, 10, 6, 10, 10),
       (004, 007, 10, 10, 6, 10),
       (004, 007, 6, 10, 6, 6),
       (005, 007, 4, 12, 6, 12),
       (005, 006, 6, 12, 6, 15),
       (005, NULL, 6, 15, 6, 18),
       (005, NULL, 6, 18, 0, 18),
       (005, NULL, 0, 18, 0, 12),
       (006, 007, 6, 12, 10, 12),
       (006, NULL, 10, 12, 10, 15),
       (006, NULL, 10, 15, 6, 15),
       (007, NULL, 10, 10, 10, 12),
       # Pianta 002
       (008, NULL, 0, 0, 7, 0),
       (008, 010, 7, 0, 7, 4),
       (008, 011, 7, 4, 7, 6),
       (008, 011, 7, 6, 8, 6),
       (008, 012, 8, 6, 10, 6),
       (008, NULL, 10, 6, 10, 10),
       (008, NULL, 10, 10, 6, 10),
       (008, 009, 6, 10, 6, 8),
       (008, 009, 6, 8, 4, 8),
       (008, 009, 4, 8, 4, 10),
       (009, NULL, 4, 10, 6, 10),
       (008, NULL, 6, 10, 0, 10),
       (008, NULL, 0, 10 ,0, 0),
       (010, NULL, 7, 0, 10, 0),
       (010, NULL, 10, 0, 10, 4),
       (010, 012, 10, 4, 8, 4),
       (010, 011, 8, 4, 7, 4),
       (011, 012, 8, 4, 8, 6),
       (012, NULL, 10, 4, 10, 6),
       # Pianta 003
       (013, NULL, 3, 10, 4, 10),
       (013, 014, 4, 10, 4, 8),
       (013, 014, 4, 8, 6, 8),
       (013, 014, 6, 8, 6, 10),
       (014, NULL, 6, 10, 4, 10),
       (013, NULL, 6, 10, 7, 10),
       (013, 028, 7, 10, 7, 8),
       (013, 028, 7, 8, 8, 8),
       (013, 029, 8, 8, 8, 7),
       (013, 025, 8, 7, 8, 3),
       (013, 023, 8, 3, 8, 2),
       (013, 022, 8, 2, 7, 2),
       (013, 019, 7, 2, 3, 2),
       (013, 016, 3, 2, 2, 2),
       (013, 017, 2, 2, 2, 3),
       (013, 034, 2, 3, 2, 7),
       (013, 031, 2, 7, 2, 8),
       (013, 030, 2, 8, 3, 8),
       (013, 030, 3, 8, 3, 10),
       (015, NULL, 0, 0, 1, 0),
       (015, NULL, 0, 0, 0, 2),
       (015, 017, 0, 2, 1, 2),
       (015, 016, 1, 2, 1, 0),
       (016, NULL, 1, 0, 3, 0),
       (016, 018, 3, 0, 3, 1),
       (016, 019, 3, 1, 3, 2),
       (016, 017, 2, 2, 1, 2),
       (017, NULL, 0, 2, 0, 3),
       (017, 035, 0, 3, 1, 3),
       (017, 034, 1, 3, 2, 3),
       (018, NULL, 3, 0, 5, 0),
       (018, 020, 5, 0, 5, 1),
       (018, 019, 5, 1, 3, 1),
       (019, 020, 5, 1, 7, 1),
       (019, 022, 7, 1, 7, 2),
       (020, NULL, 5, 0, 7, 0),
       (020, 022, 7, 0, 7, 1),
       (021, NULL, 9, 0, 10, 0),
       (021, NULL, 10, 0, 10, 2),
       (021, 023, 10, 2, 9, 2),
       (021, 022, 9, 2, 9, 0),
       (022, NULL, 7, 0, 9, 0),
       (022, 023, 9, 2, 8, 2),
       (023, NULL, 10, 2, 10, 3),
       (023, 026, 10, 3, 9, 3),
       (023, 025, 9, 3, 8, 3),
       (024, NULL, 10, 5, 10, 7),
       (024, 029, 10, 7, 9, 7),
       (024, 025, 9, 7, 9, 5),
       (024, 026, 9, 5, 10, 5),
       (025, 026, 9, 3, 9, 5),
       (025, 029, 9, 7, 8, 7),
       (026, NULL, 10, 3, 10, 5),
       (027, NULL, 10, 8, 10, 10),
       (027, NULL, 10, 10, 9, 10),
       (027, 028, 9, 10, 9, 8),
       (027, 029, 9, 8, 10, 8),
       (028, NULL, 9, 10, 7, 10),
       (028, 029, 8, 8, 9, 8),
       (029, NULL, 10, 7, 10, 8),
       (030, NULL, 2, 10, 3, 10),
       (030, 031, 2, 8, 2, 9),
       (030, 032, 2, 9, 2, 10),
       (031, NULL, 0, 7, 0, 9),
       (031, 032, 0, 9, 2, 9),
       (031, 034, 2, 7, 1, 7),
       (031, 033, 1, 7, 0, 7),
       (032, NULL, 0, 10, 2, 10),
       (032, NULL, 0, 9, 0, 10),
       (033, NULL, 0, 5, 0, 7),
       (033, 034, 1, 7, 1, 5),
       (033, 035, 1, 5, 0, 5),
       (034, 035, 1, 5, 1, 3),
       (035, NULL, 0, 3, 0, 5),
       # Pianta 004
       (036, NULL, 3, 10, 4, 10),
       (036, 037, 4, 10, 4, 8),
       (036, 037, 4, 8, 6, 8),
       (036, 037, 6, 8, 6, 10),
       (037, NULL, 6, 10, 4, 10),
       (036, NULL, 6, 10, 7, 10),
       (036, 051, 7, 10, 7, 8),
       (036, 051, 7, 8, 8, 8),
       (036, 052, 8, 8, 8, 7),
       (036, 048, 8, 7, 8, 3),
       (036, 046, 8, 3, 8, 2),
       (036, 045, 8, 2, 7, 2),
       (036, 042, 7, 2, 3, 2),
       (036, 039, 3, 2, 2, 2),
       (036, 040, 2, 2, 2, 3),
       (036, 057, 2, 3, 2, 7),
       (036, 054, 2, 7, 2, 8),
       (036, 053, 2, 8, 3, 8),
       (036, 053, 3, 8, 3, 10),
       (038, NULL, 0, 0, 1, 0),
       (038, NULL, 0, 0, 0, 2),
       (038, 040, 0, 2, 1, 2),
       (038, 039, 1, 2, 1, 0),
       (039, NULL, 1, 0, 3, 0),
       (039, 041, 3, 0, 3, 1),
       (039, 042, 3, 1, 3, 2),
       (039, 040, 2, 2, 1, 2),
       (040, NULL, 0, 2, 0, 3),
       (040, 058, 0, 3, 1, 3),
       (040, 057, 1, 3, 2, 3),
       (041, NULL, 3, 0, 5, 0),
       (041, 043, 5, 0, 5, 1),
       (041, 042, 5, 1, 3, 1),
       (042, 043, 5, 1, 7, 1),
       (042, 045, 7, 1, 7, 2),
       (043, NULL, 5, 0, 7, 0),
       (043, 045, 7, 0, 7, 1),
       (044, NULL, 9, 0, 10, 0),
       (044, NULL, 10, 0, 10, 2),
       (044, 046, 10, 2, 9, 2),
       (044, 045, 9, 2, 9, 0),
       (045, NULL, 7, 0, 9, 0),
       (045, 046, 9, 2, 8, 2),
       (046, NULL, 10, 2, 10, 3),
       (046, 049, 10, 3, 9, 3),
       (046, 048, 9, 3, 8, 3),
       (047, NULL, 10, 5, 10, 7),
       (047, 052, 10, 7, 9, 7),
       (047, 048, 9, 7, 9, 5),
       (047, 049, 9, 5, 10, 5),
       (048, 049, 9, 3, 9, 5),
       (048, 052, 9, 7, 8, 7),
       (049, NULL, 10, 3, 10, 5),
       (050, NULL, 10, 8, 10, 10),
       (050, NULL, 10, 10, 9, 10),
       (050, 051, 9, 10, 9, 8),
       (050, 052, 9, 8, 10, 8),
       (051, NULL, 9, 10, 7, 10),
       (051, 052, 8, 8, 9, 8),
       (052, NULL, 10, 7, 10, 8),
       (053, NULL, 2, 10, 3, 10),
       (053, 054, 2, 8, 2, 9),
       (053, 055, 2, 9, 2, 10),
       (054, NULL, 0, 7, 0, 9),
       (054, 055, 0, 9, 2, 9),
       (054, 057, 2, 7, 1, 7),
       (054, 056, 1, 7, 0, 7),
       (055, NULL, 0, 10, 2, 10),
       (055, NULL, 0, 9, 0, 10),
       (056, NULL, 0, 5, 0, 7),
       (056, 057, 1, 7, 1, 5),
       (056, 058, 1, 5, 0, 5),
       (057, 058, 1, 5, 1, 3),
       (058, NULL, 0, 3, 0, 5),
       # Pianta 005
       (059, NULL, 3, 10, 4, 10),
       (059, 060, 4, 10, 4, 8),
       (059, 060, 4, 8, 6, 8),
       (059, 060, 6, 8, 6, 10),
       (060, NULL, 6, 10, 4, 10),
       (059, NULL, 6, 10, 7, 10),
       (059, 074, 7, 10, 7, 8),
       (059, 074, 7, 8, 8, 8),
       (059, 075, 8, 8, 8, 7),
       (059, 071, 8, 7, 8, 3),
       (059, 069, 8, 3, 8, 2),
       (059, 068, 8, 2, 7, 2),
       (059, 065, 7, 2, 3, 2),
       (059, 062, 3, 2, 2, 2),
       (059, 063, 2, 2, 2, 3),
       (059, 080, 2, 3, 2, 7),
       (059, 077, 2, 7, 2, 8),
       (059, 076, 2, 8, 3, 8),
       (059, 076, 3, 8, 3, 10),
       (061, NULL, 0, 0, 1, 0),
       (061, NULL, 0, 0, 0, 2),
       (061, 063, 0, 2, 1, 2),
       (061, 062, 1, 2, 1, 0),
       (062, NULL, 1, 0, 3, 0),
       (062, 064, 3, 0, 3, 1),
       (062, 065, 3, 1, 3, 2),
       (062, 063, 2, 2, 1, 2),
       (063, NULL, 0, 2, 0, 3),
       (063, 081, 0, 3, 1, 3),
       (063, 080, 1, 3, 2, 3),
       (064, NULL, 3, 0, 5, 0),
       (064, 066, 5, 0, 5, 1),
       (064, 065, 5, 1, 3, 1),
       (065, 066, 5, 1, 7, 1),
       (065, 068, 7, 1, 7, 2),
       (066, NULL, 5, 0, 7, 0),
       (066, 068, 7, 0, 7, 1),
       (067, NULL, 9, 0, 10, 0),
       (067, NULL, 10, 0, 10, 2),
       (067, 069, 10, 2, 9, 2),
       (067, 068, 9, 2, 9, 0),
       (068, NULL, 7, 0, 9, 0),
       (068, 069, 9, 2, 8, 2),
       (069, NULL, 10, 2, 10, 3),
       (069, 072, 10, 3, 9, 3),
       (069, 071, 9, 3, 8, 3),
       (070, NULL, 10, 5, 10, 7),
       (070, 075, 10, 7, 9, 7),
       (070, 071, 9, 7, 9, 5),
       (070, 072, 9, 5, 10, 5),
       (071, 072, 9, 3, 9, 5),
       (071, 075, 9, 7, 8, 7),
       (072, NULL, 10, 3, 10, 5),
       (073, NULL, 10, 8, 10, 10),
       (073, NULL, 10, 10, 9, 10),
       (073, 074, 9, 10, 9, 8),
       (073, 075, 9, 8, 10, 8),
       (074, NULL, 9, 10, 7, 10),
       (074, 075, 8, 8, 9, 8),
       (075, NULL, 10, 7, 10, 8),
       (076, NULL, 2, 10, 3, 10),
       (076, 077, 2, 8, 2, 9),
       (076, 078, 2, 9, 2, 10),
       (077, NULL, 0, 7, 0, 9),
       (077, 078, 0, 9, 2, 9),
       (077, 080, 2, 7, 1, 7),
       (077, 079, 1, 7, 0, 7),
       (078, NULL, 0, 10, 2, 10),
       (078, NULL, 0, 9, 0, 10),
       (079, NULL, 0, 5, 0, 7),
       (079, 080, 1, 7, 1, 5),
       (079, 081, 1, 5, 0, 5),
       (080, 081, 1, 5, 1, 3),
       (081, NULL, 0, 3, 0, 5),
       # Pianta 006
       (082, NULL, 8, 0, 10, 0),
       (082, NULL, 8, 10, 10, 10),
       (082, 083, 10, 10, 10, 6),
       (082, 083, 10, 6, 14, 6),
       (082, 083, 14, 6, 14, 4),
       (082, 084, 14, 4, 10, 4),
       (082, 084, 10, 4, 10, 0),
       (082, 085, 8, 0, 8, 4),
       (082, 085, 8, 4, 4, 4),
       (082, 085, 4, 4, 4, 6),
       (082, 086, 4, 6, 8, 6),
       (082, 086, 8, 6, 8, 10),
       (083, NULL, 10, 10, 18, 10),
       (083, NULL, 18, 10, 18, 4),
       (083, 084, 18, 4, 14, 4),
       (084, NULL, 18, 4, 18, 0),
       (084, NULL, 18, 0, 10, 0),
       (085, NULL, 8, 0, 0, 0),
       (085, NULL, 0, 0, 0, 6),
       (085, 086, 0, 6, 4, 6),
       (086, NULL, 0, 6, 0, 10),
       (086, NULL, 0, 10, 8, 10),
       # Pianta 007
       (087, NULL, 0, 4, 0, 6),
       (087, NULL, 18, 4, 18, 6),
       (087, 088, 0, 4, 8, 4),
       (087, 089, 8, 4, 18, 4),
       (087, 092, 0, 6, 4, 6),
       (087, 091, 4, 6, 10, 6),
       (087, 090, 10, 6, 18, 6),
       (088, NULL, 0, 0, 8, 0),
       (088, NULL, 0, 0, 0, 4),
       (088, 089, 8, 0, 8, 4),
       (089, NULL, 18, 0, 18, 4),
       (089, NULL, 18, 0, 8, 0),
       (090, NULL, 18, 6, 18, 10),
       (090, NULL, 18, 10, 11, 10),
       (090, 091, 11, 10, 11, 6),
       (091, NULL, 11, 10, 4, 10),
       (091, 092, 4, 10, 4, 6),
       (092, NULL, 0, 6, 0, 10),
       (092, NULL, 0, 10, 4, 10),
       # Pianta 008
       (093, NULL, 8, 0, 10, 0),
       (093, NULL, 8, 10, 10, 10),
       (093, 094, 10, 10, 10, 6),
       (093, 094, 10, 6, 14, 6),
       (093, 094, 14, 6, 14, 4),
       (093, 095, 14, 4, 10, 4),
       (093, 095, 10, 4, 10, 0),
       (093, 096, 8, 0, 8, 4),
       (093, 096, 8, 4, 4, 4),
       (093, 096, 4, 4, 4, 6),
       (093, 097, 4, 6, 8, 6),
       (093, 097, 8, 6, 8, 10),
       (094, NULL, 10, 10, 18, 10),
       (094, NULL, 18, 10, 18, 4),
       (094, 095, 18, 4, 14, 4),
       (095, NULL, 18, 4, 18, 0),
       (095, NULL, 18, 0, 10, 0),
       (096, NULL, 8, 0, 0, 0),
       (096, NULL, 0, 0, 0, 6),
       (096, 097, 0, 6, 4, 6),
       (097, NULL, 0, 6, 0, 10),
       (097, NULL, 0, 10, 8, 10),
       # Pianta 009
       (098, NULL, 0, 4, 0, 6),
       (098, NULL, 18, 4, 18, 6),
       (098, 099, 0, 4, 8, 4),
       (098, 100, 8, 4, 18, 4),
       (098, 103, 0, 6, 4, 6),
       (098, 102, 4, 6, 10, 6),
       (098, 101, 10, 6, 18, 6),
       (099, NULL, 0, 0, 8, 0),
       (099, NULL, 0, 0, 0, 4),
       (099, 100, 8, 0, 8, 4),
       (100, NULL, 18, 0, 18, 4),
       (100, NULL, 18, 0, 8, 0),
       (101, NULL, 18, 6, 18, 10),
       (101, NULL, 18, 10, 11, 10),
       (101, 102, 11, 10, 11, 6),
       (102, NULL, 11, 10, 4, 10),
       (102, 103, 4, 10, 4, 6),
       (103, NULL, 0, 6, 0, 10),
       (103, NULL, 0, 10, 4, 10),
       # Pianta 010
       (104, NULL, 0, 0, 12, 0),
       (104, NULL, 12, 0, 12, 12),
       (104, NULL, 12, 12, 0, 12),
       (104, NULL, 0, 12, 0, 0),
       (105, NULL, 0, 6, 0, 12),
       (105, NULL, 0, 12, 6, 12),
       (105, 106, 6, 12, 6, 6),
       (105, 107, 6, 6, 0, 6),
       (106, NULL, 6, 12, 12, 12),
       (106, NULL, 12, 12, 12, 6),
       (106, 108, 12, 6, 6, 6),
       (107, NULL, 0, 0, 0, 6),
       (107, 108, 6, 6, 6, 0),
       (107, NULL, 0, 0, 6, 0),
       (108, NULL, 12, 6, 12, 0),
       (108, NULL, 12, 0, 6, 0);
       
INSERT INTO Apertura(Muro, X1, Y1, X2, Y2, Balcone, Tipologia)
VALUES # Pianta 001
	   (001, 4.5, 0, 5.5, 0, FALSE, 'Porta Esterna'),
       (003, 4, 4.5, 4, 5.5, FALSE, 'Porta'),
       (005, 0, 4.5, 0, 5.5, FALSE, 'Finestra'),
       (006, 4, 8.5, 4, 9.5, FALSE, 'Porta'),
       (008, 0, 8.5, 0, 9.5, FALSE, 'Finestra'),
       (010, 10, 4.5, 10, 5.5, FALSE, 'Finestra'),
       (012, 6, 4.5, 6, 5.5, FALSE, 'Porta'),
       (015, 6, 7.5, 6, 8.5, FALSE, 'Porta'),
       (013, 10, 8.5, 10, 9.5, FALSE, 'Finestra'),
       (016, 4.5, 12, 5.5, 12, FALSE, 'Porta'),
       (017, 6, 13.25, 6, 13.75, FALSE, 'Porta'),
       (020, 0, 14, 0, 16, FALSE, 'Porta-Finestra'),
       (021, 6.5, 12, 7.5, 12, FALSE, 'Porta'),
       (022, 10, 13.25, 10, 13.75, FALSE, 'Finestra'),
       (024, 10, 11.5, 10, 12.5, FALSE, 'Porta Esterna'),
       # Pianta 002
       (025, 4, 0, 6, 0, FALSE, 'Porta Esterna'),
       (026, 7, 1, 7, 2, FALSE, 'Porta'),
       (033, 4.5, 8, 5.5, 8, FALSE, 'Porta'),
       (039, 10, 1, 10, 2, FALSE, 'Finestra'),
       (040, 8.5, 4, 9.5, 4, FALSE, 'Porta'),
       (041, 7.25, 4, 7.75, 4, FALSE, 'Porta'),
       (043, 10, 5.75, 10 ,6.25, FALSE, 'Finestra'),
       # Pianta 003
       (044, 3.25, 10, 3.75, 10, FALSE, 'Finestra'),
       (049, 6.25, 10, 6.75, 10, FALSE, 'Finestra'),
       (046, 4.5, 8, 5.5, 8, FALSE, 'Porta'),
       (050, 7, 8.5, 7, 9.5, FALSE, 'Porta'),
       (053, 8, 5.5, 8, 6.5, FALSE, 'Porta'),
       (055, 7.25, 2, 7.75, 2, FALSE, 'Porta'),
       (056, 4.5, 2, 5.5, 2, FALSE, 'Porta'),
       (057, 2.25, 2, 2.75, 2, FALSE, 'Porta'),
       (059, 2, 5.5, 2, 6.5, FALSE, 'Porta'),
       (060, 2, 7.25, 2, 7.75, FALSE, 'Porta'),
       (064, 0, 0.5, 0, 1.5, FALSE, 'Finestra'),
       (066, 1, 0.5, 1, 1.5, FALSE, 'Porta'),
       (067, 1.5, 0, 2.5, 0, TRUE, 'Porta-Finestra'),
       (070, 1.25, 2, 1.75, 2, FALSE, 'Porta'),
       (071, 0, 2.25, 0, 2.75, FALSE, 'Finestra'),
       (074, 3.5, 0, 4.5, 0, FALSE, 'Finestra'),
       (076, 3.5, 1, 4.5, 1, FALSE, 'Porta'),
       (077, 5.5, 1, 6.5, 1, FALSE, 'Porta'),
       (079, 5.5, 0, 6.5, 0, TRUE, 'Porta-Finestra'),
       (082, 10, 0.5, 10, 1.5, TRUE, 'Porta-Finestra'),
       (084, 9, 0.5, 9, 1.5, FALSE, 'Porta'),
       (085, 7.5, 0, 8.5, 0, FALSE, 'Finestra'),
       (086, 8.25, 2, 8.75, 2, FALSE, 'Porta'),
       (087, 10, 2.25, 10, 2.75, FALSE, 'Finestra'),
       (090, 10, 5.5, 10, 6.5, FALSE, 'Finestra'),
       (092, 9, 5.5, 9, 6.5, FALSE, 'Porta'),
       (094, 9, 3.5, 9, 4.5, FALSE, 'Porta'),
       (096, 10, 3.5, 10, 4.5, TRUE, 'Porta-Finestra'),
       (097, 10, 8.5, 10, 9.5, FALSE, 'Finestra'),
       (099, 9, 8.5, 9, 9.5, FALSE, 'Porta'),
       (101, 7.5, 10, 8.5, 10, FALSE, 'Finestra'),
       (102, 8.25, 8, 8.75, 8, FALSE, 'Porta'),
       (103, 10, 7.25, 10, 8.75, TRUE, 'Porta-Finestra'),
       (104, 2.25, 10, 2.75, 10, FALSE, 'Finestra'),
       (105, 2, 8.25, 2, 8.75, FALSE, 'Porta'),
       (107, 0, 7.5, 0, 8.5, TRUE, 'Porta-Finestra'),
       (108, 0.5, 9, 1.5, 9, FALSE, 'Porta'),
       (111, 0.5, 10, 1.5, 10, FALSE, 'Finestra'),
       (113, 0, 5.5, 0, 6.5, FALSE, 'Finestra'),
       (114, 1, 5.5, 1, 6.5, FALSE, 'Porta'),
       (116, 1, 3.5, 1, 4.5, FALSE, 'Porta'),
       (117, 0, 3.5, 0, 4.5, TRUE, 'Porta-Finestra'),
       # Pianta 004
       (118, 3.25, 10, 3.75, 10, FALSE, 'Finestra'),
       (123, 6.25, 10, 6.75, 10, FALSE, 'Finestra'),
       (120, 4.5, 8, 5.5, 8, FALSE, 'Porta'),
       (124, 7, 8.5, 7, 9.5, FALSE, 'Porta'),
       (127, 8, 5.5, 8, 6.5, FALSE, 'Porta'),
       (129, 7.25, 2, 7.75, 2, FALSE, 'Porta'),
       (130, 4.5, 2, 5.5, 2, FALSE, 'Porta'),
       (131, 2.25, 2, 2.75, 2, FALSE, 'Porta'),
       (133, 2, 5.5, 2, 6.5, FALSE, 'Porta'),
       (134, 2, 7.25, 2, 7.75, FALSE, 'Porta'),
       (138, 0, 0.5, 0, 1.5, FALSE, 'Finestra'),
       (140, 1, 0.5, 1, 1.5, FALSE, 'Porta'),
       (141, 1.5, 0, 2.5, 0, TRUE, 'Porta-Finestra'),
       (144, 1.25, 2, 1.75, 2, FALSE, 'Porta'),
       (145, 0, 2.25, 0, 2.75, FALSE, 'Finestra'),
       (148, 3.5, 0, 4.5, 0, FALSE, 'Finestra'),
       (150, 3.5, 1, 4.5, 1, FALSE, 'Porta'),
       (151, 5.5, 1, 6.5, 1, FALSE, 'Porta'),
       (153, 5.5, 0, 6.5, 0, TRUE, 'Porta-Finestra'),
       (156, 10, 0.5, 10, 1.5, TRUE, 'Porta-Finestra'),
       (158, 9, 0.5, 9, 1.5, FALSE, 'Porta'),
       (159, 7.5, 0, 8.5, 0, FALSE, 'Finestra'),
       (160, 8.25, 2, 8.75, 2, FALSE, 'Porta'),
       (161, 10, 2.25, 10, 2.75, FALSE, 'Finestra'),
       (164, 10, 5.5, 10, 6.5, FALSE, 'Finestra'),
       (166, 9, 5.5, 9, 6.5, FALSE, 'Porta'),
       (168, 9, 3.5, 9, 4.5, FALSE, 'Porta'),
       (170, 10, 3.5, 10, 4.5, TRUE, 'Porta-Finestra'),
       (171, 10, 8.5, 10, 9.5, FALSE, 'Finestra'),
       (173, 9, 8.5, 9, 9.5, FALSE, 'Porta'),
       (175, 7.5, 10, 8.5, 10, FALSE, 'Finestra'),
       (176, 8.25, 8, 8.75, 8, FALSE, 'Porta'),
       (177, 10, 7.25, 10, 8.75, TRUE, 'Porta-Finestra'),
       (178, 2.25, 10, 2.75, 10, FALSE, 'Finestra'),
       (179, 2, 8.25, 2, 8.75, FALSE, 'Porta'),
       (181, 0, 7.5, 0, 8.5, TRUE, 'Porta-Finestra'),
       (182, 0.5, 9, 1.5, 9, FALSE, 'Porta'),
       (185, 0.5, 10, 1.5, 10, FALSE, 'Finestra'),
       (187, 0, 5.5, 0, 6.5, FALSE, 'Finestra'),
       (188, 1, 5.5, 1, 6.5, FALSE, 'Porta'),
       (190, 1, 3.5, 1, 4.5, FALSE, 'Porta'),
       (191, 0, 3.5, 0, 4.5, TRUE, 'Porta-Finestra'),
       # Pianta 005
       (192, 3.25, 10, 3.75, 10, FALSE, 'Finestra'),
       (197, 6.25, 10, 6.75, 10, FALSE, 'Finestra'),
       (194, 4.5, 8, 5.5, 8, FALSE, 'Porta'),
       (198, 7, 8.5, 7, 9.5, FALSE, 'Porta'),
       (201, 8, 5.5, 8, 6.5, FALSE, 'Porta'),
       (203, 7.25, 2, 7.75, 2, FALSE, 'Porta'),
       (204, 4.5, 2, 5.5, 2, FALSE, 'Porta'),
       (205, 2.25, 2, 2.75, 2, FALSE, 'Porta'),
       (207, 2, 5.5, 2, 6.5, FALSE, 'Porta'),
       (208, 2, 7.25, 2, 7.75, FALSE, 'Porta'),
       (212, 0, 0.5, 0, 1.5, FALSE, 'Finestra'),
       (214, 1, 0.5, 1, 1.5, FALSE, 'Porta'),
       (215, 1.5, 0, 2.5, 0, TRUE, 'Porta-Finestra'),
       (218, 1.25, 2, 1.75, 2, FALSE, 'Porta'),
       (219, 0, 2.25, 0, 2.75, FALSE, 'Finestra'),
       (222, 3.5, 0, 4.5, 0, FALSE, 'Finestra'),
       (224, 3.5, 1, 4.5, 1, FALSE, 'Porta'),
       (255, 5.5, 1, 6.5, 1, FALSE, 'Porta Esterna'),
       (227, 5.5, 0, 6.5, 0, TRUE, 'Porta-Finestra'),
       (230, 10, 0.5, 10, 1.5, TRUE, 'Porta-Finestra'),
       (232, 9, 0.5, 9, 1.5, FALSE, 'Porta'),
       (233, 7.5, 0, 8.5, 0, FALSE, 'Finestra'),
       (234, 8.25, 2, 8.75, 2, FALSE, 'Porta'),
       (235, 10, 2.25, 10, 2.75, FALSE, 'Finestra'),
       (238, 10, 5.5, 10, 6.5, FALSE, 'Finestra'),
       (239, 9, 5.5, 9, 6.5, FALSE, 'Porta'),
       (242, 9, 3.5, 9, 4.5, FALSE, 'Porta'),
       (244, 10, 3.5, 10, 4.5, TRUE, 'Porta-Finestra'),
       (245, 10, 8.5, 10, 9.5, FALSE, 'Finestra'),
       (247, 9, 8.5, 9, 9.5, FALSE, 'Porta'),
       (249, 7.5, 10, 8.5, 10, FALSE, 'Finestra'),
       (250, 8.25, 8, 8.75, 8, FALSE, 'Porta'),
       (251, 10, 7.25, 10, 8.75, TRUE, 'Porta-Finestra'),
       (252, 2.25, 10, 2.75, 10, FALSE, 'Finestra'),
       (253, 2, 8.25, 2, 8.75, FALSE, 'Porta'),
       (255, 0, 7.5, 0, 8.5, TRUE, 'Porta-Finestra'),
       (256, 0.5, 9, 1.5, 9, FALSE, 'Porta'),
       (259, 0.5, 10, 1.5, 10, FALSE, 'Finestra'),
       (261, 0, 5.5, 0, 6.5, FALSE, 'Finestra'),
       (262, 1, 5.5, 1, 6.5, FALSE, 'Porta'),
       (264, 1, 3.5, 1, 4.5, FALSE, 'Porta'),
       (265, 0, 3.5, 0, 4.5, TRUE, 'Porta-Finestra'),
       # Pianta 006
       (266, 8.5, 0, 9.5, 0, FALSE, 'Porta Esterna'),
       (267, 8.5, 10, 9.5, 10, FALSE, 'Porta Esterna'),
       (268, 10, 7.5, 10, 8.5, FALSE, 'Porta'),
       (270, 14, 4.5, 14, 5.5, FALSE, 'Porta'),
       (272, 10, 1.5, 10, 2.5, FALSE, 'Porta'),
       (273, 8, 1.5, 8, 2.5, FALSE, 'Porta'),
       (275, 4, 4.5, 4, 5.5, FALSE, 'Porta'),
       (276, 4.25, 6, 4.75, 6, FALSE, 'Porta'),
       (277, 8, 7.5, 8, 8.5, FALSE, 'Porta'),
       (278, 14, 10, 15, 10, FALSE, 'Finestra'),
       (279, 18, 6.5, 18, 7.5, FALSE, 'Finestra'),
       (280, 14.5, 4, 15.5, 4, FALSE, 'Porta'),
       (281, 18, 2.5, 18, 3.5, FALSE, 'Finestra'),
       (282, 14, 0, 15, 0, FALSE, 'Finestra'),
       (283, 1.5, 0, 2.5, 0, FALSE, 'Finestra'),
       (284, 0, 3.5, 0, 4.5, FALSE, 'Finestra'),
       (285, 1.5, 6, 2.5, 6, FALSE, 'Porta'),
       (286, 7.5, 0, 8.5, 0, FALSE, 'Finestra'),
       (287, 1.5, 0, 3.5, 0, FALSE, 'Porta-Finestra'),
       # Pianta 007
       (290, 1, 4, 2, 4, FALSE, 'Porta'),
       (291, 12.5, 4, 13.5, 4, FALSE, 'Porta'),
       (292, 0.5, 6, 1.5, 6, FALSE, 'Porta'),
       (293, 8, 6, 9, 6, FALSE, 'Porta'),
       (294, 14, 6, 15, 6, FALSE, 'Porta'),
       (295, 4, 0, 5, 0, FALSE, 'Finestra'),
       (299, 12, 0, 14, 0, TRUE, 'Porta-Finestra'),
       (301, 12.5, 10, 13.5, 10, TRUE, 'Porta-Finestra'),
       (303, 6, 10, 7, 10, TRUE, 'Porta-Finestra'),
       # Pianta 008
       (307, 8.5, 0, 9.5, 0, FALSE, 'Porta Esterna'),
       (308, 8.5, 10, 9.5, 10, FALSE, 'Porta Esterna'),
       (309, 10, 7.5, 10, 8.5, FALSE, 'Porta'),
       (311, 14, 4.5, 14, 5.5, FALSE, 'Porta'),
       (313, 10, 1.5, 10, 2.5, FALSE, 'Porta'),
       (314, 8, 1.5, 8, 2.5, FALSE, 'Porta'),
       (316, 4, 4.5, 4, 5.5, FALSE, 'Porta'),
       (317, 4.25, 6, 4.75, 6, FALSE, 'Porta'),
       (318, 8, 7.5, 8, 8.5, FALSE, 'Porta'),
       (319, 14, 10, 15, 10, FALSE, 'Finestra'),
       (320, 18, 6.5, 18, 7.5, FALSE, 'Finestra'),
       (321, 14.5, 4, 15.5, 4, FALSE, 'Porta'),
       (322, 18, 2.5, 18, 3.5, FALSE, 'Finestra'),
       (323, 14, 0, 15, 0, FALSE, 'Finestra'),
       (324, 1.5, 0, 2.5, 0, FALSE, 'Finestra'),
       (325, 0, 3.5, 0, 4.5, FALSE, 'Finestra'),
       (326, 1.5, 6, 2.5, 6, FALSE, 'Porta'),
       (327, 7.5, 0, 8.5, 0, FALSE, 'Finestra'),
       (328, 1.5, 0, 3.5, 0, FALSE, 'Porta-Finestra'),
       # Pianta 009
       (331, 1, 4, 2, 4, FALSE, 'Porta'),
       (332, 12.5, 4, 13.5, 4, FALSE, 'Porta'),
       (333, 0.5, 6, 1.5, 6, FALSE, 'Porta'),
       (334, 8, 6, 9, 6, FALSE, 'Porta'),
       (335, 14, 6, 15, 6, FALSE, 'Porta'),
       (336, 4, 0, 5, 0, FALSE, 'Finestra'),
       (340, 12, 0, 14, 0, TRUE, 'Porta-Finestra'),
       (342, 12.5, 10, 13.5, 10, TRUE, 'Porta-Finestra'),
       (344, 6, 10, 7, 10, TRUE, 'Porta-Finestra'),
       # Pianta 011
       (352, 0, 8.75, 0, 9.25, FALSE, 'Finestra'),
       (353, 2.75, 12, 3.25, 12, FALSE, 'Porta-Finestra'),
       (354, 6, 8.75, 6, 9.25, FALSE, 'Porta'),
       (355, 2.75, 6, 3.25, 6, FALSE, 'Porta'),
       (356, 8.75, 12, 9.25, 12, FALSE, 'Porta-Finestra'),
       (358, 8.75, 6, 9.25, 6, FALSE, 'Porta'),
       (359, 2.75, 0, 3.25, 0, FALSE, 'Finestra'),
       (360, 6, 2.75, 6, 3.25, FALSE, 'Porta'),
       (361, 0, 2.75, 0, 3.25, FALSE, 'Finestra'),
       (362, 12, 2.75, 12, 3.25, FALSE, 'Finestra'),
       (363, 8.75, 0, 9.25, 0, FALSE, 'Porta Esterna');

INSERT INTO ProgettoEdilizio(Tipo, DataApprovazione, DataInizio, StimaFine, DataFine, Edificio)
VALUES ('Costruzione', '2017-01-01', '2017-04-04', '2018-04-04', '2018-05-01', 001), 
       ('Costruzione', '2018-03-15', '2018-07-16', '2019-08-28', '2019-09-30', 002),
       ('Costruzione', '2019-02-04', '2019-05-19', '2020-06-08', '2020-06-30', 003),
       ('Riparazione', '2020-03-06', '2020-04-06', '2020-05-08', '2020-05-14', 001),
       ('Riparazione', '2020-03-10', '2020-04-10', '2020-05-12', '2020-05-12', 002),
       ('Costruzione', '2020-07-17', '2020-10-11', '2021-12-13', '2022-02-24', 004),
       ('Costruzione', '2021-04-04', '2021-08-06', '2023-02-04', NULL, 005);
       
INSERT INTO StadioDiAvanzamento(Numero, Progetto, DataInizio, StimaFine, DataFine, Tipologia, CostoPreventivato)
VALUES (1, 001, '2017-04-04', '2017-04-22', '2017-04-25', 'Fondamenta', 7000),
	   (2, 001, '2017-05-02', '2017-07-07', '2017-07-19', 'Intelaiatura', 20000),
       (3, 001, '2017-07-25', '2017-08-31', '2017-09-04', 'Chiusura', 9000),
       (4, 001, '2017-09-11', '2017-10-18', '2017-10-23', 'Fissaggio', 6500),
       (5, 001, '2017-11-02', '2017-12-04', '2017-12-04', 'Adattamento', 4850),
       (6, 001, '2017-12-11', '2018-04-04', '2018-05-01', 'Rifinitura', 500),
       (1, 002, '2018-07-16', '2018-08-08', '2018-08-08', 'Fondamenta', 15000),
	   (2, 002, '2018-08-15', '2018-11-12', '2018-11-20', 'Intelaiatura', 30000),
       (3, 002, '2018-11-26', '2019-01-15', '2019-01-21', 'Chiusura', 17100),
       (4, 002, '2019-03-11', '2019-05-01', '2019-05-17', 'Fissaggio', 6200),
       (5, 002, '2019-05-27', '2019-06-04', '2019-06-24', 'Adattamento', 8600),
       (6, 002, '2019-07-01', '2019-08-28', '2019-09-30', 'Rifinitura', 250),
       (1, 003, '2019-05-19', '2019-06-10', '2019-06-17', 'Fondamenta', 6200),
	   (2, 003, '2019-06-24', '2019-09-15', '2019-09-25', 'Intelaiatura', 38400),
       (3, 003, '2019-10-01', '2019-11-20', '2019-11-29', 'Chiusura', 6700),
       (4, 003, '2019-12-02', '2020-02-20', '2020-03-03', 'Fissaggio', 12900),
       (5, 003, '2020-03-11', '2020-04-19', '2020-04-21', 'Adattamento', 8200),
       (6, 003, '2020-04-27', '2020-06-08', '2020-06-30', 'Rifinitura', 800),
       (1, 004, '2020-04-06', '2020-04-15', '2020-04-15', 'Riparazione Servizi', 280),
       (2, 004, '2020-04-16', '2020-04-29', '2020-04-30', 'Riparazione Sistema Antisismico', 1200),
       (3, 004, '2020-05-03', '2020-05-10', '2020-05-10', 'Riparazione Pavimentazione', 800),
       (4, 004, '2020-05-11', '2020-05-14', '2020-05-14', 'Riparazione Caldaia', 70),
       (1, 005, '2020-04-10', '2020-05-12', '2020-05-12', 'Riparazione Facciata', 10000),
       (1, 006, '2020-10-12', '2020-11-09', '2020-11-09', 'Fondamenta', 8700),
	   (2, 006, '2020-11-11', '2020-11-20', '2020-11-24', 'Riparazione Stadio di Avanzamento 1', 900),
       (3, 006, '2020-11-30', '2021-02-04', '2021-02-08', 'Intelaiatura', 21000),
       (4, 006, '2021-02-11', '2021-03-31', '2021-04-04', 'Chiusura', 10100),
       (5, 006, '2021-04-26', '2021-07-16', '2021-08-02', 'Fissaggio', 8300),
       (6, 006, '2021-08-23', '2021-09-25', '2021-09-25', 'Riparazione Stadio di Avanzamento 2', 1400),
       (7, 006, '2021-10-14', '2021-11-30', '2021-12-13', 'Adattamento', 7200),
       (8, 006, '2022-01-12', '2022-02-24', '2022-03-08', 'Rifinitura', 700),
	   (1, 007, '2021-08-06', '2021-09-03', '2021-09-03', 'Fondamenta', 9700),
       (2, 007, '2021-09-09', '2021-12-19', '2021-12-18', 'Intelaiatura', 39900),
       (3, 007, '2022-01-10', '2022-03-03', '2022-03-09', 'Chiusura', 18500),
	   (4, 007, '2022-04-04', '2022-04-22', '2022-04-22', 'Riparazione Stadio di Avanzamento', 100),
       (5, 007, '2022-05-02', '2022-06-28', '2022-07-04', 'Fissaggio', 13900),
       (6, 007, '2022-07-25', '2022-11-21', NULL, 'Adattamento', 640);
	
INSERT INTO TipologiaLavoro(Nome, NumeroMinimoLavoratori, NumeroMassimoLavoratori, TempoStimato) 
VALUES ('Scavo', 3, 15, 5), # Fondamenta
       ('Posizionamento Barre di Rinforzo', 3, 10, 1), #(Opzionale)
       ('Costruzione Fondamenta', 5, 15, 14),
       ('Ispezione Fondamenta', 2, 4, 1),
       ('Costruzione Intelaiatura', 5, 15, 60), # Intelaiatura 20
       ('Costruzione Sistema Antisismico', 5, 30, 14),
       ('Ispezione Intelaiatura', 2, 4, 1),
       ('Costruzione Pareti Esterne', 5, 30, 15), # Chiusura
       ('Costruzione Tetti', 5, 30, 15),
       ('Costruzione Grondaie', 3, 10, 3),
       ('Ispezione Chiusura', 2, 4, 1),
       ('Costruzione Pareti Interne', 5, 30, 10), # Fissaggio
       ('Installazione Tubature del Gas', 3, 10, 7),
       ('Installazione Cablaggio Elettrico', 3, 10, 7), 
       ('Installazione Cablaggio Telefonico', 3, 10, 7), 
       ('Installazione Tubature Idrauliche', 3, 10, 7),
       ('Pavimentazione', 5, 15, 7),
       ('Costruzione Caldaia', 5, 10, 3),
       ('Costruzione Camino', 3, 10, 1), #(Opzionale)
       ('Ispezione Fissaggio', 2, 4, 1),
       ('Costruzione e Definizione Stanze', 5, 15, 5), # Adattamento
       ('Pittura Pareti', 5, 10, 3),
       ('Aggiunta Aperture', 5, 10, 4),
	   ('Aggiunta Mobilio', 3, 10, 3),
       ('Lavori di Falegnameria', 3, 10, 2), #(Opzionale)
       ('Installazione Riscaldamento', 3, 10, 4),
       ('Ispezione Adattamento', 2, 4, 1),
       ('Pulizia', 3, 10, 1), # Rifinitura
       ('Lavori di Giardinaggio', 3, 10, 2), #(Opzionale)
       ('Installazione Casetta da Giardino', 3, 10, 1), #(Opzionale)
       ('Installazione Vialetto', 3, 10, 2), #(Opzionale)
       ('Decorazione', 3, 10, 3),
       ('Installazione Antenna Parabolica', 5, 10, 3), 
       ('Attivazione Servizi', 2, 10, 25),
       ('Riparazione Stadio di Avanzamento', 5, 30, 5), #(Opzionale)
       ('Ispezione Finale', 2, 4, 7),
       ('Riparazione Sistema Antisismico', 5, 15, 14), # Riparazione 
       ('Riparazione Fondamenta', 5, 15, 14),
       ('Riparazione Crepa', 3, 10, 3),
       ('Riparazione Muratura', 3, 10, 7),
       ('Riparazione Apertura', 2, 10, 3),
       ('Riparazione Mobilio', 2, 10, 3),
       ('Riparazione Pavimento', 3, 10, 3),
       ('Riparazione Tetto', 5, 15, 7),
       ('Riparazione Grondaie', 3, 10, 3),
       ('Riparazione Riscaldamento', 3, 10, 3),
       ('Riparazione Impianto Elettrico', 3, 10, 3),
       ('Riparazione Impianto Telefonico', 3, 10, 3),
       ('Riparazione Impianto Idraulico', 3, 10, 3),
       ('Riparazione Caldaia', 3, 10, 3),
       ('Riparazione Casetta da Giardino', 3, 10, 3),
       ('Applicazione Intonaci Deumidificanti', 3, 10, 3),
       ('Installazione o Riparazione Aria Condizionata', 3, 10, 1),
       ('Riparazione Facciata', 5, 30, 30),
       ('Ispezione Caldaia', 2, 4, 1), # Ispezioni per Riparazioni
       ('Ispezione Crepa', 2, 4, 1),
       ('Ispezione Impianto Elettrico', 2, 4, 1),
       ('Ispezione Impianto Telefonico', 2, 4, 1),
       ('Ispezione Impianto Idraulico', 2, 4, 1),
       ('Ispezione Impianto Impianto Gas', 2, 4, 1),
       ('Ispezione Umidità di Risalita', 2, 4, 1),
       ('Ispezione Umidità Esterna', 2, 4, 1),
       ('Ispezione Danni da Calore', 2, 4, 1);
       
INSERT INTO Lavoro(DataInizio, DataFine, StadioDiAvanzamento, Progetto, TipologiaDiLavoro)
VALUES # Costruzione Edificio 001
	   ('2017-04-04', '2017-04-08', 1, 001, 'Scavo'),
	   ('2017-04-10', '2017-04-10', 1, 001, 'Posizionamento Barre di Rinforzo'),
       ('2017-04-11', '2017-04-24', 1, 001, 'Costruzione Fondamenta'),
       ('2017-04-25', '2017-04-25', 1, 001, 'Ispezione Fondamenta'),
       ('2017-05-02', '2017-07-03', 2, 001, 'Costruzione Intelaiatura'),
       ('2017-07-03', '2017-07-17', 2, 001, 'Costruzione Sistema Antisismico'),
       ('2017-07-18', '2017-07-19', 2, 001, 'Ispezione Intelaiatura'),
       ('2017-07-26', '2017-08-10', 3, 001, 'Costruzione Pareti Esterne'),
       ('2017-08-11', '2017-08-26', 3, 001, 'Costruzione Tetti'),
       ('2017-08-28', '2017-08-31', 3, 001, 'Costruzione Grondaie'),
       ('2017-09-04', '2017-09-04', 3, 001, 'Ispezione Chiusura'),
       ('2017-09-11', '2017-09-21', 4, 001, 'Costruzione Pareti Interne'),
       ('2017-09-22', '2017-09-29', 4, 001, 'Installazione Tubature del Gas'),
       ('2017-09-25', '2017-10-02', 4, 001, 'Installazione Cablaggio Elettrico'),
       ('2017-09-28', '2017-10-05', 4, 001, 'Installazione Cablaggio Telefonico'),
       ('2017-10-02', '2017-10-09', 4, 001, 'Installazione Tubature Idrauliche'),
       ('2017-10-10', '2017-10-17', 4, 001, 'Pavimentazione'),
       ('2017-10-18', '2017-10-21', 4, 001, 'Costruzione Caldaia'),
       ('2017-10-23', '2017-10-23', 4, 001, 'Ispezione Fissaggio'),
       ('2017-11-02', '2017-11-06', 5, 001, 'Costruzione e Definizione Stanze'),
       ('2017-11-09', '2017-11-11', 5, 001, 'Pittura Pareti'),
       ('2017-11-12', '2017-11-16', 5, 001, 'Aggiunta Aperture'),
       ('2017-11-20', '2017-11-22', 5, 001, 'Aggiunta Mobilio'),
       ('2017-11-23', '2017-11-25', 5, 001, 'Lavori di Falegnameria'),
       ('2017-11-27', '2017-12-01', 5, 001, 'Installazione Riscaldamento'),
       ('2017-12-04', '2017-12-04', 5, 001, 'Ispezione Adattamento'),
       ('2017-12-11', '2017-12-11', 6, 001, 'Pulizia'),
       ('2017-12-12', '2017-12-13', 6, 001, 'Lavori di Giardinaggio'),
       ('2017-12-15', '2017-12-16', 6, 001, 'Installazione Casetta da Giardino'),
       ('2018-01-09', '2018-01-11', 6, 001, 'Installazione Vialetto'),
       ('2018-01-17', '2018-01-20', 6, 001, 'Decorazione'),
       ('2018-01-22', '2018-01-24', 6, 001, 'Installazione Antenna Parabolica'),
       ('2018-02-04', '2018-03-03', 6, 001, 'Riparazione Stadio di Avanzamento'),
       ('2018-03-12', '2018-04-05', 6, 001, 'Attivazione Servizi'),
       ('2018-04-24', '2018-05-01', 6, 001, 'Ispezione Finale'),
       # Costruzione Edificio 002
	   ('2018-07-16', '2018-07-19', 1, 002, 'Scavo'),
       ('2018-07-20', '2018-07-20', 1, 002, 'Posizionamento Barre di Rinforzo'),
       ('2018-07-23', '2018-08-06', 1, 002, 'Costruzione Fondamenta'), 
       ('2018-08-08', '2018-08-08', 1, 002, 'Ispezione Fondamenta'),
       ('2018-08-15', '2018-10-26', 2, 002, 'Costruzione Intelaiatura'),
       ('2018-10-29', '2018-11-16', 2, 002, 'Costruzione Sistema Antisismico'),
       ('2018-11-20', '2018-11-20', 2, 002, 'Ispezione Intelaiatura'),
       ('2018-11-26', '2018-12-14', 3, 002, 'Costruzione Pareti Esterne'),
       ('2018-12-17', '2019-01-14', 3, 002, 'Costruzione Tetti'), 
       ('2019-01-16', '2019-01-18', 3, 002, 'Costruzione Grondaie'),
       ('2019-01-21', '2019-01-21', 3, 002, 'Ispezione Chiusura'),
       ('2019-03-11', '2019-03-22', 4, 002, 'Costruzione Pareti Interne'),
       ('2019-03-25', '2019-03-29', 4, 002, 'Installazione Tubature del Gas'),
       ('2019-04-01', '2019-04-05', 4, 002, 'Installazione Cablaggio Elettrico'),
       ('2019-04-08', '2019-04-12', 4, 002, 'Installazione Cablaggio Telefonico'),
       ('2019-04-15', '2019-04-19', 4, 002, 'Installazione Tubature Idrauliche'),
       ('2019-04-22', '2019-04-30', 4, 002, 'Pavimentazione'),
	   ('2019-05-06', '2019-05-08', 4, 002, 'Costruzione Camino'),
       ('2019-05-09', '2019-05-13', 4, 002, 'Costruzione Caldaia'),
       ('2019-05-17', '2019-05-17', 4, 002, 'Ispezione Fissaggio'),
       ('2019-05-27', '2019-05-31', 5, 002, 'Costruzione e Definizione Stanze'),
       ('2019-06-03', '2019-06-05', 5, 002, 'Pittura Pareti'),
       ('2019-06-10', '2019-06-14', 5, 002, 'Aggiunta Aperture'),
       ('2019-06-17', '2019-06-19', 5, 002, 'Aggiunta Mobilio'),
       ('2019-06-18', '2019-06-21', 5, 002, 'Installazione Riscaldamento'),
	   ('2019-06-20', '2019-06-21', 5, 002, 'Lavori di Falegnameria'),
       ('2019-06-24', '2019-06-24', 5, 002, 'Ispezione Adattamento'),
       ('2019-07-01', '2019-07-01', 6, 002, 'Pulizia'),
       ('2019-07-08', '2019-07-12', 6, 002, 'Decorazione'),
       ('2019-07-26', '2019-07-30', 6, 002, 'Installazione Antenna Parabolica'),
       ('2019-08-09', '2019-09-16', 6, 002, 'Attivazione Servizi'),
       ('2019-09-23', '2019-09-30', 6, 002, 'Ispezione Finale'),
       # Costruzione Edificio 003
       ('2019-05-19', '2019-05-22', 1, 003, 'Scavo'), 
       ('2019-05-22', '2019-05-22', 1, 003, 'Posizionamento Barre di Rinforzo'),
       ('2019-05-25', '2019-06-11', 1, 003, 'Costruzione Fondamenta'),
       ('2019-06-17', '2019-06-17', 1, 003, 'Ispezione Fondamenta'),
       ('2019-06-24', '2019-08-28', 2, 003, 'Costruzione Intelaiatura'),
       ('2019-09-03', '2019-09-20', 2, 003, 'Costruzione Sistema Antisismico'),
       ('2019-09-25', '2019-09-25', 2, 003, 'Ispezione Intelaiatura'),
       ('2019-10-01', '2019-10-22', 3, 003, 'Costruzione Pareti Esterne'),
       ('2019-10-28', '2019-11-15', 3, 003, 'Costruzione Tetti'),
       ('2019-11-15', '2019-11-19', 3, 003, 'Costruzione Grondaie'),
       ('2019-11-22', '2019-11-22', 3, 003, 'Ispezione Chiusura'),
       ('2019-11-25', '2019-11-27', 3, 003, 'Riparazione Stadio di Avanzamento'),
       ('2019-11-29', '2019-11-29', 3, 003, 'Ispezione Chiusura'),
       ('2019-12-02', '2019-12-18', 4, 003, 'Costruzione Pareti Interne'),
	   ('2020-01-08', '2020-01-17', 4, 003, 'Installazione Cablaggio Elettrico'),
       ('2020-01-10', '2020-01-19', 4, 003, 'Installazione Cablaggio Telefonico'),
       ('2020-01-21', '2020-01-25', 4, 003, 'Installazione Tubature del Gas'),
       ('2020-01-28', '2020-02-04', 4, 003, 'Installazione Tubature Idrauliche'),
       ('2020-02-04', '2020-02-13', 4, 003, 'Pavimentazione'),
       ('2020-02-12', '2020-02-15', 4, 003, 'Costruzione Caldaia'),
       ('2020-02-21', '2020-02-21', 4, 003, 'Ispezione Fissaggio'),
       ('2020-02-25', '2020-03-01', 4, 003, 'Riparazione Stadio di Avanzamento'),
       ('2020-03-03', '2020-03-03', 4, 003, 'Ispezione Fissaggio'),
       ('2020-03-11', '2020-03-17', 5, 003, 'Costruzione e Definizione Stanze'),
       ('2020-03-18', '2020-03-20', 5, 003, 'Pittura Pareti'),
       ('2020-03-23', '2020-03-26', 5, 003, 'Aggiunta Aperture'),
       ('2020-04-06', '2020-04-09', 5, 003, 'Aggiunta Mobilio'),
       ('2020-04-14', '2020-04-17', 5, 003, 'Installazione Riscaldamento'),
       ('2020-04-21', '2020-04-21', 5, 003, 'Ispezione Adattamento'),
       ('2020-04-27', '2020-04-27', 6, 003, 'Pulizia'),
       ('2020-05-04', '2020-05-06', 6, 003, 'Decorazione'),
       ('2020-05-07', '2020-05-09', 6, 003, 'Installazione Antenna Parabolica'),
       ('2020-05-18', '2020-06-19', 6, 003, 'Attivazione Servizi'),
       ('2020-06-22', '2020-06-30', 6, 003, 'Ispezione Finale'),
       # Riparazione 1 Edificio 004
       ('2020-04-06', '2020-04-15', 1, 004, 'Riparazione Impianto Elettrico'),
       ('2020-04-06', '2020-04-15', 1, 004, 'Riparazione Impianto Telefonico'),
       ('2020-04-06', '2020-04-15', 1, 004, 'Riparazione Impianto Idraulico'),
       ('2020-04-06', '2020-04-15', 1, 004, 'Riparazione Riscaldamento'),
       ('2020-04-16', '2020-04-30', 2, 004, 'Riparazione Sistema Antisismico'),
       ('2020-05-03', '2020-05-03', 3, 004, 'Riparazione Crepa'),
       ('2020-05-11', '2020-05-13', 4, 004, 'Riparazione Caldaia'),
       ('2020-05-14', '2020-05-14', 4, 004, 'Ispezione Caldaia'),
	   # Riparazione 1 Edificio 002
       ('2020-04-10', '2020-05-11', 1, 005, 'Riparazione Facciata'),
       ('2020-04-10', '2020-04-11', 1, 005, 'Riparazione Crepa'),
       ('2020-04-12', '2020-05-12', 1, 005, 'Ispezione Finale'),
       # Costruzione Edificio 004
       ('2020-10-12', '2020-10-15', 1, 006, 'Scavo'),
       ('2020-10-16', '2020-10-16', 1, 006, 'Posizionamento Barre di Rinforzo'),
       ('2020-10-19', '2020-11-05', 1, 006, 'Costruzione Fondamenta'),
       ('2020-11-09', '2020-11-09', 1, 006, 'Ispezione Fondamenta'),
       ('2020-11-11', '2020-11-20', 2, 006, 'Riparazione Stadio di Avanzamento'),
       ('2020-11-24', '2020-11-24', 2, 006, 'Ispezione Fondamenta'),
       ('2020-11-30', '2021-01-15', 3, 006, 'Costruzione Intelaiatura'),
       ('2021-01-18', '2021-02-04', 3, 006, 'Costruzione Sistema Antisismico'),
       ('2021-02-08', '2021-02-08', 3, 006, 'Ispezione Intelaiatura'),
       ('2021-02-11', '2021-03-03', 4, 006, 'Costruzione Pareti Esterne'),
       ('2021-03-05', '2021-03-25', 4, 006, 'Costruzione Tetti'),
       ('2021-03-29', '2021-03-31', 4, 006, 'Costruzione Grondaie'),
       ('2021-04-04', '2021-04-04', 4, 006, 'Ispezione Chiusura'),
       ('2021-04-26', '2021-05-07', 5, 006, 'Costruzione Pareti Interne'),
       ('2021-05-10', '2021-05-18', 5, 006, 'Installazione Tubature del Gas'),
       ('2021-05-19', '2021-05-27', 5, 006, 'Installazione Cablaggio Elettrico'),
       ('2021-05-31', '2021-06-08', 5, 006, 'Installazione Cablaggio Telefonico'),
       ('2021-06-10', '2021-06-18', 5, 006, 'Installazione Tubature Idrauliche'),
       ('2021-06-28', '2021-07-06', 5, 006, 'Pavimentazione'),
       ('2021-07-14', '2021-07-16', 5, 006, 'Costruzione Caldaia'),
       ('2021-07-23', '2021-07-23', 5, 006, 'Costruzione Camino'),
       ('2021-08-02', '2021-08-02', 5, 006, 'Ispezione Fissaggio'),
       ('2021-08-23', '2021-09-23', 6, 006, 'Riparazione Stadio di Avanzamento'), 
       ('2021-09-25', '2021-09-25', 6, 006, 'Ispezione Fissaggio'),
       ('2021-10-14', '2021-10-20', 7, 006, 'Costruzione e Definizione Stanze'),
       ('2021-10-25', '2021-10-27', 7, 006, 'Pittura Pareti'),
       ('2021-11-01', '2021-11-04', 7, 006, 'Aggiunta Aperture'),
       ('2021-11-16', '2021-11-18', 7, 006, 'Aggiunta Mobilio'),
       ('2021-11-24', '2021-11-29', 7, 006, 'Installazione Riscaldamento'),
       ('2021-12-13', '2021-12-13', 7, 006, 'Ispezione Adattamento'),
       ('2022-01-12', '2022-01-12', 8, 006, 'Pulizia'),
       ('2022-01-17', '2022-01-19', 8, 006, 'Decorazione'),
       ('2022-01-19', '2022-01-21', 8, 006, 'Installazione Antenna Parabolica'),
       ('2022-01-24', '2022-02-25', 8, 006, 'Attivazione Servizi'),
       ('2022-02-28', '2022-03-08', 8, 006, 'Ispezione Finale'),
       # Costruzione Edificio 005
	   ('2021-08-06', '2021-08-11', 1, 007, 'Scavo'),
       ('2021-08-12', '2021-08-31', 1, 007, 'Costruzione Fondamenta'),
       ('2021-09-03', '2021-09-03', 1, 007, 'Ispezione Fondamenta'),
       ('2021-09-09', '2021-11-25', 2, 007, 'Costruzione Intelaiatura'),
       ('2021-11-29', '2021-12-16', 2, 007, 'Costruzione Sistema Antisismico'),
       ('2021-12-18', '2021-12-18', 2, 007, 'Ispezione Intelaiatura'),
       ('2022-01-10', '2022-01-28', 3, 007, 'Costruzione Pareti Esterne'),
       ('2022-01-31', '2022-02-18', 3, 007, 'Costruzione Tetti'),
       ('2022-02-28', '2022-03-02', 3, 007, 'Costruzione Grondaie'),
       ('2022-03-09', '2022-03-09', 3, 007, 'Ispezione Chiusura'),
       ('2022-04-04', '2022-04-21', 4, 007, 'Riparazione Stadio di Avanzamento'),
       ('2022-04-22', '2022-04-22', 4, 007, 'Ispezione Chiusura'),
       ('2022-05-02', '2022-05-13', 5, 007, 'Costruzione Pareti Interne'),
       ('2022-05-19', '2022-05-25', 5, 007, 'Installazione Tubature del Gas'),
       ('2022-05-20', '2022-05-26', 5, 007, 'Installazione Cablaggio Elettrico'),
       ('2022-05-25', '2022-06-02', 5, 007, 'Installazione Cablaggio Telefonico'),
       ('2022-06-01', '2022-06-09', 5, 007, 'Installazione Tubature Idrauliche'),
       ('2022-06-14', '2022-06-23', 5, 007, 'Pavimentazione'),
       ('2022-07-01', '2022-07-01', 5, 007, 'Costruzione Caldaia'),
       ('2022-07-04', '2022-07-04', 5, 007, 'Ispezione Fissaggio'),
       ('2022-07-25', '2022-07-29', 6, 007, 'Costruzione e Definizione Stanze'),
       ('2022-08-04', '2022-08-08', 6, 007, 'Pittura Pareti'),
       ('2022-08-10', '2022-08-11', 6, 007, 'Lavori di Giardinaggio'),
       ('2022-08-16', '2022-08-17', 6, 007, 'Installazione Casetta da Giardino'),
       ('2022-08-29', '2022-08-30', 6, 007, 'Installazione Vialetto'),
       ('2022-09-19', '2022-09-22', 6, 007, 'Aggiunta Aperture'),
       ('2022-10-03', '2022-10-07', 6, 007, 'Aggiunta Mobilio'),
       ('2022-11-07', '2022-11-14', 6, 007, 'Lavori di Falegnameria'),
       ('2022-11-18', NULL, 6, 007, 'Installazione Riscaldamento');
       
INSERT INTO Lavoratore(CodiceFiscale, Nome, Cognome, Sesso, Stipendio, DataNascita, DataAssunzione, Pensione)
VALUES ('LROFND92P09G491B', 'Facondo', 'Lori', 'M', 1200, '1992-09-09', '2016-12-04', FALSE),
	   ('BRSRMG88T24G491Q', 'Remigio', 'Baresi', 'M', 1200, '1988-12-24', '2016-12-04', FALSE),
       ('CRVLGU93E17E202N', 'Luigi', 'Cervi', 'M', 1200, '1993-05-17', '2016-12-04', FALSE),
       ('GTTTMS93B17I726F', 'Tommaso', 'Gatti', 'M', 1200, '1993-02-17', '2016-12-04', FALSE),
       ('MNCDLM88T70G491Y', 'Delma', 'Mancini', 'F', 1200, '1988-12-30', '2016-12-04', FALSE),
       ('BRGPTT92H62A944J', 'Pupetta', 'Bergamaschi', 'A', 1200, '1992-06-22', '2016-12-04', FALSE),
       ('VLDGRC84C20E864J', 'Greco', 'Vladimiro', 'M', 1200, '1984-03-20', '2016-12-04', FALSE),
       ('MNCDNN90D20A561S', 'Donnino', 'Mancini', 'M', 1200, '1990-04-20', '2016-12-04', FALSE),
       ('NPLGLI87E15G702E', 'Gioele', 'Napolitano', 'M', 1200, '1987-05-15', '2016-12-04', FALSE),
       ('TSCCAI84L16A241W', 'Caio', 'Toscani', 'M', 1200, '1984-07-16', '2016-12-04', FALSE),
       ('TRVPIO83B02G882Y', 'Pio', 'Trevisano', 'M', 1000, '1983-02-02', '2017-05-02', FALSE),
       ('FRRFBL80C50A071O', 'Fabiola', 'Ferri', 'F', 1000, '1980-03-10', '2017-05-02', FALSE),
       ('MNNNLM85S01E715V', 'Anselmo', 'Manna', 'M', 1000, '1985-11-01', '2017-05-02', FALSE),
       ('GRCRFN88E24G491V', 'Rufino', 'Greco', 'M', 1000, '1988-05-24', '2017-05-02', FALSE),
       ('CSTLNR92B44G491P', 'Eleonora', 'Costa', 'F', 1000, '1992-02-04', '2017-05-02', FALSE),
       ('FRRVNT92B06C631A', 'Valentino', 'Ferrari', 'M', 1000, '1992-02-06', '2017-05-02', FALSE),
       ('CSTBCC94C18B251C', 'Bacco', 'Castiglione', 'M', 1000, '1994-03-18', '2017-05-02', FALSE),
       ('PRTRMN86D18E451W', 'Romano', 'Protasio', 'M', 1000, '1986-04-18', '2017-05-02', FALSE),
       ('PNCGNR80A16E432R', 'Gennaro', 'Panicucci', 'M', 1000, '1980-01-16', '2017-05-02', FALSE),
       ('NPLLNE80A16F025F', 'Leone', 'Napolitani', 'M', 1000, '1980-01-16', '2017-05-02', FALSE),
       ('LMBLVN80A16G636V', 'Liviano', 'Lombardi', 'M', 1000, '1980-01-16', '2017-05-02', FALSE),
       ('BCHSRI91T15G832G', 'Isauro', 'Bucho', 'M', 1000, '1991-12-15', '2017-05-02', FALSE),
       ('CLBBRD95A24L522T', 'Eberardo', 'Calabresi', 'M', 1000, '1995-01-24', '2017-05-02', FALSE),
       ('MZZRMN79H14E715U', 'Erminio', 'Mazzi', 'M', 1000, '1979-06-14', '2017-05-02', FALSE),
       ('CTTLLD81B10H570C', 'Leopoldo', 'Cattaneo', 'M', 1000, '1981-02-10', '2017-05-02', FALSE),
       ('FRHLRT78L18A561X', 'Albert', 'Ferhati', 'M', 1000, '1978-07-18', '2017-05-02', FALSE),
       ('KCHRTM88H19G491Y', 'Rustem', 'Kochiu', 'M', 1000, '1988-06-19', '2017-05-02', FALSE),
       ('VLDPTR88B10G491X', 'Petrescu', 'Vladimiro', 'M', 1000, '1988-02-10', '2017-05-02', FALSE),
       ('FLPMRK88L29L736B', 'Marku', 'Filipescu', 'M', 1000, '1988-07-29', '2017-05-02', FALSE),
       ('FLLLDA84T14L736J', 'Aldo', 'Folliero', 'M', 1000, '1984-12-14', '2017-05-02', FALSE); 
       
INSERT INTO Capocantiere(CodiceFiscale, Nome, Cognome, Sesso, Stipendio, DataNascita, DataAssunzione, Pensione, NumeroMassimoLavoratori)
VALUES ('NPLVNI85A26L253C', 'Ivone', 'Napolitani', 'M', 1600, '1985-01-26', '2016-12-04', FALSE, 10),
	   ('PCCLVE75C27M172B', 'Elvio', 'Piccio', 'M', 1600, '1975-03-27', '2016-12-04', FALSE, 10),
       ('RSSCMN80C60I872L', 'Clementina', 'Russo', 'F', 1600, '1980-03-20', '2016-12-04', FALSE, 10),
       ('LROVIA83P57G916G', 'Iva', 'Lori', 'F', 1300, '1983-09-17', '2017-05-02', FALSE, 5),
       ('MNFBRD65S27A393X', 'Berardo', 'Manfrin', 'M', 1300, '1965-11-27', '2017-05-02', FALSE, 8),
       ('LCCLEI88S28D643Y', 'Elia', 'Lucchese', 'M', 1300, '1988-11-28', '2017-05-02', FALSE, 5),
       ('DVDRLA79E16F934P', 'Raul', 'Davide', 'M', 1300, '1979-05-16', '2017-05-02', FALSE, 5),
       ('NDRDRD82M10H501C', 'Eduardo', 'Endrizzi', 'M', 1300, '1982-08-10', '2017-05-02', FALSE, 5);
       
INSERT INTO Responsabile(CodiceFiscale, Nome, Cognome, Sesso, Stipendio, DataNascita, DataAssunzione, Pensione)
VALUES ('PNTFNC88B04G491N', 'Francesco', 'Panattoni', 'M', 4000, '1988-02-04', '2016-12-04', FALSE),
	   ('VZZLNZ92P26G491Z', 'Lorenzo', 'Vezzani', 'M', 4000, '1988-09-26', '2016-12-04', FALSE),
       ('NRDGCM80A01D612H', 'Giacomo', 'Nardi', 'M', 3000, '1980-01-01', '2017-05-02', FALSE),
       ('CRSMRT77D04L736D', 'Umberto', 'Caruso', 'M', 3000, '1977-04-04', '2017-05-02', FALSE),
       ('GVRCRN79L55H199W', 'Caterina', 'Giaveri', 'F', 3000, '1979-07-15', '2017-05-02', FALSE),
       ('VLSGAI81H48C342W', 'Gaia', 'Velasco', 'F', 3000, '1981-06-08', '2017-05-02', FALSE);
       
INSERT INTO Responsabilita(Responsabile, Progetto)
VALUES ('PNTFNC88B04G491N', 001),
	   ('VZZLNZ92P26G491Z', 001),
       ('NRDGCM80A01D612H', 002),
       ('CRSMRT77D04L736D', 002),
       ('GVRCRN79L55H199W', 003),
       ('VLSGAI81H48C342W', 003),
       ('PNTFNC88B04G491N', 004),
	   ('VZZLNZ92P26G491Z', 004),
       ('PNTFNC88B04G491N', 005),
	   ('VZZLNZ92P26G491Z', 005),
	   ('NRDGCM80A01D612H', 006),
       ('CRSMRT77D04L736D', 006),
       ('GVRCRN79L55H199W', 007),
       ('VLSGAI81H48C342W', 007);
       
INSERT INTO Calamita(Area, Data, Orario, Nome, Epicentro, Intensita)
VALUES  (001, '2017-01-18', '16:48:00', 'Valanga', 3.7, 9),
		(016, '2017-09-09', '21:00:00', 'Alluvione', 3.7, 9),
        (016, '2017-09-09', '22:15:00', 'Inondazione', 2, 8),
        (006, '2018-10-26', '14:00:00', 'Tornado', 100, 7),
        (017, '2018-10-26', '14:00:00', 'Tornado', 100, 7),
        (020, '2018-10-26', '14:00:00', 'Tornado', 100, 7),
        (008, '2018-10-29', '20:13:12', 'Tornado', 100, 8),
        (007, '2018-10-30', '14:44:44', 'Tornado', 100, 8),
        (004, '2018-11-01', '21:15:12', 'Tornado', 100, 8),
        (003, '2018-11-02', '15:17:24', 'Tornado', 100, 9),
        (013, '2018-11-02', '16:54:22', 'Tornado', 100, 9),
        (015, '2018-11-04', '16:44:44', 'Tornado', 100, 10),
        (001, '2019-11-26', '03:54:11', 'Terremoto', 30, 3),
        (002, '2019-11-26', '03:54:11', 'Terremoto', 30, 3),
        (004, '2019-11-26', '03:54:11', 'Terremoto', 30, 3),
		(011, '2019-11-26', '03:54:11', 'Terremoto', 30, 3),
        (013, '2019-11-26', '03:54:11', 'Terremoto', 30, 3),
        (015, '2019-11-26', '03:54:11', 'Terremoto', 30, 3),
        (016, '2020-03-01', '11:30:45', 'Terremoto', 60, 7),
        (020, '2022-04-04', '04:44:44', 'Terremoto', 45, 8),
        (017, '2022-07-03', '17:00:00', 'Valanga', 0.7, 8),
        (020, '2022-07-03', '17:00:00', 'Valanga', 0.7, 8),
        (010, '2022-09-15', '17:00:00', 'Alluvione', 4.2, 9),
        (010, '2022-09-15', '19:30:00', 'Inondazione', 1.2, 5),
        (004, '2022-11-25', '09:00:00', 'Alluvione', 4, 7),
        (004, '2022-11-26', '05:00:00', 'Inondazione', 1.2, 8);

INSERT INTO Crepa(Muro, UltimaLunghezzaRegistrata, UnitaMisura, UltimaAngolazioneRegistrata, AlertLunghezza, AlertAngolo, Riparato)
VALUES (005, 2.4, 'mm', 12, 15, 30, FALSE),
	   (044, 1.1, 'cm', 5, 3, 30, FALSE),
       (297, 0.4, 'mm', 10, 15, 30, FALSE);
      

DROP PROCEDURE IF EXISTS Popolamento_Impiego_Materiali;
DELIMITER $$
CREATE PROCEDURE Popolamento_Impiego_Materiali()
BEGIN
	DECLARE finito INT DEFAULT 0;
    DECLARE lavoro INT DEFAULT 0;
    DECLARE nome_lavoro VARCHAR(50) DEFAULT '';
    DECLARE data_compravendita DATE DEFAULT NULL;
    DECLARE fornitore VARCHAR(50) DEFAULT '';
    DECLARE numero_fornitore INT DEFAULT 1;
    DECLARE numero_stringa_a INT DEFAULT 0;
    DECLARE numero_stringa_i INT DEFAULT 0;
    DECLARE numero_stringa_m INT DEFAULT 0;
    DECLARE numero_stringa_pia INT DEFAULT 0;
    DECLARE numero_stringa_pie INT DEFAULT 0;
    
    DECLARE lista_lavori CURSOR FOR
		SELECT L.Codice_Lavoro, L.TipologiaDiLavoro, L.DataInizio
        FROM Lavoro L
        WHERE L.DataFine < '2022-11-21';
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
    
    OPEN lista_lavori;
    ciclo: LOOP
		FETCH lista_lavori INTO lavoro, nome_lavoro, data_compravendita;
		IF 
			finito = 1
		THEN 
			LEAVE ciclo;
		END IF;
		
		SET data_compravendita = DATE_SUB(data_compravendita, INTERVAL 1 WEEK);
        
        IF
			DAYOFWEEK(data_compravendita) = 7
        THEN
			SET data_compravendita = DATE_SUB(data_compravendita, INTERVAL 1 DAY);
        ELSEIF
			DAYOFWEEK(data_compravendita) = 1
        THEN
            SET data_compravendita = DATE_ADD(data_compravendita, INTERVAL 1 DAY);
        END IF;
        
        IF
			numero_fornitore = 1
        THEN
			SET fornitore = 'Alpha Express';
            SET numero_fornitore = 2;
		ELSEIF
			numero_fornitore = 2
        THEN
			SET fornitore = 'Beta Company';
            SET numero_fornitore = 3;
		ELSEIF
			numero_fornitore = 3
        THEN
			SET fornitore = 'Omega-Net';
            SET numero_fornitore = 4;
		ELSEIF
			numero_fornitore = 4
        THEN
			SET fornitore = 'Sigma Company';
            SET numero_fornitore = 1;
        END IF;
        
        IF
			nome_lavoro = 'Costruzione Fondamenta'
            OR
            nome_lavoro = 'Riparazione Fondamenta'
        THEN
			IF
				lavoro % 2 = 0
            THEN
                SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES(CONCAT('aaaa', numero_stringa_a), 'Acciaio', 200, 200, fornitore, 2500, data_compravendita),
					  (CONCAT('aaaa', numero_stringa_a+1), 'Cemento Armato', 1000, 1000, fornitore, 3000, data_compravendita);
					
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 200),
					   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 1000);
                
                SET numero_stringa_a = numero_stringa_a + 2;
                
                INSERT INTO Intonaco(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Colore)
                VALUES (CONCAT('bbbb', numero_stringa_i), 'Intonaco a Base di Malta', 1000, 1000, fornitore, 3500, data_compravendita, 'Grigio Scuro');

                INSERT INTO ImpiegoIntonaco(Lavoro, Lotto_Intonaco, Quantita)
                VALUES (lavoro, CONCAT('bbbb', numero_stringa_i), 1000);                
				
                SET numero_stringa_i = numero_stringa_i + 1;
            ELSEIF
				lavoro % 2 <> 0
            THEN
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES(CONCAT('aaaa', numero_stringa_a), 'Ferro', 200, 200, fornitore, 2500, data_compravendita),
					  (CONCAT('aaaa', numero_stringa_a+1), 'Cemento Armato', 1000, 1000, fornitore, 3000, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 200),
					   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 1000);
				
				SET numero_stringa_a = numero_stringa_a + 2;
                
                INSERT INTO Intonaco(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Colore)
                VALUES (CONCAT('bbbb', numero_stringa_i), 'Intonaco Cementizio', 1000, 1000, fornitore, 3500, data_compravendita, 'Grigio Scuro');
                
                INSERT INTO ImpiegoIntonaco(Lavoro, Lotto_Intonaco, Quantita)
                VALUES (lavoro, CONCAT('bbbb', numero_stringa_i), 1000);
                
                SET numero_stringa_i = numero_stringa_i + 1;
            END IF;
		
		ELSEIF
			nome_lavoro = 'Posizionamento Barre di Rinforzo'
        THEN              
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Ferro', 100, 100, fornitore, 1250, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 100);
				
				SET numero_stringa_a = numero_stringa_a + 1;
		
        ELSEIF
			nome_lavoro = 'Costruzione Intelaiatura'
        THEN                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Acciaio', 4000, 4000, fornitore, 20000, data_compravendita),
					   (CONCAT('aaaa', numero_stringa_a+1), 'Calcestruzzo', 500, 500, fornitore, 2000, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+2), 'Legno', 2000, 2000, fornitore, 3000, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 4000),
					   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 500),
                       (lavoro, CONCAT('aaaa', numero_stringa_a+2), 2000);
				
				SET numero_stringa_a = numero_stringa_a + 3;
                
        ELSEIF
			nome_lavoro = 'Costruzione Sistema Antisismico'
            OR
            nome_lavoro = 'Riparazione Sistema Antisismico'
        THEN
			IF
				numero_fornitore = 1 OR numero_fornitore = 3
            THEN                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Cemento Armato', 500, 500, fornitore, 1500, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+1), 'Legno', 1000, 1000, fornitore, 1500, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+2), 'Calcestruzzo', 200, 200, fornitore, 1000, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 500),
					   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 1000),
                       (lavoro, CONCAT('aaaa', numero_stringa_a+2), 200);
				
				SET numero_stringa_a = numero_stringa_a + 3;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Laterizio', 20000, 20000, fornitore, 30000, data_compravendita, 'Cilindrica Cava');
                
                INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 20000);
                
                SET numero_stringa_m = numero_stringa_m + 1;
                
            ELSEIF
				numero_fornitore = 2
            THEN
                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Cemento Armato', 500, 500, fornitore, 1500, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+1), 'Legno', 1000, 1000, fornitore, 1500, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+2), 'Calcestruzzo', 200, 200, fornitore, 1000, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 500),
					   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 1000),
                       (lavoro, CONCAT('aaaa', numero_stringa_a+2), 200);
				
				SET numero_stringa_a = numero_stringa_a + 3;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Calcestruzzo', 20000, 20000, fornitore, 30000, data_compravendita, 'Rettangolare Cava');
                
                INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 20000);
                
                SET numero_stringa_m = numero_stringa_m + 1;
                
			ELSEIF
				numero_fornitore = 4
            THEN
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Cemento Armato', 500, 500, fornitore, 1500, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+1), 'Legno', 1000, 1000, fornitore, 1500, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+2), 'Calcestruzzo', 200, 200, fornitore, 1000, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 500),
					   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 1000),
                       (lavoro, CONCAT('aaaa', numero_stringa_a+2), 200);
				
				SET numero_stringa_a = numero_stringa_a + 3;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Terra Piena', 20000, 20000, fornitore, 1000, data_compravendita, 'Nessuna');
                
                INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 20000);
                
                SET numero_stringa_m = numero_stringa_m + 1;
			END IF;
		
		ELSEIF
			nome_lavoro = 'Costruzione Pareti Esterne'
            OR
            nome_lavoro = 'Costruzione Pareti Interne'
            OR
            nome_lavoro = 'Riparazione Facciata'
        THEN
			IF
				numero_fornitore = 1
            THEN                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Gesso', 5000, 5000, fornitore, 7500, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+1), 'Legno', 1000, 1000, fornitore, 1500, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 5000),
					   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 1000);
				
				SET numero_stringa_a = numero_stringa_a + 2;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Laterizio', 20000, 20000, fornitore, 30000, data_compravendita, 'Cilindrica Cava');
                
                INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 20000);
                
                SET numero_stringa_m = numero_stringa_m + 1;
                
                INSERT INTO Intonaco(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Colore)
                VALUES (CONCAT('bbbb', numero_stringa_i), 'Intonaco Premiscelato', 10000, 10000, fornitore, 12500, data_compravendita, 'Grigio Scuro');
                
                INSERT INTO ImpiegoIntonaco(Lavoro, Lotto_Intonaco, Quantita)
                VALUES (lavoro, CONCAT('bbbb', numero_stringa_i), 10000);
                
                SET numero_stringa_i = numero_stringa_i + 1;
                
            ELSEIF
				numero_fornitore = 2
            THEN               
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Gesso', 5000, 5000, fornitore, 7500, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+1), 'Legno', 1000, 1000, fornitore, 1500, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 5000),
					   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 1000);
				
				SET numero_stringa_a = numero_stringa_a + 2;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Calcestruzzo', 20000, 20000, fornitore, 30000, data_compravendita, 'Rettangolare Cava');
                
                INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 20000);
                
                SET numero_stringa_m = numero_stringa_m + 1;
                
                INSERT INTO Intonaco(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Colore)
                VALUES (CONCAT('bbbb', numero_stringa_i), 'Intonaco Cementizio', 3000, 3000, fornitore, 5800, data_compravendita, 'Grigio Scuro'),
					   (CONCAT('bbbb', numero_stringa_i+1), 'Intonaco a Base di Malta', 3000, 3000, fornitore, 5800, data_compravendita, 'Grigio Scuro'),
                       (CONCAT('bbbb', numero_stringa_i+2), 'Intonaco a Base di Calce', 3000, 3000, fornitore, 5800, data_compravendita, 'Grigio Scuro');
                
                INSERT INTO ImpiegoIntonaco(Lavoro, Lotto_Intonaco, Quantita)
                VALUES (lavoro, CONCAT('bbbb', numero_stringa_i), 3000),
					   (lavoro, CONCAT('bbbb', numero_stringa_i+1), 3000),
                       (lavoro, CONCAT('bbbb', numero_stringa_i+2), 3000);
                
                SET numero_stringa_i = numero_stringa_i + 3;
                
			ELSEIF
				numero_fornitore = 3
            THEN                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Gesso', 5000, 5000, fornitore, 7500, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+1), 'Legno', 1000, 1000, fornitore, 1500, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 5000),
					   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 1000);
				
				SET numero_stringa_a = numero_stringa_a + 2;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Blocco di Cemento', 20000, 20000, fornitore, 25000, data_compravendita, 'Nessuna');
                
                INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 20000);
                
                SET numero_stringa_m = numero_stringa_m + 1;
                
                INSERT INTO Intonaco(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Colore)
                VALUES (CONCAT('bbbb', numero_stringa_i), 'Intonaco a Base di Gesso', 3000, 3000, fornitore, 5800, data_compravendita, 'Grigio Scuro'),
					   (CONCAT('bbbb', numero_stringa_i+1), 'Intonaco a Base di Malta', 3000, 3000, fornitore, 5800, data_compravendita, 'Grigio Scuro'),
                       (CONCAT('bbbb', numero_stringa_i+2), 'Intonaco a Base di Calce', 3000, 3000, fornitore, 5800, data_compravendita, 'Grigio Scuro');
                
                INSERT INTO ImpiegoIntonaco(Lavoro, Lotto_Intonaco, Quantita)
                VALUES (lavoro, CONCAT('bbbb', numero_stringa_i), 3000),
					   (lavoro, CONCAT('bbbb', numero_stringa_i+1), 3000),
                       (lavoro, CONCAT('bbbb', numero_stringa_i+2), 3000);
                
                SET numero_stringa_i = numero_stringa_i + 3;
                
			ELSEIF
				numero_fornitore = 4
            THEN
                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Gesso', 5000, 5000, fornitore, 7500, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+1), 'Legno', 1000, 1000, fornitore, 1500, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 5000),
					   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 1000);
				
				SET numero_stringa_a = numero_stringa_a + 2;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Terra Piena', 20000, 20000, fornitore, 10000, data_compravendita, 'Nessuna');
                
                INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 20000);
                
                SET numero_stringa_m = numero_stringa_m + 1;
                
                INSERT INTO Intonaco(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Colore)
                VALUES (CONCAT('bbbb', numero_stringa_i), 'Intonaco a Base di Gesso', 3000, 3000, fornitore, 4800, data_compravendita, 'Grigio Scuro'),
					   (CONCAT('bbbb', numero_stringa_i+1), 'Intonaco a Base di Malta', 3000, 3000, fornitore, 4800, data_compravendita, 'Grigio Scuro'),
                       (CONCAT('bbbb', numero_stringa_i+2), 'Intonaco a Base di Calce', 3000, 3000, fornitore, 4800, data_compravendita, 'Grigio Scuro'),
                       (CONCAT('bbbb', numero_stringa_i+3), 'Intonaco Cementizio', 3000, 3000, fornitore, 4800, data_compravendita, 'Grigio Scuro');
                
                INSERT INTO ImpiegoIntonaco(Lavoro, Lotto_Intonaco, Quantita)
                VALUES (lavoro, CONCAT('bbbb', numero_stringa_i), 3000),
					   (lavoro, CONCAT('bbbb', numero_stringa_i+1), 3000),
                       (lavoro, CONCAT('bbbb', numero_stringa_i+2), 3000),
                       (lavoro, CONCAT('bbbb', numero_stringa_i+3), 3000);
                
                SET numero_stringa_i = numero_stringa_i + 4;
			END IF;
		
        ELSEIF
			nome_lavoro = 'Costruzione Tetti'
            OR
            nome_lavoro = 'Riparazione Tetto'
        THEN
			IF
				numero_fornitore = 1
            THEN
                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 1000, 1000, fornitore, 1500, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 1000);
				
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Laterizio', 20000, 20000, fornitore, 30000, data_compravendita, 'Cilindrica Cava');
                
                INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 20000);
                
                SET numero_stringa_m = numero_stringa_m + 1;
                
                INSERT INTO Intonaco(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Colore)
                VALUES (CONCAT('bbbb', numero_stringa_i), 'Intonaco Premiscelato', 10000, 10000, fornitore, 22500, data_compravendita, 'Grigio Scuro');
                
                INSERT INTO ImpiegoIntonaco(Lavoro, Lotto_Intonaco, Quantita)
                VALUES (lavoro, CONCAT('bbbb', numero_stringa_i), 10000);
                
                SET numero_stringa_i = numero_stringa_i + 1;
                
            ELSEIF
				numero_fornitore = 2
            THEN
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 1000, 1000, fornitore, 1500, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 1000);
				
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Calcestruzzo', 20000, 20000, fornitore, 30000, data_compravendita, 'Rettangolare Cava');
                
                INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 20000);
                
                SET numero_stringa_m = numero_stringa_m + 1;
                
                INSERT INTO Intonaco(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Colore)
                VALUES (CONCAT('bbbb', numero_stringa_i), 'Intonaco Cementizio', 10000, 10000, fornitore, 17500, data_compravendita, 'Grigio Scuro');
                
                INSERT INTO ImpiegoIntonaco(Lavoro, Lotto_Intonaco, Quantita)
                VALUES (lavoro, CONCAT('bbbb', numero_stringa_i), 10000);
                
                SET numero_stringa_i = numero_stringa_i + 1;
                
			ELSEIF
				numero_fornitore = 3
            THEN              
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 1000, 1000, fornitore, 1500, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 1000);
				
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Blocco di Cemento', 20000, 20000, fornitore, 25000, data_compravendita, 'Nessuna');
                
                INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 20000);
                
                SET numero_stringa_m = numero_stringa_m + 1;
                
                INSERT INTO Intonaco(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Colore)
                VALUES (CONCAT('bbbb', numero_stringa_i), 'Intonaco a Base di Malta', 10000, 10000, fornitore, 20000, data_compravendita, 'Grigio Scuro');
                
                INSERT INTO ImpiegoIntonaco(Lavoro, Lotto_Intonaco, Quantita)
                VALUES (lavoro, CONCAT('bbbb', numero_stringa_i), 10000);
                
                SET numero_stringa_i = numero_stringa_i + 1;
                
			ELSEIF
				numero_fornitore = 4
            THEN
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
                VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 1000, 1000, fornitore, 1500, data_compravendita);
                      
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 1000);
				
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Terra Piena', 20000, 20000, fornitore, 10000, data_compravendita, 'Nessuna');
                
                INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 20000);
                
                SET numero_stringa_m = numero_stringa_m + 1;
                
                INSERT INTO Intonaco(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Colore)
                VALUES (CONCAT('bbbb', numero_stringa_i), 'Intonaco a Base di Gesso', 10000, 10000, fornitore, 15000, data_compravendita, 'Grigio Scuro');
                
                INSERT INTO ImpiegoIntonaco(Lavoro, Lotto_Intonaco, Quantita)
                VALUES (lavoro, CONCAT('bbbb', numero_stringa_i), 10000);
                
                SET numero_stringa_i = numero_stringa_i + 1;
			END IF;
            
		ELSEIF
			nome_lavoro = 'Installazione Tubature del Gas'
        THEN
			INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
			VALUES (CONCAT('aaaa', numero_stringa_a), 'Ferro', 100, 100, fornitore, 200, data_compravendita),
				   (CONCAT('aaaa', numero_stringa_a+1), 'Piombo', 100, 100, fornitore, 250, data_compravendita),
				   (CONCAT('aaaa', numero_stringa_a+2), 'Rame', 200, 200, fornitore, 600, data_compravendita);
                      
			INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
			VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 100),
				   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 100),
				   (lavoro, CONCAT('aaaa', numero_stringa_a+2), 200);
				
			SET numero_stringa_a = numero_stringa_a + 3;
                
		ELSEIF
			nome_lavoro = 'Installazione Cablaggio Elettrico'
            OR
            nome_lavoro = 'Riparazione Impianto Elettrico'
        THEN
			INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
            VALUES (CONCAT('aaaa', numero_stringa_a), 'Oro', 100, 100, fornitore, 200, data_compravendita),
                   (CONCAT('aaaa', numero_stringa_a+1), 'Piombo', 100, 100, fornitore, 250, data_compravendita),
                   (CONCAT('aaaa', numero_stringa_a+2), 'Rame', 200, 200, fornitore, 600, data_compravendita);
                      
			INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
            VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 100),
				   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 100),
                   (lavoro, CONCAT('aaaa', numero_stringa_a+2), 200);
				
			SET numero_stringa_a = numero_stringa_a + 3;
		
        ELSEIF
			nome_lavoro = 'Installazione Cablaggio Telefonico'
            OR
            nome_lavoro = 'Riparazione Impianto Telefonico'
        THEN                
			INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
            VALUES (CONCAT('aaaa', numero_stringa_a), 'Piombo', 100, 100, fornitore, 250, data_compravendita),
                   (CONCAT('aaaa', numero_stringa_a+1), 'Rame', 200, 200, fornitore, 600, data_compravendita);
                      
			INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
            VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 100),
                   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 200);
				
			SET numero_stringa_a = numero_stringa_a + 2;
                
		ELSEIF
			nome_lavoro = 'Installazione Tubature Idrauliche'
            OR
            nome_lavoro = 'Riparazione Impianto Idraulico'
        THEN
			INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
            VALUES (CONCAT('aaaa', numero_stringa_a), 'Acciaio', 100, 100, fornitore, 250, data_compravendita),
                   (CONCAT('aaaa', numero_stringa_a+1), 'Ferro', 100, 100, fornitore, 200, data_compravendita);
                      
			INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
            VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 100),
				   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 100);
				
			SET numero_stringa_a = numero_stringa_a + 2;
                
        ELSEIF
			nome_lavoro = 'Pavimentazione'
            OR
            nome_lavoro = 'Riparazione Pavimento'
        THEN
			IF
				numero_fornitore = 1
            THEN                
				INSERT INTO Piastrelle(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Forma, Fuga)
                VALUES (CONCAT('dddd', numero_stringa_pia), 'Parquet', 10000, 10000, fornitore, 15000, data_compravendita, 'Rettangolare', 1);
                      
				INSERT INTO ImpiegoPiastrelle(Lavoro, Lotto_Piastrelle, Quantita)
                VALUES (lavoro, CONCAT('dddd', numero_stringa_pia), 10000);
				
				SET numero_stringa_pia = numero_stringa_pia + 1;
                
            ELSEIF
				numero_fornitore = 2
            THEN               
				INSERT INTO Piastrelle(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Forma, Fuga)
                VALUES (CONCAT('dddd', numero_stringa_pia), 'Piastrelle in Ceramica', 10000, 10000, fornitore, 15000, data_compravendita, 'Quadrata', 2);
                      
				INSERT INTO ImpiegoPiastrelle(Lavoro, Lotto_Piastrelle, Quantita)
                VALUES (lavoro, CONCAT('dddd', numero_stringa_pia), 10000);
				
				SET numero_stringa_pia = numero_stringa_pia + 1;
                
			ELSEIF
				numero_fornitore = 3
            THEN                
				INSERT INTO Piastrelle(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Forma, Fuga)
                VALUES (CONCAT('dddd', numero_stringa_pia), 'Piastrelle in Marmo', 10000, 10000, fornitore, 15000, data_compravendita, 'Quadrata', 2);
                      
				INSERT INTO ImpiegoPiastrelle(Lavoro, Lotto_Piastrelle, Quantita)
                VALUES (lavoro, CONCAT('dddd', numero_stringa_pia), 10000);
				
				SET numero_stringa_pia = numero_stringa_pia + 1;
                
			ELSEIF
				numero_fornitore = 4
            THEN
				INSERT INTO Piastrelle(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Forma, Fuga)
                VALUES (CONCAT('dddd', numero_stringa_pia), 'Piastrelle in Legno', 10000, 10000, fornitore, 12500, data_compravendita, 'Ottagonale', 1);
                      
				INSERT INTO ImpiegoPiastrelle(Lavoro, Lotto_Piastrelle, Quantita)
                VALUES (lavoro, CONCAT('dddd', numero_stringa_pia), 10000);
				
				SET numero_stringa_pia = numero_stringa_pia + 1;
			END IF;
		
        ELSEIF
			nome_lavoro = 'Costruzione Caldaia'
        THEN
			INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
			VALUES (CONCAT('aaaa', numero_stringa_a), 'Acciaio', 200, 200, fornitore, 500, data_compravendita);
                      
			INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
			VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 200);
				
			SET numero_stringa_a = numero_stringa_a + 1;
		
        ELSEIF
			nome_lavoro = 'Costruzione Camino'           
        THEN            
			IF
				numero_fornitore = 1
            THEN
                INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
				VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 10, 10, fornitore, 20, data_compravendita);
						  
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
				VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 10);
					
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Pietre(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Spessore)
                VALUES (CONCAT('eeee', numero_stringa_pie), 'Arenaria', 100, 100, fornitore, 1500, data_compravendita, 20);
                      
				INSERT INTO ImpiegoPietre(Lavoro, Lotto_Pietre, Quantita)
                VALUES (lavoro, CONCAT('eeee', numero_stringa_pie), 100);
				
				SET numero_stringa_pie = numero_stringa_pie + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Calcestruzzo', 100, 100, fornitore, 1010, data_compravendita, 'Cilindrica Cava');
                      
				INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 100);
				
				SET numero_stringa_m = numero_stringa_m + 1;
                
            ELSEIF
				numero_fornitore = 2
            THEN
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
				VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 10, 10, fornitore, 20, data_compravendita);
						  
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
				VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 10);
					
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Pietre(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Spessore)
                VALUES (CONCAT('eeee', numero_stringa_pie), 'Basalto', 100, 100, fornitore, 1500, data_compravendita, 20);
                      
				INSERT INTO ImpiegoPietre(Lavoro, Lotto_Pietre, Quantita)
                VALUES (lavoro, CONCAT('eeee', numero_stringa_pie), 100);
				
				SET numero_stringa_pie = numero_stringa_pie + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Terra Piena', 100, 100, fornitore, 1010, data_compravendita, 'Rettangolare Cava');
                      
				INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 100);
				
				SET numero_stringa_m = numero_stringa_m + 1;
                
			ELSEIF
				numero_fornitore = 3
            THEN                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
				VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 10, 10, fornitore, 20, data_compravendita);
						  
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
				VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 10);
					
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Blocco di Cemento', 50, 50, fornitore, 510, data_compravendita, 'Nessuna'),
					   (CONCAT('cccc', numero_stringa_m+1), 'Mattone in Laterizio', 50, 50, fornitore, 730, data_compravendita, 'Cilindrica Cava');
                      
				INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 50),
					   (lavoro, CONCAT('cccc', numero_stringa_m+1), 50);
				
				SET numero_stringa_m = numero_stringa_m + 2;
			
            ELSEIF
				numero_fornitore = 4
            THEN                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
				VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 10, 10, fornitore, 20, data_compravendita);
						  
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
				VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 10);
					
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Blocco di Cemento', 50, 50, fornitore, 510, data_compravendita, 'Nessuna'),
					   (CONCAT('cccc', numero_stringa_m+1), 'Mattone in Vetrocemento', 50, 50, fornitore, 730, data_compravendita, 'Nessuna');
                      
				INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 50),
					   (lavoro, CONCAT('cccc', numero_stringa_m+1), 50);
				
				SET numero_stringa_m = numero_stringa_m + 2;
			END IF;
            
		ELSEIF
            nome_lavoro = 'Riparazione Muro'
            OR
            nome_lavoro = 'Riparazione Crepa'
		THEN                
			INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
			VALUES (CONCAT('aaaa', numero_stringa_a), 'Gesso', 500, 500, fornitore, 750, data_compravendita);
                      
			INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
			VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 500);
				
			SET numero_stringa_a = numero_stringa_a + 1;
            
			IF
				numero_fornitore = 1
            THEN
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
				VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 10, 10, fornitore, 20, data_compravendita);
						  
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
				VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 10);
					
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Pietre(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Spessore)
                VALUES (CONCAT('eeee', numero_stringa_pie), 'Arenaria', 100, 100, fornitore, 1500, data_compravendita, 20);
                      
				INSERT INTO ImpiegoPietre(Lavoro, Lotto_Pietre, Quantita)
                VALUES (lavoro, CONCAT('eeee', numero_stringa_pie), 100);
				
				SET numero_stringa_pie = numero_stringa_pie + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Calcestruzzo', 1000, 1000, fornitore, 10010, data_compravendita, 'Cilindrica Cava');
                      
				INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 1000);
				
				SET numero_stringa_m = numero_stringa_m + 1;
                
            ELSEIF
				numero_fornitore = 2
            THEN                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
				VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 10, 10, fornitore, 20, data_compravendita);
						  
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
				VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 10);
					
				SET numero_stringa_a = numero_stringa_a + 1;
      
				INSERT INTO Pietre(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Spessore)
                VALUES (CONCAT('eeee', numero_stringa_pie), 'Basalto', 100, 100, fornitore, 1500, data_compravendita, 20);
                      
				INSERT INTO ImpiegoPietre(Lavoro, Lotto_Pietre, Quantita)
                VALUES (lavoro, CONCAT('eeee', numero_stringa_pie), 100);
				
				SET numero_stringa_pie = numero_stringa_pie + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Terra Piena', 1000, 1000, fornitore, 10100, data_compravendita, 'Rettangolare Cava');
                      
				INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 1000);
				
				SET numero_stringa_m = numero_stringa_m + 1;
                
			ELSEIF
				numero_fornitore = 3
            THEN                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
				VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 10, 10, fornitore, 20, data_compravendita);
						  
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
				VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 10);
					
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Blocco di Cemento', 500, 500, fornitore, 5100, data_compravendita, 'Nessuna'),
					   (CONCAT('cccc', numero_stringa_m+1), 'Mattone in Laterizio', 500, 500, fornitore, 7300, data_compravendita, 'Cilindrica Cava');
                      
				INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 500),
					   (lavoro, CONCAT('cccc', numero_stringa_m+1), 500);
				
				SET numero_stringa_m = numero_stringa_m + 2;
			
            ELSEIF
				numero_fornitore = 4
            THEN                
                
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
				VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 10, 10, fornitore, 20, data_compravendita);
						  
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
				VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 10);
					
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Blocco di Cemento', 500, 500, fornitore, 5100, data_compravendita, 'Nessuna'),
					   (CONCAT('cccc', numero_stringa_m+1), 'Mattone in Vetrocemento', 500, 500, fornitore, 7300, data_compravendita, 'Nessuna');
                      
				INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 500),
					   (lavoro, CONCAT('cccc', numero_stringa_m+1), 500);
				
				SET numero_stringa_m = numero_stringa_m + 2;
			END IF;
        
        ELSEIF
			nome_lavoro = 'Aggiunta Aperture'
            OR 
			nome_lavoro = 'Riparazione Aperture'
        THEN
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
				VALUES (CONCAT('aaaa', numero_stringa_a), 'Acciaio', 10, 10, fornitore, 100, data_compravendita),
					   (CONCAT('aaaa', numero_stringa_a+1), 'Ferro', 5, 5, fornitore, 7, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+2), 'Legno', 50, 50, fornitore, 50, data_compravendita),
                       (CONCAT('aaaa', numero_stringa_a+3), 'Vetro', 10, 10, fornitore, 75, data_compravendita);
						  
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
				VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 10),
					   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 5),
                       (lavoro, CONCAT('aaaa', numero_stringa_a+2), 50),
                       (lavoro, CONCAT('aaaa', numero_stringa_a+3), 10);
					
				SET numero_stringa_a = numero_stringa_a + 4;
		ELSEIF
			nome_lavoro = 'Aggiunta Mobilio'
            OR
            nome_lavoro = 'Riparazione Mobilio'
        THEN                
			INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
			VALUES (CONCAT('aaaa', numero_stringa_a), 'Ferro', 5, 5, fornitore, 7, data_compravendita),
                   (CONCAT('aaaa', numero_stringa_a+1), 'Legno', 50, 50, fornitore, 50, data_compravendita),
                   (CONCAT('aaaa', numero_stringa_a+2), 'Vetro', 5, 5, fornitore, 35, data_compravendita);
						  
			INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
			VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 5),
                   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 50),
                   (lavoro, CONCAT('aaaa', numero_stringa_a+2), 5);
					
			SET numero_stringa_a = numero_stringa_a + 3;
		
        ELSEIF
			nome_lavoro = 'Lavori di Falegnameria'
            OR
            nome_lavoro = 'Installazione Casetta da Giardino'
            OR
            nome_lavoro = 'Costruzione Grondaie'
            OR
            nome_lavoro = 'Riparazione Grondaie'
            OR
            nome_lavoro = 'Riparazione Casetta da Giardino'
        THEN
			INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
			VALUES (CONCAT('aaaa', numero_stringa_a), 'Acciaio', 5, 5, fornitore, 50, data_compravendita),
				   (CONCAT('aaaa', numero_stringa_a+1), 'Ferro', 5, 5, fornitore, 7, data_compravendita),
                   (CONCAT('aaaa', numero_stringa_a+2), 'Legno', 5, 5, fornitore, 5, data_compravendita);
						  
			INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
			VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 5),
				   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 5),
                   (lavoro, CONCAT('aaaa', numero_stringa_a+2), 5);
				
			SET numero_stringa_a = numero_stringa_a + 3;
                
		ELSEIF
			nome_lavoro = 'Installazione Riscaldamento'
        THEN
			INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
			VALUES (CONCAT('aaaa', numero_stringa_a), 'Acciaio', 1, 1, fornitore, 2, data_compravendita),
				   (CONCAT('aaaa', numero_stringa_a+1), 'Ferro', 1, 1, fornitore, 1, data_compravendita);
						  
			INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
			VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 1),
				   (lavoro, CONCAT('aaaa', numero_stringa_a+1), 1);
				
			SET numero_stringa_a = numero_stringa_a + 2;
        
        ELSEIF
			nome_lavoro = 'Installazione Vialetto'
        THEN
			IF
				numero_fornitore = 1
            THEN
				INSERT INTO Piastrelle(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Forma, Fuga)
                VALUES (CONCAT('dddd', numero_stringa_pia), 'Piastrelle in Argilla', 1000, 1000, fornitore, 1500, data_compravendita, 'Quadrata', 1);
                      
				INSERT INTO ImpiegoPiastrelle(Lavoro, Lotto_Piastrelle, Quantita)
                VALUES (lavoro, CONCAT('dddd', numero_stringa_pia), 1000);
				
				SET numero_stringa_pia = numero_stringa_pia + 1;
                
            ELSEIF
				numero_fornitore = 2
            THEN                
				INSERT INTO Piastrelle(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Forma, Fuga)
                VALUES (CONCAT('dddd', numero_stringa_pia), 'Piastrelle in Ceramica', 1000, 1000, fornitore, 1500, data_compravendita, 'Quadrata', 2);
                      
				INSERT INTO ImpiegoPiastrelle(Lavoro, Lotto_Piastrelle, Quantita)
                VALUES (lavoro, CONCAT('dddd', numero_stringa_pia), 1000);
				
				SET numero_stringa_pia = numero_stringa_pia + 1;
                
			ELSEIF
				numero_fornitore = 3
            THEN
				INSERT INTO Piastrelle(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Forma, Fuga)
                VALUES (CONCAT('dddd', numero_stringa_pia), 'Piastrelle in Marmo', 1000, 1000, fornitore, 1500, data_compravendita, 'Quadrata', 2);
                      
				INSERT INTO ImpiegoPiastrelle(Lavoro, Lotto_Piastrelle, Quantita)
                VALUES (lavoro, CONCAT('dddd', numero_stringa_pia), 1000);
				
				SET numero_stringa_pia = numero_stringa_pia + 1;
                
			ELSEIF
				numero_fornitore = 4
            THEN                
				INSERT INTO Piastrelle(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Forma, Fuga)
                VALUES (CONCAT('dddd', numero_stringa_pia), 'Piastrelle in Legno', 10000, 10000, fornitore, 12500, data_compravendita, 'Quadrata', 1);
                      
				INSERT INTO ImpiegoPiastrelle(Lavoro, Lotto_Piastrelle, Quantita)
                VALUES (lavoro, CONCAT('dddd', numero_stringa_pia), 10000);
				
				SET numero_stringa_pia = numero_stringa_pia + 1;
                
                INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Vetrocemento', 5, 5, fornitore, 73, data_compravendita, 'Nessuna');
                      
				INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 5);
				
				SET numero_stringa_m = numero_stringa_m + 1;
			END IF;
		
		ELSEIF
			nome_lavoro = 'Costruzione e Definizione Stanze'
		THEN            
			IF
				numero_fornitore = 1
            THEN
				INSERT INTO Pietre(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Spessore)
                VALUES (CONCAT('eeee', numero_stringa_pie), 'Arenaria', 5, 5, fornitore, 50, data_compravendita, 20);
                      
				INSERT INTO ImpiegoPietre(Lavoro, Lotto_Pietre, Quantita)
                VALUES (lavoro, CONCAT('eeee', numero_stringa_pie), 5);
				
				SET numero_stringa_pie = numero_stringa_pie + 1;
                
				INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
                VALUES (CONCAT('cccc', numero_stringa_m), 'Mattone in Vetrocemento', 5, 5, fornitore, 50, data_compravendita, 'Cilindrica Cava');
                      
				INSERT INTO ImpiegoMattoni(Lavoro, Lotto_Mattoni, Quantita)
                VALUES (lavoro, CONCAT('cccc', numero_stringa_m), 5);
				
				SET numero_stringa_m = numero_stringa_m + 1;
                
            ELSEIF
				numero_fornitore = 2
            THEN
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
				VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 10, 10, fornitore, 20, data_compravendita);
						  
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
				VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 10);
					
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Pietre(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Spessore)
                VALUES (CONCAT('eeee', numero_stringa_pie), 'Basalto', 5, 5, fornitore, 50, data_compravendita, 20);
                      
				INSERT INTO ImpiegoPietre(Lavoro, Lotto_Pietre, Quantita)
                VALUES (lavoro, CONCAT('eeee', numero_stringa_pie), 5);
				
				SET numero_stringa_pie = numero_stringa_pie + 1;
                
			ELSEIF
				numero_fornitore = 3
            THEN                               
				INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
				VALUES (CONCAT('aaaa', numero_stringa_a), 'Legno', 10, 10, fornitore, 20, data_compravendita);
						  
				INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
				VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 10);
					
				SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Pietre(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Spessore)
                VALUES (CONCAT('eeee', numero_stringa_pie), 'Marmo', 5, 5, fornitore, 100, data_compravendita, 20);
                      
				INSERT INTO ImpiegoPietre(Lavoro, Lotto_Pietre, Quantita)
                VALUES (lavoro, CONCAT('eeee', numero_stringa_pie), 5);
				
				SET numero_stringa_pie = numero_stringa_pie + 1;
			
            ELSEIF
				numero_fornitore = 4
            THEN                
                INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
				VALUES (CONCAT('aaaa', numero_stringa_a), 'Oro', 5, 5, fornitore, 1000, data_compravendita);
                
                INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
                VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 5);
                
                SET numero_stringa_a = numero_stringa_a + 1;
                
				INSERT INTO Pietre(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Spessore)
                VALUES (CONCAT('eeee', numero_stringa_pie), 'Marmo', 5, 5, fornitore, 100, data_compravendita, 20);
                      
				INSERT INTO ImpiegoPietre(Lavoro, Lotto_Pietre, Quantita)
                VALUES (lavoro, CONCAT('eeee', numero_stringa_pie), 5);
				
				SET numero_stringa_pie = numero_stringa_pie + 1;
			END IF;
            
		ELSEIF
			nome_lavoro = 'Installazione Antenna Parabolica'
		THEN            
			INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
			VALUES (CONCAT('aaaa', numero_stringa_a), 'Ferro', 1, 1, fornitore, 1, data_compravendita);
						  
			INSERT INTO ImpiegoAltriMateriali(Lavoro, Lotto_Altri_Materiali, Quantita)
			VALUES (lavoro, CONCAT('aaaa', numero_stringa_a), 1);
					
			SET numero_stringa_a = numero_stringa_a + 1;
            
		ELSEIF 
			nome_lavoro = 'Applicazione Intonaci Deumidificanti'
        THEN
			INSERT INTO Intonaco(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Colore)
                VALUES (CONCAT('bbbb', numero_stringa_i), 'Intonaco Deumidificato', 3000, 3000, fornitore, 9000, data_compravendita, 'Grigio Scuro');
                
                INSERT INTO ImpiegoIntonaco(Lavoro, Lotto_Intonaco, Quantita)
                VALUES (lavoro, CONCAT('bbbb', numero_stringa_i), 3000);
                       
				SET numero_stringa_i = numero_stringa_i + 1;
        END IF;
    END LOOP;
    CLOSE lista_lavori;
    
    INSERT INTO AltriMateriali(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto)
    VALUES (CONCAT('aaaa', numero_stringa_a), 'Acciaio', 10, 10, 'Sigma Company', 100, '2022-10-04'),
		   (CONCAT('aaaa', numero_stringa_a+1), 'Calcestruzzo', 10, 10, 'Sigma Company', 100, '2022-10-04'),
           (CONCAT('aaaa', numero_stringa_a+2), 'Cemento Armato', 10, 10, 'Sigma Company', 100, '2022-10-04'),
           (CONCAT('aaaa', numero_stringa_a+3), 'Ceramica', 10, 10, 'Sigma Company', 100, '2022-10-04'),
           (CONCAT('aaaa', numero_stringa_a+4), 'Ferro', 10, 10, 'Sigma Company', 100, '2022-10-04'),
           (CONCAT('aaaa', numero_stringa_a+5), 'Gesso', 10, 10, 'Sigma Company', 100, '2022-10-04'),
           (CONCAT('aaaa', numero_stringa_a+6), 'Legno', 10, 10, 'Sigma Company', 100, '2022-10-04'),
           (CONCAT('aaaa', numero_stringa_a+7), 'Oro', 1, 1, 'Sigma Company', 100, '2022-10-04'),
           (CONCAT('aaaa', numero_stringa_a+8), 'Piombo', 10, 10, 'Sigma Company', 100, '2022-10-04'),
           (CONCAT('aaaa', numero_stringa_a+9), 'Rame', 10, 10, 'Sigma Company', 100, '2022-10-04'),
           (CONCAT('aaaa', numero_stringa_a+10), 'Titanio', 10, 10, 'Sigma Company', 100, '2022-10-04'),
           (CONCAT('aaaa', numero_stringa_a+11), 'Vetro', 10, 10, 'Sigma Company', 100, '2022-10-04');
           
	INSERT INTO Intonaco(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Colore)
	VALUES (CONCAT('bbbb', numero_stringa_i), 'Intonaco a Base di Calce', 10, 10, 'Alpha Express', 200, '2022-10-05', 'Grigio Chiaro'),
		   (CONCAT('bbbb', numero_stringa_i+1), 'Intonaco a Base di Gesso', 10, 10, 'Alpha Express', 200, '2022-10-05', 'Grigio Chiaro'),
           (CONCAT('bbbb', numero_stringa_i+2), 'Intonaco a Base di Malta', 10, 10, 'Alpha Express', 200, '2022-10-05', 'Grigio Chiaro'),
           (CONCAT('bbbb', numero_stringa_i+3), 'Intonaco Cementizio', 10, 10, 'Alpha Express', 200, '2022-10-05', 'Grigio Chiaro'),
           (CONCAT('bbbb', numero_stringa_i+4), 'Intonaco Premiscelato', 10, 10, 'Alpha Express', 200, '2022-10-05', 'Grigio Chiaro'),
           (CONCAT('bbbb', numero_stringa_i+5), 'Intonaco Deumidificato', 10, 10, 'Alpha Express', 400, '2022-10-05', 'Grigio Chiaro');
           
	INSERT INTO Mattoni(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Alveolatura)
	VALUES (CONCAT('cccc', numero_stringa_m), 'Blocco di Cemento', 10, 10, 'Omega-Net', 200, '2022-10-06', 'Rettangolare Cava'),
		   (CONCAT('cccc', numero_stringa_m+1), 'Mattone in Calcestruzzo', 10, 10, 'Omega-Net', 200, '2022-10-06', 'Rettangolare Cava'),
           (CONCAT('cccc', numero_stringa_m+2), 'Mattone in Laterizio', 10, 10, 'Omega-Net', 200, '2022-10-06', 'Cilndrica Cava'),
           (CONCAT('cccc', numero_stringa_m+3), 'Mattone in Terra Piena', 10, 10, 'Omega-Net', 200, '2022-10-06', 'Nessuna'),
           (CONCAT('cccc', numero_stringa_m+4), 'Mattone in Vetrocemento', 10, 10, 'Omega-Net', 200, '2022-10-06', 'Nessuna');
           
	INSERT INTO Piastrelle(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Forma, Fuga)
	VALUES (CONCAT('dddd', numero_stringa_pia), 'Parquet', 10, 10, 'Beta Company', 400, '2022-10-07', 'Quadrata', 1),
		   (CONCAT('dddd', numero_stringa_pia+1), 'Piastrelle in Argilla', 10, 10, 'Beta Company', 300, '2022-10-07', 'Quadrata', 1),
           (CONCAT('dddd', numero_stringa_pia+2), 'Piastrelle in Ceramica', 10, 10, 'Beta Company', 300, '2022-10-07', 'Quadrata', 1),
           (CONCAT('dddd', numero_stringa_pia+3), 'Piastrelle in Legno', 10, 10, 'Beta Company', 300, '2022-10-07', 'Quadrata', 1),
           (CONCAT('dddd', numero_stringa_pia+4), 'Piastrelle in Marmo', 10, 10, 'Beta Company', 300, '2022-10-07', 'Quadrata', 1);
	
    INSERT INTO Pietre(Codice_Lotto, Nome, QuantitaComprata, QuantitaStoccata, Fornitore, Costo, DataAcquisto, Spessore)
	VALUES (CONCAT('eeee', numero_stringa_pie), 'Arenaria', 10, 10, 'Sigma Company', 100, '2022-10-10', 10),
		   (CONCAT('eeee', numero_stringa_pie+1), 'Basalto', 10, 10, 'Sigma Company', 100, '2022-10-10', 10),
           (CONCAT('eeee', numero_stringa_pie+2), 'Granito', 10, 10, 'Sigma Company', 100, '2022-10-10', 50),
		   (CONCAT('eeee', numero_stringa_pie+3), 'Marmo', 10, 10, 'Sigma Company', 100, '2022-10-10', 50);
END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS Popolamento_Turni_R;
DELIMITER $$
CREATE PROCEDURE Popolamento_Turni_R()
BEGIN
	DECLARE finito INT DEFAULT 0;
    DECLARE lavoro INT DEFAULT 0;
    DECLARE nome_lavoro VARCHAR(50) DEFAULT '';
    DECLARE giorni INT DEFAULT 0;
    DECLARE data_inizio, data_fine DATE DEFAULT NULL;

	DECLARE lista_lavori CURSOR FOR
		SELECT L.Codice_Lavoro, L.TipologiaDiLavoro
        FROM Lavoro L;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
    
	OPEN lista_lavori;
    ciclo: LOOP
		FETCH lista_lavori INTO lavoro, nome_lavoro;
		IF 
			finito = 1
		THEN 
			LEAVE ciclo;
		END IF;
        
		IF
			nome_lavoro = 'Ispezione Fondamenta'
			OR
			nome_lavoro = 'Ispezione Intelaiatura'
			OR
			nome_lavoro = 'Ispezione Chiusura'
			OR
			nome_lavoro = 'Ispezione Fissaggio'
			OR
			nome_lavoro = 'Ispezione Adattamento'
			OR
			nome_lavoro = 'Ispezione Caldaia'
			OR
			nome_lavoro = 'Ispezione Crepa'
			OR
			nome_lavoro = 'Ispezione Umidità di Risalita'
			OR
			nome_lavoro = 'Ispezione Umidità Esterna'
			OR
			nome_lavoro = 'Ispezione Danni da Alluvione'
			OR
			nome_lavoro = 'Ispezione Danni da Calore'
			OR
            nome_lavoro = 'Ispezione Finale'
		THEN
			INSERT INTO Turni_Di_Lavoro_Responsabile(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
				SELECT L.Codice_Lavoro, R.Responsabile, '8:00:00' AS OrarioInizio, '18:00:00' AS OrarioFine, 2 AS OrePausa, 7 AS GiornoLibero
                FROM Responsabilita R INNER JOIN ProgettoEdilizio PE ON R.Progetto = PE.ID_Progetto
                                      INNER JOIN Lavoro L ON L.Progetto = PE.ID_Progetto
				WHERE L.Codice_Lavoro = lavoro;
        END IF;
    END LOOP;
    CLOSE lista_lavori;
END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS Popolamento_Turni_CL1;
DELIMITER $$
CREATE PROCEDURE Popolamento_Turni_CL1()
BEGIN
	DECLARE finito INT DEFAULT 0;
    DECLARE lavoro INT DEFAULT 0;
    DECLARE nome_lavoro VARCHAR(50) DEFAULT '';

	DECLARE lista_lavori CURSOR FOR
		SELECT L.Codice_Lavoro, L.TipologiaDiLavoro
        FROM Lavoro L
        WHERE L.DataFine <= '2017-05-02';
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
    
	OPEN lista_lavori;
    ciclo: LOOP
		FETCH lista_lavori INTO lavoro, nome_lavoro;
			IF 
                finito = 1
            THEN 
                LEAVE ciclo;
            END IF;
            IF
                nome_lavoro <> 'Ispezione Fondamenta'
                AND
                nome_lavoro <> 'Ispezione Intelaiatura'
                AND
                nome_lavoro <> 'Ispezione Chiusura'
                AND
                nome_lavoro <> 'Ispezione Fissaggio'
                AND
                nome_lavoro <> 'Ispezione Adattamento'
                AND
                nome_lavoro <> 'Ispezione Caldaia'
                AND
                nome_lavoro <> 'Ispezione Crepa'
                AND
                nome_lavoro <> 'Ispezione Umidità di Risalita'
                AND
                nome_lavoro <> 'Ispezione Umidità Esterna'
                AND
                nome_lavoro <> 'Ispezione Danni da Alluvione'
                AND
                nome_lavoro <> 'Ispezione Danni da Calore'	
                AND
                nome_lavoro <> 'Ispezione Finale'
            THEN
				IF
					lavoro % 2 = 0
				THEN
					INSERT INTO Turni_Di_Lavoro_Capocantiere(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
					VALUES (lavoro, 'NPLVNI85A26L253C', '8:00:00', '18:00:00', 2, 7),
							(lavoro, 'PCCLVE75C27M172B', '8:00:00', '18:00:00', 2, 7);
                                    
					INSERT INTO Turni_Di_Lavoro_Lavoratore(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
					VALUES (lavoro, 'LROFND92P09G491B', '8:00:00', '18:00:00', 2, 7),
							(lavoro, 'BRSRMG88T24G491Q', '8:00:00', '18:00:00', 2, 7),                                        
							(lavoro, 'CRVLGU93E17E202N', '8:00:00', '18:00:00', 2, 7),                                        
							(lavoro, 'GTTTMS93B17I726F', '8:00:00', '18:00:00', 2, 7),                                        
							(lavoro, 'MNCDLM88T70G491Y', '8:00:00', '18:00:00', 2, 7);
					
                    ELSEIF
                        lavoro % 2 <> 0
                    THEN
                        INSERT INTO Turni_Di_Lavoro_Capocantiere(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
						VALUES (lavoro, 'RSSCMN80C60I872L', '8:00:00', '18:00:00', 2, 7),                                        
                                (lavoro, 'LROVIA83P57G916G', '8:00:00', '18:00:00', 2, 7);
                                    
						INSERT INTO Turni_Di_Lavoro_Lavoratore(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
						VALUES (lavoro, 'TRVPIO83B02G882Y', '8:00:00', '18:00:00', 2, 7),                                        
                                (lavoro, 'FRRFBL80C50A071O', '8:00:00', '18:00:00', 2, 7),                                        
                                (lavoro, 'MNNNLM85S01E715V', '8:00:00', '18:00:00', 2, 7),                                       
                                (lavoro, 'GRCRFN88E24G491V', '8:00:00', '18:00:00', 2, 7),                                        
                                (lavoro, 'CSTLNR92B44G491P', '8:00:00', '18:00:00', 2, 7);
                    END IF;
                END IF;
    END LOOP;
    CLOSE lista_lavori;
END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS Popolamento_Turni_CL2;
DELIMITER $$
CREATE PROCEDURE Popolamento_Turni_CL2()
BEGIN
	DECLARE finito INT DEFAULT 0;
    DECLARE lavoro INT DEFAULT 0;
    DECLARE numero_randomizzazione INT DEFAULT 1;
    DECLARE nome_lavoro VARCHAR(50) DEFAULT '';
    
	DECLARE lista_lavori CURSOR FOR
		SELECT L.Codice_Lavoro, L.TipologiaDiLavoro
        FROM Lavoro L
        WHERE L.DataFine > '2017-05-02' 
			 AND
		 	  L.DataFine <= '2022-11-21'; 
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
    
    OPEN lista_lavori;
        ciclo: LOOP
            FETCH lista_lavori INTO lavoro, nome_lavoro;
				IF 
                    finito = 1
                THEN 
                    LEAVE ciclo;
                END IF;
                
                IF
                    nome_lavoro <> 'Ispezione Fondamenta'
                    AND
                    nome_lavoro <> 'Ispezione Intelaiatura'
                    AND
                    nome_lavoro <> 'Ispezione Chiusura'
                    AND
                    nome_lavoro <> 'Ispezione Fissaggio'
                    AND
                    nome_lavoro <> 'Ispezione Adattamento'
                    AND
                    nome_lavoro <> 'Ispezione Caldaia'
                    AND
                    nome_lavoro <> 'Ispezione Crepa'
                    AND
                    nome_lavoro <> 'Ispezione Umidità di Risalita'
                    AND
                    nome_lavoro <> 'Ispezione Umidità Esterna'
                    AND
                    nome_lavoro <> 'Ispezione Danni da Alluvione'
                    AND
                    nome_lavoro <> 'Ispezione Danni da Calore'	
                    AND
                    nome_lavoro <> 'Ispezione Finale'
                THEN  
                        IF
                            numero_randomizzazione = 1
                        THEN
								INSERT INTO Turni_Di_Lavoro_Capocantiere(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
								VALUES (lavoro, 'NPLVNI85A26L253C', '8:00:00', '18:00:00', 2, 7),
                                        (lavoro, 'PCCLVE75C27M172B', '8:00:00', '18:00:00', 2, 7);
                                    
								INSERT INTO Turni_Di_Lavoro_Lavoratore(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
								VALUES (lavoro, 'LROFND92P09G491B', '8:00:00', '18:00:00', 2, 7),
                                        (lavoro, 'BRSRMG88T24G491Q', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'CRVLGU93E17E202N', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'GTTTMS93B17I726F', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'MNCDLM88T70G491Y', '8:00:00', '18:00:00', 2, 7);
                                                                
                        ELSEIF 
                            numero_randomizzazione = 2
                        THEN
								INSERT INTO Turni_Di_Lavoro_Capocantiere(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
								VALUES (lavoro, 'MNFBRD65S27A393X', '8:00:00', '18:00:00', 2, 7),
                                        (lavoro, 'LCCLEI88S28D643Y', '8:00:00', '18:00:00', 2, 7);
                                                                            
								INSERT INTO Turni_Di_Lavoro_Lavoratore(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
								VALUES (lavoro, 'BRGPTT92H62A944J', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'VLDGRC84C20E864J', '8:00:00', '18:00:00', 2, 7),
                                        (lavoro, 'MNCDNN90D20A561S', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'NPLGLI87E15G702E', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'TSCCAI84L16A241W', '8:00:00', '18:00:00', 2, 7);
                                                                               
                        ELSEIF 
                            numero_randomizzazione = 3
                        THEN
								INSERT INTO Turni_Di_Lavoro_Capocantiere(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
								VALUES (lavoro, 'RSSCMN80C60I872L', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'LROVIA83P57G916G', '8:00:00', '18:00:00', 2, 7);
                                    
								INSERT INTO Turni_Di_Lavoro_Lavoratore(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
								VALUES (lavoro, 'TRVPIO83B02G882Y', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'FRRFBL80C50A071O', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'MNNNLM85S01E715V', '8:00:00', '18:00:00', 2, 7),                                       
                                        (lavoro, 'GRCRFN88E24G491V', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'CSTLNR92B44G491P', '8:00:00', '18:00:00', 2, 7);                                       
                                    
                        ELSEIF 
                            numero_randomizzazione = 4
                        THEN
								INSERT INTO Turni_Di_Lavoro_Capocantiere(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
								VALUES (lavoro, 'DVDRLA79E16F934P', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'NDRDRD82M10H501C', '8:00:00', '18:00:00', 2, 7);
                                                                            
								INSERT INTO Turni_Di_Lavoro_Lavoratore(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
								VALUES (lavoro, 'FRRVNT92B06C631A', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'CSTBCC94C18B251C', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'PRTRMN86D18E451W', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'PNCGNR80A16E432R', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'NPLLNE80A16F025F', '8:00:00', '18:00:00', 2, 7);
								
                        ELSEIF 
                            numero_randomizzazione = 5
                        THEN
								INSERT INTO Turni_Di_Lavoro_Capocantiere(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
								VALUES (lavoro, 'NDRDRD82M10H501C', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'NPLVNI85A26L253C', '8:00:00', '18:00:00', 2, 7);
                                        
                                    
								INSERT INTO Turni_Di_Lavoro_Lavoratore(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
								VALUES (lavoro, 'LMBLVN80A16G636V', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'BCHSRI91T15G832G', '8:00:00', '18:00:00', 2, 7),                                       
                                        (lavoro, 'CLBBRD95A24L522T', '8:00:00', '18:00:00', 2, 7),                                       
                                        (lavoro, 'MZZRMN79H14E715U', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'CTTLLD81B10H570C', '8:00:00', '18:00:00', 2, 7);
                                                                               
                        ELSEIF 
                            numero_randomizzazione = 6
                        THEN
								INSERT INTO Turni_Di_Lavoro_Capocantiere(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
								VALUES (lavoro, 'DVDRLA79E16F934P', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'PCCLVE75C27M172B', '8:00:00', '18:00:00', 2, 7);
                                    
								INSERT INTO Turni_Di_Lavoro_Lavoratore(Lavoro, CodiceFiscale, OrarioInizio, OrarioFine, OrePausa, GiornoLibero)
								VALUES (lavoro, 'FRHLRT78L18A561X', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'KCHRTM88H19G491Y', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'VLDPTR88B10G491X', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'FLPMRK88L29L736B', '8:00:00', '18:00:00', 2, 7),                                        
                                        (lavoro, 'FLLLDA84T14L736J', '8:00:00', '18:00:00', 2, 7);
                        END IF;
                    END IF;
                IF
                    numero_randomizzazione >= 6
                THEN
                    SET numero_randomizzazione = 1;
                ELSEIF
                    numero_randomizzazione < 6
                THEN
                    SET numero_randomizzazione = numero_randomizzazione+1;
                END IF;    
        END LOOP;
        CLOSE lista_lavori;
END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS Popolamento_Soffitto_Pavimentazione;
DELIMITER $$
CREATE PROCEDURE Popolamento_Soffitto_Pavimentazione()
BEGIN
	DECLARE finito INT DEFAULT 0;
    DECLARE lotto, nome_lavoro VARCHAR(50) DEFAULT '';
    DECLARE edificio INT DEFAULT 0;
    
	DECLARE cursore CURSOR FOR
		SELECT IP.Lotto_Piastrelle AS Lotto, L.TipologiaDiLavoro, PE.Edificio
		FROM ImpiegoPiastrelle IP INNER JOIN Lavoro L ON IP.Lavoro = L.Codice_Lavoro
								  INNER JOIN ProgettoEdilizio PE ON L.Progetto = PE.ID_Progetto
		WHERE L.TipologiaDiLavoro = 'Pavimentazione'
			 AND
              PE.DataInizio < '2022-11-01'
		UNION
		SELECT IP.Lotto_Pietre AS Lotto, L.TipologiaDiLavoro, PE.Edificio
		FROM ImpiegoPietre IP INNER JOIN Lavoro L ON IP.Lavoro = L.Codice_Lavoro
							  INNER JOIN ProgettoEdilizio PE ON L.Progetto = PE.ID_Progetto
		WHERE L.TipologiaDiLavoro = 'Costruzione e Definizione Stanze'
			AND
			  PE.DataInizio < '2022-11-01';
	 DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
	
    OPEN cursore;
    ciclo: LOOP
		FETCH cursore INTO lotto, nome_lavoro, edificio;
        IF
			finito = 1
        THEN
			LEAVE ciclo;
        END IF;     
        
        IF
			nome_lavoro = 'Pavimentazione'
        THEN  
			UPDATE Vano
			SET Pavimentazione = lotto
			WHERE Pianta IN (SELECT P.Codice_Pianta
							 FROM Pianta P
							 WHERE P.Edificio = edificio);
        ELSEIF
			nome_lavoro = 'Costruzione e Definizione Stanze'
        THEN		   
            INSERT INTO Soffitto(Vano, Lotto_Pietre)
				SELECT V.Codice_Vano, lotto
				FROM Vano V INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
                WHERE P.Edificio = edificio;
        END IF;
    END LOOP;
    CLOSE cursore;
END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS Popolamento_Strato;
DELIMITER $$
CREATE PROCEDURE Popolamento_Strato()
BEGIN
	DECLARE finito INT DEFAULT 0;
    DECLARE lotto, nome_lavoro VARCHAR(50) DEFAULT '';
    DECLARE muro INT DEFAULT 0;
    
	DECLARE cursore_intonaci CURSOR FOR
		SELECT II.Lotto_Intonaco AS Lotto, L.TipologiaDiLavoro, M.Codice_Muro
		FROM ImpiegoIntonaco II INNER JOIN Lavoro L ON II.Lavoro = L.Codice_Lavoro
								INNER JOIN ProgettoEdilizio PE ON L.Progetto = PE.ID_Progetto
								INNER JOIN Edificio E ON PE.Edificio = E.ID
								INNER JOIN Pianta P ON E.ID = P.Edificio
                                INNER JOIN Vano V ON V.Pianta = P.Codice_Pianta
								INNER JOIN Muro M ON M.Vano1 = V.Codice_Vano OR M.Vano2 = V.Codice_Vano
		WHERE L.TipologiaDiLavoro = 'Costruzione Pareti Interne'
			 AND
			  M.Vano2 IS NOT NULL
			 AND
			  PE.DataInizio < '2022-11-01'
		UNION
		SELECT II.Lotto_Intonaco AS Lotto, L.TipologiaDiLavoro, M.Codice_Muro
		FROM ImpiegoIntonaco II INNER JOIN Lavoro L ON II.Lavoro = L.Codice_Lavoro
								INNER JOIN ProgettoEdilizio PE ON L.Progetto = PE.ID_Progetto
								INNER JOIN Edificio E ON PE.Edificio = E.ID
								INNER JOIN Pianta P ON E.ID = P.Edificio
								INNER JOIN Vano V ON V.Pianta = P.Codice_Pianta
								INNER JOIN Muro M ON M.Vano1 = V.Codice_Vano OR M.Vano2 = V.Codice_Vano
		WHERE L.TipologiaDiLavoro = 'Costruzione Pareti Esterne'
			 AND
			  M.Vano2 IS NULL
			 AND
			  PE.DataInizio < '2022-11-01';
	 DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
	
    OPEN cursore_intonaci;
    ciclo: LOOP
		FETCH cursore_intonaci INTO lotto, nome_lavoro, muro;
        IF
			finito = 1
        THEN
			LEAVE ciclo;
        END IF;     
        
        IF
			nome_lavoro = 'Costruzione Pareti Esterne'
        THEN  
			INSERT INTO Strato(Muro, Lotto_Intonaco, Spessore)
            VALUES (muro, lotto, 2);
            
        ELSEIF
			nome_lavoro = 'Costruzione Pareti Interne'
        THEN		   
            INSERT INTO Strato(Muro, Lotto_Intonaco, Spessore)
            VALUES (muro, lotto, 1.5);
        END IF;
    END LOOP;
    CLOSE cursore_intonaci;
END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS Popolamento_Disposizione;
DELIMITER $$
CREATE PROCEDURE Popolamento_Disposizione()
BEGIN
	DECLARE finito INT DEFAULT 0;
    DECLARE lotto, nome_lavoro VARCHAR(50) DEFAULT '';
    DECLARE muro INT DEFAULT 0;
    DECLARE bit INT DEFAULT 0;
    DECLARE disposizione VARCHAR(50) DEFAULT '';
    
	DECLARE cursore CURSOR FOR
		SELECT IM.Lotto_Mattoni AS Lotto, L.TipologiaDiLavoro, M.Codice_Muro
		FROM ImpiegoMattoni IM INNER JOIN Lavoro L ON IM.Lavoro = L.Codice_Lavoro
							   INNER JOIN ProgettoEdilizio PE ON L.Progetto = PE.ID_Progetto
							   INNER JOIN Edificio E ON PE.Edificio = E.ID
							   INNER JOIN Pianta P ON E.ID = P.Edificio
							   INNER JOIN Vano V ON V.Pianta = P.Codice_Pianta
							   INNER JOIN Muro M ON M.Vano1 = V.Codice_Vano OR M.Vano2 = V.Codice_Vano
		WHERE L.TipologiaDiLavoro = 'Costruzione Pareti Interne'
			 AND
			  M.Vano2 IS NOT NULL
			 AND
			  PE.DataInizio < '2022-11-01'
		UNION
		SELECT IM.Lotto_Mattoni AS Lotto, L.TipologiaDiLavoro, M.Codice_Muro
		FROM ImpiegoMattoni IM INNER JOIN Lavoro L ON IM.Lavoro = L.Codice_Lavoro
							   INNER JOIN ProgettoEdilizio PE ON L.Progetto = PE.ID_Progetto
							   INNER JOIN Edificio E ON PE.Edificio = E.ID
							   INNER JOIN Pianta P ON E.ID = P.Edificio
							   INNER JOIN Vano V ON V.Pianta = P.Codice_Pianta
							   INNER JOIN Muro M ON M.Vano1 = V.Codice_Vano OR M.Vano2 = V.Codice_Vano
		WHERE L.TipologiaDiLavoro = 'Costruzione Pareti Esterne'
			 AND
			  M.Vano2 IS NULL
			 AND
			  PE.DataInizio < '2022-11-01'
		UNION
        SELECT IP.Lotto_Pietre AS Lotto, L.TipologiaDiLavoro, M.Codice_Muro
		FROM ImpiegoPietre IP INNER JOIN Lavoro L ON IP.Lavoro = L.Codice_Lavoro
							  INNER JOIN ProgettoEdilizio PE ON L.Progetto = PE.ID_Progetto
							  INNER JOIN Edificio E ON PE.Edificio = E.ID
							  INNER JOIN Pianta P ON E.ID = P.Edificio
							  INNER JOIN Vano V ON V.Pianta = P.Codice_Pianta
							  INNER JOIN Muro M ON M.Vano1 = V.Codice_Vano OR M.Vano2 = V.Codice_Vano
		WHERE L.TipologiaDiLavoro = 'Costruzione e Definizione Stanze'
			 AND
			  PE.DataInizio < '2022-11-01';
		
	 DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
	
    OPEN cursore;
    ciclo: LOOP
		FETCH cursore INTO lotto, nome_lavoro, muro;
        IF
			finito = 1
        THEN
			LEAVE ciclo;
        END IF;     
        
        IF
			nome_lavoro = 'Costruzione Pareti Esterne'
        THEN  
			INSERT INTO Muratura(Muro, Lotto_Mattoni)
            VALUES (muro, lotto);
            
        ELSEIF
			nome_lavoro = 'Costruzione Pareti Interne'
        THEN		   
            INSERT INTO Muratura(Muro, Lotto_Mattoni)
            VALUES (muro, lotto);
            
		ELSEIF
			nome_lavoro = 'Costruzione e Definizione Stanze'
		THEN
			IF 
				bit = 0
			THEN
				SET disposizione = 'Verticale';
                SET bit = 1;
                
				INSERT INTO Decorazione(Muro, Lotto_Pietre, Disposizione)
				VALUES (muro, lotto, disposizione);
			ELSEIF
				bit = 1
			THEN
				SET disposizione = 'Orizzontale';
                SET bit = 0;
                
				INSERT INTO Decorazione(Muro, Lotto_Pietre, Disposizione)
				VALUES (muro, lotto, disposizione);
			END IF;
        END IF;
    END LOOP;
    CLOSE cursore;
END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS Popolamento_Sensori;
DELIMITER $$
CREATE PROCEDURE Popolamento_Sensori()
BEGIN
    DECLARE finito INT DEFAULT 0;
    DECLARE vano INT DEFAULT 0;
    DECLARE codice INT DEFAULT 1;
    DECLARE muri_esterni INT DEFAULT 0;
    DECLARE edificio_attuale, edificio_precedente INT DEFAULT 0;
    DECLARE stato_edificio FLOAT DEFAULT 0;
    DECLARE sensori_esterni BOOL DEFAULT FALSE;
    
    DECLARE cursore_vani CURSOR FOR
		SELECT V.Codice_Vano
        FROM Vano V INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
					INNER JOIN ProgettoEdilizio PE ON P.Edificio = PE.ID_Progetto
		WHERE PE.DataInizio < '2022-11-01'
        ORDER BY V.Codice_Vano ASC;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finito = 1;
	
    SET edificio_precedente = (SELECT P.Edificio
							   FROM Pianta P INNER JOIN Vano V ON P.Codice_Pianta = V.Pianta
							   WHERE V.Codice_Vano = (SELECT MIN(V1.Codice_Vano)
													  FROM Vano V1));
	
    SET stato_edificio = (SELECT E.Stato 
						  FROM Edificio E
                          WHERE E.ID = edificio_precedente);
    
    OPEN cursore_vani;
    ciclo: LOOP
		FETCH cursore_vani INTO vano;
		IF
			finito = 1
		THEN
			LEAVE ciclo;
		END IF;
        
        SET edificio_attuale = (SELECT P.Edificio
							    FROM Pianta P INNER JOIN Vano V ON P.Codice_Pianta = V.Pianta
							    WHERE V.Codice_Vano = vano);
		IF
			edificio_attuale <> edificio_precedente
		THEN
			SET edificio_precedente = edificio_attuale;
            SET sensori_esterni = FALSE;
            SET stato_edificio = (SELECT E.Stato 
								  FROM Edificio E
								  WHERE E.ID = edificio_attuale);
        END IF;
        
		
		SET muri_esterni = (SELECT IFNULL(COUNT(*), 0)
						    FROM (SELECT M.Codice_Muro
							      FROM Muro M INNER JOIN Vano V ON M.Vano1 = V.Codice_Vano OR M.Vano2 = V.Codice_Vano
							       WHERE M.Vano2 IS NULL
									    AND
									     V.Codice_Vano = vano) AS D);
        
		INSERT INTO Sensore(Codice_Seriale, Categoria, UnitaMisura, Alert, Vano)
        VALUES (codice, 'Termostato Interno Caldo', '°C', 40, vano),
			   (codice, 'Termostato Interno Freddo', '°C', -10, vano),
               (codice+1, 'Igrometro Interno', 'kg/m³', 60, vano);
		
        SET codice = codice + 2;
        
        IF
			muri_esterni > 0
            AND
            sensori_esterni = FALSE
		THEN
			INSERT INTO Sensore(Codice_Seriale, Categoria, UnitaMisura, Alert, Vano)
			VALUES (codice, 'Accelerometro X', 'm', 0.05, vano),
				   (codice, 'Accelerometro Y', 'm', 0.05, vano),
                   (codice, 'Accelerometro Z', 'm', 0.05, vano),
                   (codice+1, 'Giroscopio X', '°/s', 0.05, vano),
				   (codice+1, 'Giroscopio Y', '°/s', 0.05, vano),
                   (codice+1, 'Giroscopio Z', '°/s', 0.05, vano),
                   (codice+2, 'Termostato Esterno Caldo', '°C', 44, vano),
				   (codice+2, 'Termostato Esterno Freddo', '°C', -20, vano),
                   (codice+3, 'Igrometro Esterno', 'kg/m³', 70, vano),
                   (codice+4, 'Pluviometro', 'mm', 100, vano);

			SET codice = codice + 5;   
			SET sensori_esterni = TRUE; 
        END IF;
    END LOOP;
    CLOSE cursore_vani;
END $$
DELIMITER ;


DROP PROCEDURE IF EXISTS Popolamento_Registrazione_Danno;
DELIMITER $$
CREATE PROCEDURE Popolamento_Registrazione_Danno()
BEGIN
	DECLARE finito INT DEFAULT 0;
    DECLARE sensore_attuale, max_sensore, numero INT DEFAULT 0;
    DECLARE tipo_sensore VARCHAR(50) DEFAULT '';
    DECLARE data_registrazione DATE DEFAULT NULL;
    DECLARE valore FLOAT DEFAULT 0;
    DECLARE muro INT DEFAULT 0;
    
    SET max_sensore = (
						SELECT MAX(S.Codice_Seriale)
                        FROM Sensore S
					  );
                      
    SET sensore_attuale = 1;
    SET numero = 1;
    
    SET tipo_sensore = (
							SELECT D.Categoria
							FROM (
							 		SELECT S.Codice_Seriale, S.Categoria, DENSE_RANK() OVER(ORDER BY S.Codice_Seriale, S.Categoria ASC) AS Posizione
									FROM Sensore S
							     ) AS D
							WHERE D.Posizione = numero
					   );
    
	IF
		sensore_attuale < max_sensore
    THEN
		SET data_registrazione = (
								SELECT PE.DataFine
								FROM Sensore S INNER JOIN Vano V ON S.Vano = V.Codice_Vano  		
											   INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
											   INNER JOIN ProgettoEdilizio PE ON P.Edificio = PE.ID_Progetto
								WHERE PE.DataFine <= '2022-11-01'
									 AND
									  PE.DataFine IS NOT NULL
									 AND
                                      S.Codice_Seriale = sensore_attuale
									 AND 
									  S.Categoria = tipo_sensore
							 );
		SET data_registrazione = DATE_ADD(data_registrazione, INTERVAL 1 DAY);
                             
		ciclo: LOOP
			IF
				data_registrazione > '2022-11-01'
			THEN
				IF
					finito = 1 
				THEN
					LEAVE ciclo;
				END IF;
                
				SET numero = numero + 1;
                    
				SET sensore_attuale = (
										SELECT D.Codice_Seriale
										FROM (
												SELECT S.Codice_Seriale, S.Categoria, DENSE_RANK() OVER(ORDER BY S.Codice_Seriale, S.Categoria ASC) AS Posizione
												FROM Sensore S
											 ) AS D
										WHERE D.Posizione = numero
									  );
				
                SET tipo_sensore = (
								 	 SELECT D.Categoria
									 FROM (
									 		SELECT S.Codice_Seriale, S.Categoria, DENSE_RANK() OVER(ORDER BY S.Codice_Seriale, S.Categoria ASC) AS Posizione
											FROM Sensore S
									      ) AS D
									 WHERE D.Posizione = numero
								   );
                
				SET data_registrazione = (
											SELECT PE.DataFine
											FROM Sensore S INNER JOIN Vano V ON S.Vano = V.Codice_Vano  		
														   INNER JOIN Pianta P ON V.Pianta = P.Codice_Pianta
														   INNER JOIN ProgettoEdilizio PE ON P.Edificio = PE.ID_Progetto
											WHERE PE.DataFine <= '2022-11-01'
												 AND
												  PE.DataFine IS NOT NULL
												 AND
												  S.Codice_Seriale = sensore_attuale
												 AND 
                                                  S.Categoria = tipo_sensore
										);
				
                SET data_registrazione = DATE_ADD(data_registrazione, INTERVAL 1 DAY);
                
				IF 
					sensore_attuale = max_sensore
				THEN
					SET finito = 1;
				END IF;
			END IF;
        
        SET valore = 0;
			
			IF
				tipo_sensore = 'Accelerometro X'
                OR
                tipo_sensore = 'Accelerometro Y'
                OR
                tipo_sensore = 'Accelerometro Z'
            THEN 
				SET valore = 0.00001;
            ELSEIF
				tipo_sensore = 'Giroscopio X'
                OR
                tipo_sensore = 'Giroscopio Y'
                OR
                tipo_sensore = 'Giroscopio Z'
            THEN
				SET valore = 0.000001;
            ELSEIF
				tipo_sensore = 'Termostato Esterno Caldo'
                OR
                tipo_sensore = 'Termostato Esterno Freddo'
            THEN
				IF
					MONTH(data_registrazione) <= 2
                    OR
                    MONTH(data_registrazione) >= 11
                THEN
					SET valore = -5;
				ELSEIF
					MONTH(data_registrazione) = 3
				THEN
					SET valore = 15;
				ELSEIF
					MONTH(data_registrazione) = 4
				THEN
					SET valore = 20;
				ELSEIF
					MONTH(data_registrazione) = 5
				THEN
					SET valore = 25;
				ELSEIF
					MONTH(data_registrazione) = 6
				THEN
					SET valore = 30;
				ELSEIF
					MONTH(data_registrazione) = 7
                    OR
                    MONTH(data_registrazione) = 8
				THEN
					SET valore = 35;
				ELSEIF
					MONTH(data_registrazione) = 9
                    OR
                    MONTH(data_registrazione) = 10
                THEN
					SET valore = 20;
                END IF;
			ELSEIF
				tipo_sensore = 'Termostato Interno Caldo'
                OR
                tipo_sensore = 'Termostato Interno Freddo'
			THEN
				IF
					MONTH(data_registrazione) <= 2
                    OR
                    MONTH(data_registrazione) >= 11
                THEN
					SET valore = 0;
				ELSEIF
					MONTH(data_registrazione) = 3
				THEN
					SET valore = 15;
				ELSEIF
					MONTH(data_registrazione) = 4
				THEN
					SET valore = 20;
				ELSEIF
					MONTH(data_registrazione) = 5
				THEN
					SET valore = 25;
				ELSEIF
					MONTH(data_registrazione) = 6
				THEN
					SET valore = 30;
				ELSEIF
					MONTH(data_registrazione) = 7
                    OR
                    MONTH(data_registrazione) = 8
				THEN
					SET valore = 30;
				ELSEIF
					MONTH(data_registrazione) = 9
                    OR
                    MONTH(data_registrazione) = 10
                THEN
					SET valore = 20;
                END IF;
			ELSEIF
				tipo_sensore = 'Igrometro Interno'
                OR
                tipo_sensore = 'Igrometro Esterno'
            THEN
				IF
					(MONTH(data_registrazione) >= 1
                     AND
                     MONTH(data_registrazione) <= 4)
                    OR
                    MONTH(data_registrazione) = 11
                    OR
                    MONTH(data_registrazione) = 12
                THEN
					SET valore = 55;
				ELSEIF
					MONTH(data_registrazione) >= 5
                    AND
                    MONTH(data_registrazione) <= 8
				THEN
					SET valore = 45;
				ELSEIF
					MONTH(data_registrazione) = 9
                    OR
                    MONTH(data_registrazione) = 10
                THEN
					SET valore = 50;
				END IF;
			ELSEIF
				tipo_sensore = 'Pluviometro'
            THEN
				IF
					(MONTH(data_registrazione) >= 1
                     AND
                     MONTH(data_registrazione) <= 4)
                    OR
                    (MONTH(data_registrazione) >= 9
                     AND
                     MONTH(data_registrazione) <= 12)
                THEN
					SET valore = 90;
				ELSEIF
					MONTH(data_registrazione) = 5
				THEN
					SET valore = 60;
				ELSEIF
					MONTH(data_registrazione) >= 6
                    AND
                    MONTH(data_registrazione) <= 8
                THEN
					SET valore = 30;
				END IF;
            END IF;
            
            INSERT INTO Registrazione(ID_Sensore, TipoSensore, Data, Orario, ValoreRegistrato)
            VALUES (sensore_attuale, tipo_sensore, data_registrazione, '17:05:05', valore);
            
            SET data_registrazione = DATE_ADD(data_registrazione, INTERVAL 3 MONTH);  
		END LOOP;
	END IF;

    
    INSERT INTO Registrazione(ID_Sensore, TipoSensore, Data, Orario, ValoreRegistrato)
    VALUES (3, 'Accelerometro X', '2020-03-01', '11:30:45', 0.1),
		   (3, 'Accelerometro Y', '2020-03-01', '11:30:45', 0.1),
           (3, 'Accelerometro Z', '2020-03-01', '11:30:45', 0.1),
           (4, 'Giroscopio X', '2020-03-01', '11:30:45', 0.06),
           (4, 'Giroscopio Y', '2020-03-01', '11:30:45', 0.06),
           (4, 'Giroscopio Z', '2020-03-01', '11:30:45', 0.06),
           (22, 'Accelerometro X', '2020-03-01', '11:30:45', 0.1),
		   (22, 'Accelerometro Y', '2020-03-01', '11:30:45', 0.1),
           (22, 'Accelerometro Z', '2020-03-01', '11:30:45', 0.1),
           (23, 'Giroscopio X', '2020-03-01', '11:30:45', 0.06),
           (23, 'Giroscopio Y', '2020-03-01', '11:30:45', 0.06),
           (23, 'Giroscopio Z', '2020-03-01', '11:30:45', 0.06),
           (175, 'Accelerometro X', '2022-04-04', '04:44:44', 0.8),
		   (175, 'Accelerometro Y', '2022-04-04', '04:44:44', 0.8),
           (175, 'Accelerometro Z', '2022-04-04', '04:44:44', 0.8),
           (176, 'Giroscopio X', '2022-04-04', '04:44:44', 0.07),
           (176, 'Giroscopio Y', '2022-04-04', '04:44:44', 0.07),
           (176, 'Giroscopio Z', '2022-04-04', '04:44:44', 0.07);

	UPDATE Edificio
    SET Stato = 1
    WHERE ID = 001 OR ID = 002;
 
    INSERT INTO Ristrutturazione(Danno, Lavoro)
		SELECT D.Codice_Danno AS Danno, L.Codice_Lavoro AS Lavoro
        FROM Danno D INNER JOIN ProgettoEdilizio PE ON D.Edificio = PE.Edificio
					 INNER JOIN Lavoro L ON PE.ID_Progetto = L.Progetto
        WHERE (D.Edificio = 001
			  OR 
               D.Edificio = 002)
			 AND
              PE.Tipo = 'Riparazione'
			 AND
              (PE.DataFine = '2020-05-14'
			  OR
               PE.DataFine = '2020-05-12');
               
	INSERT INTO CausaDanneggiamento(Danno, Area, Data, Orario)
		SELECT D.Codice_Danno AS Danno, E.Locazione AS Area, C.Data, C.Orario
		FROM Danno D INNER JOIN Edificio E ON D.Edificio = E.ID
					 INNER JOIN Calamita C ON E.Locazione = C.Area
		WHERE ((C.Area = 016 AND C.Data = '2020-03-01' AND C.Orario = '11:30:45' AND (D.Edificio = 001 OR D.Edificio = 002))
			  OR
			  (C.Area = 020 AND C.Data = '2022-04-04' AND C.Orario = '04:44:44' AND D.Edificio = 003))
              AND
               C.Nome = 'Terremoto';
    
    UPDATE Danno
    SET Riparato = TRUE
    WHERE Edificio = 001 OR Edificio = 002;
END $$
DELIMITER ;

CALL Popolamento_Impiego_Materiali();
CALL Popolamento_Turni_R();
CALL Popolamento_Turni_CL1();
CALL Popolamento_Turni_CL2();
CALL Procedura_Aggiornamento_Costo_Lavori();
CALL Popolamento_Soffitto_Pavimentazione();
CALL Popolamento_Strato();
CALL Popolamento_Disposizione();
CALL Popolamento_Sensori();
CALL Popolamento_Registrazione_Danno();

UPDATE Capocantiere
SET Pensione = TRUE
WHERE CodiceFiscale = 'MNFBRD65S27A393X';

SET SQL_SAFE_UPDATES = 1;
